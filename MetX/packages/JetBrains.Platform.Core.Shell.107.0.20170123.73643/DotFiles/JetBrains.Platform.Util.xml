<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.Util</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Util.EmptyDictionary`2">
            <summary>
            Reuses the single read-only instance of an empty dictionary (one per type).
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyList`1">
            <summary>
            Reuses the single instance of an empty list (one per type). This instance is read-only and reuses singleton enumerator.
            </summary>
        </member>
        <member name="T:JetBrains.Util.AsyncLazy`1">
            <summary>
            A lazily-calculated asynchronous value.
            </summary>
        </member>
        <member name="F:JetBrains.Util.AsyncLazy`1.myValue">
            <summary>
            Lazily-created task. Threading: simple reads, CAS writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            An explicit value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.#ctor(System.Func{`0})">
            <summary>
            A function to produce the value. This function is run within a task when the value is requested.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}})">
            <summary>
            An async lambda.
            </summary>
            <param name="afactory"></param>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.#ctor">
            <summary>
            Inheritor ctor for custom lazy init. Expected to override <see cref="M:JetBrains.Util.AsyncLazy`1.OnCustomGetValue"/> in the inheritor to provide the value if this overload is used.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.GetAwaiter">
            <summary>Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
            <returns>An awaiter instance.</returns>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.GetValueAsync">
            <summary>
              <para>Starts calculating the value asynchronously, if this is the first time the value has been called for. Returns the task to be awaited.</para>
              <para>On subsequent calls, returns the same task (either completed or not).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.GetValueCold">
            <summary>
            Cold-path for <see cref="M:JetBrains.Util.AsyncLazy`1.GetValueAsync"/> to initiate its calculation. Skipped on further calls.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AsyncLazy`1.OnCustomGetValue">
            <summary>
            Override in derived classes to avoid creating a ctor-passed lambda. Replaces the factory constructor parameter.
            This WILL NOT be called from the base ctor.
            This will be called:
            1) Never, if the user never asks for the lazy task.
            2) Once, the first time the user asks for the lazy task, if this method succeeds.
            3) If this method throws, then each next time the user asks for the lazy task, until it succeeds.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentracyGuardDiagnosticSettings">
            <summary>
            Statically switched on/ off diagnistic settings for <see cref="T:JetBrains.Threading.ReentrancyGuard"/>
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.SetupConfigurationClass">
            <summary>
            Class that implements <see cref="T:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration" />.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.SetupConfiguration">
            <summary>
            The implementation of <see cref="T:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2" />.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2">
            <summary>
            Gets information about product instances set up on the machine.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration">
            <summary>
            Gets information about product instances set up on the machine.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration.EnumInstances">
            <summary>Enumerates all product instances installed.</summary>
            <returns>An enumeration of installed product instances.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration.GetInstanceForCurrentProcess">
            <summary>Gets the instance for the current process path.</summary>
            <returns>The instance for the current process path.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration.GetInstanceForPath(System.String)">
            <summary>Gets the instance for the given path.</summary>
            <param name="path">Path used to determine instance</param>
            <returns>The instance for the given path.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2.EnumInstances">
            <summary>Enumerates all completed product instances installed.</summary>
            <returns>An enumeration of installed product instances.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2.GetInstanceForCurrentProcess">
            <summary>Gets the instance for the current process path.</summary>
            <returns>The instance for the current process path.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2.GetInstanceForPath(System.String)">
            <summary>Gets the instance for the given path.</summary>
            <param name="path">Path used to determine instance</param>
            <returns>The instance for the given path.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2.EnumAllInstances">
            <summary>Enumerates all product instances.</summary>
            <returns>An enumeration of all product instances.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference">
            <summary>A reference to a package.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetId">
            <summary>Gets the general package identifier.</summary>
            <returns>The general package identifier.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetVersion">
            <summary>Gets the version of the package.</summary>
            <returns>The version of the package.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetChip">
            <summary>Gets the target process architecture of the package.</summary>
            <returns>The target process architecture of the package.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetLanguage">
            <summary>Gets the language and optional region identifier.</summary>
            <returns>The language and optional region identifier.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetBranch">
            <summary>Gets the build branch of the package.</summary>
            <returns>The build branch of the package.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetType">
            <summary>Gets the type of the package.</summary>
            <returns>The type of the package.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupPackageReference.GetUniqueId">
            <summary>
            Gets the unique identifier consisting of all defined tokens.
            </summary>
            <returns>The unique identifier consisting of all defined tokens.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2">
            <summary>Information about an instance of a product.</summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance">
            <summary>Information about an instance of a product.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetInstanceId">
            <summary>
            Gets the instance identifier (should match the name of the parent instance directory).
            </summary>
            <returns>The instance identifier.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetInstallDate">
            <summary>
            Gets the local date and time when the installation was originally installed.
            </summary>
            <returns>The local date and time when the installation was originally installed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetInstallationName">
            <summary>
            Gets the unique name of the installation, often indicating the branch and other information used for telemetry.
            </summary>
            <returns>The unique name of the installation, often indicating the branch and other information used for telemetry.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetInstallationPath">
            <summary>
            Gets the path to the installation root of the product.
            </summary>
            <returns>The path to the installation root of the product.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetInstallationVersion">
            <summary>
            Gets the version of the product installed in this instance.
            </summary>
            <returns>The version of the product installed in this instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetDisplayName(System.Int32)">
            <summary>
            Gets the display name (title) of the product installed in this instance.
            </summary>
            <param name="lcid">The LCID for the display name.</param>
            <returns>The display name (title) of the product installed in this instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.GetDescription(System.Int32)">
            <summary>
            Gets the description of the product installed in this instance.
            </summary>
            <param name="lcid">The LCID for the description.</param>
            <returns>The description of the product installed in this instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance.ResolvePath(System.String)">
            <summary>
            Resolves the optional relative path to the root path of the instance.
            </summary>
            <param name="pwszRelativePath">A relative path within the instance to resolve, or NULL to get the root path.</param>
            <returns>The full path to the optional relative path within the instance. If the relative path is NULL, the root path will always terminate in a backslash.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetInstanceId">
            <summary>
            Gets the instance identifier (should match the name of the parent instance directory).
            </summary>
            <returns>The instance identifier.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetInstallDate">
            <summary>
            Gets the local date and time when the installation was originally installed.
            </summary>
            <returns>The local date and time when the installation was originally installed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetInstallationName">
            <summary>
            Gets the unique name of the installation, often indicating the branch and other information used for telemetry.
            </summary>
            <returns>The unique name of the installation, often indicating the branch and other information used for telemetry.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetInstallationPath">
            <summary>
            Gets the path to the installation root of the product.
            </summary>
            <returns>The path to the installation root of the product.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetInstallationVersion">
            <summary>
            Gets the version of the product installed in this instance.
            </summary>
            <returns>The version of the product installed in this instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetDisplayName(System.Int32)">
            <summary>
            Gets the display name (title) of the product installed in this instance.
            </summary>
            <param name="lcid">The LCID for the display name.</param>
            <returns>The display name (title) of the product installed in this instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetDescription(System.Int32)">
            <summary>
            Gets the description of the product installed in this instance.
            </summary>
            <param name="lcid">The LCID for the description.</param>
            <returns>The description of the product installed in this instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.ResolvePath(System.String)">
            <summary>
            Resolves the optional relative path to the root path of the instance.
            </summary>
            <param name="pwszRelativePath">A relative path within the instance to resolve, or NULL to get the root path.</param>
            <returns>The full path to the optional relative path within the instance. If the relative path is NULL, the root path will always terminate in a backslash.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetState">
            <summary>Gets the state of the instance.</summary>
            <returns>The state of the instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetPackages">
            <summary>
            Gets an array of package references registered to the instance.
            </summary>
            <returns>An array of package references registered to the instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetProduct">
            <summary>
            Gets a package reference to the product registered to the instance
            </summary>
            <returns>A package reference to the product registered to the instance. This may be null if <see cref="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetState" /> does not return <see cref="F:Microsoft.VisualStudio.Setup.Configuration.InstanceState.Complete" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2.GetProductPath">
            <summary>
            Gets the relative path to the product application, if available.
            </summary>
            <returns>The relative path to the product application, if available.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.ISetupHelper">
            <summary>Helper functions.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupHelper.ParseVersion(System.String)">
            <summary>
            Parses a dotted quad version string into a 64-bit unsigned integer.
            </summary>
            <param name="version">The dotted quad version string to parse, e.g. 1.2.3.4.</param>
            <returns>A 64-bit unsigned integer representing the version. You can compare this to other versions.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.ISetupHelper.ParseVersionRange(System.String,System.UInt64@,System.UInt64@)">
            <summary>
            Parses a dotted quad version string into a 64-bit unsigned integer.
            </summary>
            <param name="versionRange">The string containing 1 or 2 dotted quad version strings to parse, e.g. [1.0,) that means 1.0.0.0 or newer.</param>
            <param name="minVersion">A 64-bit unsigned integer representing the minimum version, which may be 0. You can compare this to other versions.</param>
            <param name="maxVersion">A 64-bit unsigned integer representing the maximum version, which may be MAXULONGLONG. You can compare this to other versions.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.InstanceState">
            <summary>
            The state of an <see cref="T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2" />.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances">
            <summary>
            A enumerator of installed <see cref="T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance" /> objects.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances.Next(System.Int32,Microsoft.VisualStudio.Setup.Configuration.ISetupInstance[],System.Int32@)">
            <summary>
            Retrieves the next set of product instances in the enumeration sequence.
            </summary>
            <param name="celt">The number of product instances to retrieve.</param>
            <param name="rgelt">A pointer to an array of <see cref="T:Microsoft.VisualStudio.Setup.Configuration.ISetupInstance" />.</param>
            <param name="pceltFetched">A pointer to the number of product instances retrieved. If celt is 1 this parameter may be NULL.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances.Skip(System.Int32)">
            <summary>
            Skips the next set of product instances in the enumeration sequence.
            </summary>
            <param name="celt">The number of product instances to skip.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances.Reset">
            <summary>Resets the enumeration sequence to the beginning.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances.Clone">
            <summary>
            Creates a new enumeration object in the same state as the current enumeration object: the new object points to the same place in the enumeration sequence.
            </summary>
            <returns>A pointer to a pointer to a new <see cref="T:Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances" /> interface. If the method fails, this parameter is undefined.</returns>
        </member>
        <member name="M:JetBrains.Util.DevEnv.EnvDteUtil.GetRunningDteInstances">
            <summary>
            Get the map of VS process ids to DTE objects.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.EnvDteUtil.ExecuteCommandWithBestDte(System.String)">
            <summary>
            Try to find the "best" VS DTE object and execute the command with it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.EnvDteUtil.ExecuteDteCommand(System.Object,System.String,System.String)">
            <summary>
            Try to execute a VS command using DTE object.
            </summary>
            <param name="dte">_DTE object. We cannot reference envdte.dll here, so we use dynamic.</param>
            <param name="command">VS command name.</param>
            <param name="args">Command arguments.</param>
            <returns>True if there was no exception. It does not mean that the command is executed, because it could be not available at the moment.</returns>
        </member>
        <member name="T:JetBrains.Util.DataFlow.Reasons`1">
            <summary>
            Collection of reasons used to allow/ suppress something.
            </summary>
            <typeparam name="T">Type of reason. Normally string is used</typeparam>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Reasons`1.AddReason(JetBrains.DataFlow.Lifetime,`0)">
            <summary>
            Adds reason for the <see cref="!:lifetime"/>
            </summary>
            <param name="lifetime">Period of time the <see cref="!:reason"/> takes place</param>
            <param name="reason">Reason itself</param>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Reasons`1.GetAllReasons">
            <summary>
            Returns all the reasons active for the moment.
            </summary>
            <returns>Active reasons</returns>
        </member>
        <member name="P:JetBrains.Util.DataFlow.Reasons`1.Name">
            <summary>
            Name of the instance. Used for debugging/ loggin purposes
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataFlow.Reasons`1.AreEmpty">
            <summary>
            Property indicating if there's any active reason
            </summary>
        </member>
        <member name="T:System.GAC.ASM_DISPLAY_FLAGS">
            <summary>
            <see cref="M:System.GAC.IAssemblyName.GetDisplayName(System.Text.StringBuilder,System.UInt32@,System.GAC.ASM_DISPLAY_FLAGS)"/>
            </summary>
        </member>
        <member name="T:System.GAC.ASM_NAME">
            <summary>
            The ASM_NAME enumeration property ID describes the valid names of the name-value pairs in an assembly name. 
            See the .NET Framework SDK for a description of these properties. 
            </summary>
        </member>
        <member name="T:System.GAC.IASSEMBLYCACHE_UNINSTALL_DISPOSITION">
            <summary>
            <see cref="M:System.GAC.IAssemblyCache.UninstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[],System.UInt32@)"/>
            </summary>
        </member>
        <member name="T:System.GAC.QUERYASMINFO_FLAG">
            <summary>
            <see cref="M:System.GAC.IAssemblyCache.QueryAssemblyInfo(System.UInt32,System.String,System.GAC.ASSEMBLY_INFO@)"/>
            </summary>
        </member>
        <member name="T:System.GAC.IASSEMBLYCACHE_INSTALL_FLAG">
            <summary>
            <see cref="M:System.GAC.IAssemblyCache.InstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[])"/>
            </summary>
        </member>
        <member name="T:System.GAC.CREATE_ASM_NAME_OBJ_FLAGS">
            <summary>
            The CREATE_ASM_NAME_OBJ_FLAGS enumeration contains the following values: 
             CANOF_PARSE_DISPLAY_NAME - If this flag is specified, the szAssemblyName parameter is a full assembly name and is parsed to 
               the individual properties. If the flag is not specified, szAssemblyName is the "Name" portion of the assembly name.
             CANOF_SET_DEFAULT_VALUES - If this flag is specified, certain properties, such as processor architecture, are set to 
               their default values.
             <see cref="M:System.GAC.AssemblyCache.CreateAssemblyNameObject(System.GAC.IAssemblyName@,System.String,System.UInt32,System.IntPtr)"/>
            </summary>
        </member>
        <member name="T:System.GAC.ASM_CACHE_FLAGS">
            <summary>
            The ASM_CACHE_FLAGS enumeration contains the following values: 
            ASM_CACHE_ZAP - Enumerates the cache of precompiled assemblies by using Ngen.exe.
            ASM_CACHE_GAC - Enumerates the GAC.
            ASM_CACHE_DOWNLOAD - Enumerates the assemblies that have been downloaded on-demand or that have been shadow-copied.
            </summary>
        </member>
        <member name="T:System.GAC.FUSION_INSTALL_REFERENCE">
            <summary>
            The FUSION_INSTALL_REFERENCE structure represents a reference that is made when an application has installed an 
            assembly in the GAC. 
            The fields of the structure are defined as follows: 
               cbSize - The size of the structure in bytes.
               dwFlags - Reserved, must be zero.
               guidScheme - The entity that adds the reference.
               szIdentifier - A unique string that identifies the application that installed the assembly.
               szNonCannonicalData - A string that is only understood by the entity that adds the reference. 
                   The GAC only stores this string.
            Possible values for the guidScheme field can be one of the following: 
               FUSION_REFCOUNT_MSI_GUID - The assembly is referenced by an application that has been installed by using 
                   Windows Installer. The szIdentifier field is set to MSI, and szNonCannonicalData is set to Windows Installer. 
                   This scheme must only be used by Windows Installer itself.
               FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID - The assembly is referenced by an application that appears in Add/Remove 
                   Programs. The szIdentifier field is the token that is used to register the application with Add/Remove programs.
               FUSION_REFCOUNT_FILEPATH_GUID - The assembly is referenced by an application that is represented by a file in 
                   the file system. The szIdentifier field is the path to this file.
               FUSION_REFCOUNT_OPAQUE_STRING_GUID - The assembly is referenced by an application that is only represented 
                   by an opaque string. The szIdentifier is this opaque string. The GAC does not perform existence checking 
                   for opaque references when you remove this.
            </summary>
        </member>
        <member name="T:System.GAC.ASSEMBLY_INFO">
            <summary>
            The ASSEMBLY_INFO structure represents information about an assembly in the assembly cache. 
            The fields of the structure are defined as follows: 
               cbAssemblyInfo - Size of the structure in bytes. Permits additions to the structure in future version of the .NET Framework.
               dwAssemblyFlags - Indicates one or more of the ASSEMBLYINFO_FLAG_* bits.
               uliAssemblySizeInKB - The size of the files that make up the assembly in kilobytes (KB).
               pszCurrentAssemblyPathBuf - A pointer to a string buffer that holds the current path of the directory that contains the 
                   files that make up the assembly. The path must end with a zero.
               cchBuf - Size of the buffer that the pszCurrentAssemblyPathBug field points to.
             dwAssemblyFlags can have one of the following values: 
               ASSEMBLYINFO_FLAG__INSTALLED - Indicates that the assembly is actually installed. Always set in current version of the 
                   .NET Framework.
               ASSEMBLYINFO_FLAG__PAYLOADRESIDENT - Never set in the current version of the .NET Framework.
            </summary>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyCache(System.GAC.IAssemblyCache@,System.UInt32)">
            <summary>
            The key entry point for reading the assembly cache.
            </summary>
            <param name="ppAsmCache">Pointer to return IAssemblyCache</param>
            <param name="dwReserved">must be 0</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyNameObject(System.GAC.IAssemblyName@,System.String,System.UInt32,System.IntPtr)">
            <summary>
            An instance of IAssemblyName is obtained by calling the CreateAssemblyNameObject API.
            </summary>
            <param name="ppAssemblyNameObj">Pointer to a memory location that receives the IAssemblyName pointer that is created.</param>
            <param name="szAssemblyName">A string representation of the assembly name or of a full assembly reference that is 
            determined by dwFlags. The string representation can be null.</param>
            <param name="dwFlags">Zero or more of the bits that are defined in the CREATE_ASM_NAME_OBJ_FLAGS enumeration.</param>
            <param name="pvReserved"> Must be null.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyEnum(System.GAC.IAssemblyEnum@,System.IntPtr,System.GAC.IAssemblyName,System.GAC.ASM_CACHE_FLAGS,System.IntPtr)">
            <summary>
            To obtain an instance of the CreateAssemblyEnum API, call the CreateAssemblyNameObject API.
            </summary>
            <param name="pEnum">Pointer to a memory location that contains the IAssemblyEnum pointer.</param>
            <param name="pUnkReserved">Must be null.</param>
            <param name="pName">An assembly name that is used to filter the enumeration. Can be null to enumerate all assemblies in the GAC.</param>
            <param name="dwFlags">Exactly one bit from the ASM_CACHE_FLAGS enumeration.</param>
            <param name="pvReserved">Must be NULL.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateInstallReferenceEnum(System.GAC.IInstallReferenceEnum@,System.GAC.IAssemblyName,System.UInt32,System.IntPtr)">
            <summary>
            To obtain an instance of the CreateInstallReferenceEnum API, call the CreateInstallReferenceEnum API.
            </summary>
            <param name="ppRefEnum">A pointer to a memory location that receives the IInstallReferenceEnum pointer.</param>
            <param name="pName">The assembly name for which the references are enumerated.</param>
            <param name="dwFlags"> Must be zero.</param>
            <param name="pvReserved">Must be null.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.GetCachePath(System.GAC.ASM_CACHE_FLAGS,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            The GetCachePath API returns the storage location of the GAC. 
            </summary>
            <param name="dwCacheFlags">Exactly one of the bits defined in the ASM_CACHE_FLAGS enumeration.</param>
            <param name="pwzCachePath">Pointer to a buffer that is to receive the path of the GAC as a Unicode string.</param>
            <param name="pcchPath">Length of the pwszCachePath buffer, in Unicode characters.</param>
        </member>
        <member name="M:System.GAC.AssemblyCache.CreateAssemblyCache">
            <summary>
            Use this method as a start for the GAC API
            </summary>
            <returns>IAssemblyCache COM interface</returns>
        </member>
        <member name="M:System.GAC.AssemblyCache.GetNextAssembly(System.GAC.IAssemblyEnum,System.GAC.IAssemblyName@)">
            <summary>
            Get the next assembly name in the current enumerator or fail
            </summary>
            <param name="enumerator"></param>
            <param name="name"></param>
            <returns>0 if the enumeration is not at its end</returns>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            The assembly is referenced by an application that has been installed by using Windows Installer. 
            The szIdentifier field is set to MSI, and szNonCannonicalData is set to Windows Installer. 
            This scheme must only be used by Windows Installer itself.
            </summary>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_FILEPATH_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            
            </summary>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_OPAQUE_STRING_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            
            </summary>
        </member>
        <member name="P:System.GAC.AssemblyCache.FUSION_REFCOUNT_MSI_GUID">
            <summary>
            GUID value for element guidScheme in the struct FUSION_INSTALL_REFERENCE
            
            </summary>
        </member>
        <member name="T:System.GAC.IAssemblyCache">
            <summary>
            The IAssemblyCache interface is the top-level interface that provides access to the GAC.
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyCache.UninstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[],System.UInt32@)">
            <summary>
            The IAssemblyCache::UninstallAssembly method removes a reference to an assembly from the GAC. 
            If other applications hold no other references to the assembly, the files that make up the assembly are removed from the GAC. 
            </summary>
            <param name="dwFlags">No flags defined. Must be zero.</param>
            <param name="pszAssemblyName">The name of the assembly. A zero-ended Unicode string.</param>
            <param name="pRefData">A pointer to a FUSION_INSTALL_REFERENCE structure. Although this is not recommended, 
               this parameter can be null. The assembly is installed without an application reference, or all existing application 
               references are gone.</param>
            <param name="pulDisposition">Pointer to an integer that indicates the action that is performed by the function.</param>
            <returns>The return values are defined as follows: 
               S_OK - The assembly has been uninstalled.
               S_FALSE - The operation succeeded, but the assembly was not removed from the GAC. 
               The reason is described in pulDisposition.</returns>
             <remarks>
             NOTE: If pulDisposition is not null, pulDisposition contains one of the following values:
               IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED - The assembly files have been removed from the GAC.
               IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE - An application is using the assembly. 
                 This value is returned on Microsoft Windows 95 and Microsoft Windows 98.
               IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED - The assembly does not exist in the GAC.
               IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING - Not used.
               IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES - The assembly has not been removed from the GAC because 
                 another application reference exists.
               IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND - The reference that is specified in pRefData is not found 
                 in the GAC.
             </remarks>
        </member>
        <member name="M:System.GAC.IAssemblyCache.QueryAssemblyInfo(System.UInt32,System.String,System.GAC.ASSEMBLY_INFO@)">
            <summary>
            The IAssemblyCache::QueryAssemblyInfo method retrieves information about an assembly from the GAC. 
            </summary>
            <param name="dwFlags">One of QUERYASMINFO_FLAG_VALIDATE or QUERYASMINFO_FLAG_GETSIZE: 
               *_VALIDATE - Performs validation of the files in the GAC against the assembly manifest, including hash verification 
                 and strong name signature verification.
               *_GETSIZE - Returns the size of all files in the assembly (disk footprint). If this is not specified, the 
                 ASSEMBLY_INFO::uliAssemblySizeInKB field is not modified.</param>
            <param name="pszAssemblyName"></param>
            <param name="pAsmInfo"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyCache.CreateAssemblyCacheItem(System.UInt32,System.IntPtr,System.GAC.IAssemblyCacheItem@,System.String)">
            <summary>
            Undocumented
            </summary>
            <param name="dwFlags"></param>
            <param name="pvReserved"></param>
            <param name="ppAsmItem"></param>
            <param name="pszAssemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyCache.CreateAssemblyScavenger(System.Object@)">
            <summary>
            Undocumented
            </summary>
            <param name="ppAsmScavenger"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyCache.InstallAssembly(System.UInt32,System.String,System.GAC.FUSION_INSTALL_REFERENCE[])">
            <summary>
            The IAssemblyCache::InstallAssembly method adds a new assembly to the GAC. The assembly must be persisted in the file 
            system and is copied to the GAC.
            </summary>
            <param name="dwFlags">At most, one of the bits of the IASSEMBLYCACHE_INSTALL_FLAG_* values can be specified: 
               *_REFRESH - If the assembly is already installed in the GAC and the file version numbers of the assembly being 
               installed are the same or later, the files are replaced.
               *_FORCE_REFRESH - The files of an existing assembly are overwritten regardless of their version number.</param>
            <param name="pszManifestFilePath"> A string pointing to the dynamic-linked library (DLL) that contains the assembly manifest. 
             Other assembly files must reside in the same directory as the DLL that contains the assembly manifest.</param>
            <param name="pRefData">A pointer to a FUSION_INSTALL_REFERENCE that indicates the application on whose behalf the 
            assembly is being installed. Although this is not recommended, this parameter can be null, but this leaves the assembly 
            without any application reference.</param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IAssemblyName">
            <summary>
            The IAssemblyName interface represents an assembly name. An assembly name includes a predetermined set of name-value pairs. 
            The assembly name is described in detail in the .NET Framework SDK.
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyName.SetProperty(System.GAC.ASM_NAME,System.IntPtr,System.UInt32)">
            <summary>
            The IAssemblyName::SetProperty method adds a name-value pair to the assembly name, or, if a name-value pair 
            with the same name already exists, modifies or deletes the value of a name-value pair.
            </summary>
            <param name="propertyId">The ID that represents the name part of the name-value pair that is to be 
            added or to be modified. Valid property IDs are defined in the ASM_NAME enumeration.</param>
            <param name="pvProperty">A pointer to a buffer that contains the value of the property.</param>
            <param name="cbProperty">The length of the pvProperty buffer in bytes. If cbProperty is zero, the name-value pair 
            is removed from the assembly name.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetProperty(System.GAC.ASM_NAME,System.IntPtr,System.UInt32@)">
            <summary>
            The IAssemblyName::GetProperty method retrieves the value of a name-value pair in the assembly name that specifies the name.
            </summary>
            <param name="propertyId">The ID that represents the name of the name-value pair whose value is to be retrieved.
            Specified property IDs are defined in the ASM_NAME enumeration.</param>
            <param name="pvProperty">A pointer to a buffer that is to contain the value of the property.</param>
            <param name="pcbProperty">The length of the pvProperty buffer, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.Finalize">
            <summary>
            The IAssemblyName::Finalize method freezes an assembly name. Additional calls to IAssemblyName::SetProperty are 
            unsuccessful after this method has been called.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetDisplayName(System.Text.StringBuilder,System.UInt32@,System.GAC.ASM_DISPLAY_FLAGS)">
            <summary>
            The IAssemblyName::GetDisplayName method returns a string representation of the assembly name.
            </summary>
            <param name="szDisplayName">A pointer to a buffer that is to contain the display name. The display name is returned in Unicode.</param>
            <param name="pccDisplayName">The size of the buffer in characters (on input). The length of the returned display name (on return).</param>
            <param name="dwDisplayFlags">One or more of the bits defined in the ASM_DISPLAY_FLAGS enumeration: 
               *_VERSION - Includes the version number as part of the display name.
               *_CULTURE - Includes the culture.
               *_PUBLIC_KEY_TOKEN - Includes the public key token.
               *_PUBLIC_KEY - Includes the public key.
               *_CUSTOM - Includes the custom part of the assembly name.
               *_PROCESSORARCHITECTURE - Includes the processor architecture.
               *_LANGUAGEID - Includes the language ID.</param>
            <returns></returns>
            <remarks>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondefaultmarshalingforstrings.asp</remarks>
        </member>
        <member name="M:System.GAC.IAssemblyName.BindToObject(System.Guid@,System.Object,System.Object,System.String,System.Int64,System.IntPtr,System.UInt32,System.IntPtr@)">
            <summary>
            Undocumented
            </summary>
            <param name="refIID"></param>
            <param name="pUnkSink"></param>
            <param name="pUnkContext"></param>
            <param name="szCodeBase"></param>
            <param name="llFlags"></param>
            <param name="pvReserved"></param>
            <param name="cbReserved"></param>
            <param name="ppv"></param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetName(System.UInt32@,System.Text.StringBuilder)">
            <summary>
            The IAssemblyName::GetName method returns the name part of the assembly name.
            </summary>
            <param name="lpcwBuffer">Size of the pwszName buffer (on input). Length of the name (on return).</param>
            <param name="pwzName">Pointer to the buffer that is to contain the name part of the assembly name.</param>
            <returns></returns>
            <remarks>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondefaultmarshalingforstrings.asp</remarks>
        </member>
        <member name="M:System.GAC.IAssemblyName.GetVersion(System.UInt32@,System.UInt32@)">
            <summary>
            The IAssemblyName::GetVersion method returns the version part of the assembly name.
            </summary>
            <param name="pdwVersionHi">Pointer to a DWORD that contains the upper 32 bits of the version number.</param>
            <param name="pdwVersionLow">Pointer to a DWORD that contain the lower 32 bits of the version number.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.IsEqual(System.GAC.IAssemblyName,System.GAC.ASM_CMP_FLAGS)">
            <summary>
            The IAssemblyName::IsEqual method compares the assembly name to another assembly names.
            </summary>
            <param name="pName">The assembly name to compare to.</param>
            <param name="dwCmpFlags">Indicates which part of the assembly name to use in the comparison. 
            Values are one or more of the bits defined in the ASM_CMP_FLAGS enumeration.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyName.Clone(System.GAC.IAssemblyName@)">
            <summary>
            The IAssemblyName::Clone method creates a copy of an assembly name. 
            </summary>
            <param name="pName"></param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IAssemblyEnum">
            <summary>
            The IAssemblyEnum interface enumerates the assemblies in the GAC.
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyEnum.GetNextAssembly(System.IntPtr,System.GAC.IAssemblyName@,System.UInt32)">
            <summary>
            The IAssemblyEnum::GetNextAssembly method enumerates the assemblies in the GAC. 
            </summary>
            <param name="pvReserved">Must be null.</param>
            <param name="ppName">Pointer to a memory location that is to receive the interface pointer to the assembly 
            name of the next assembly that is enumerated.</param>
            <param name="dwFlags">Must be zero.</param>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyEnum.Reset">
            <summary>
            Undocumented. Best guess: reset the enumeration to the first assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.GAC.IAssemblyEnum.Clone(System.GAC.IAssemblyEnum@)">
            <summary>
            Undocumented. Create a copy of the assembly enum that is independently enumerable.
            </summary>
            <param name="ppEnum"></param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IInstallReferenceItem">
            <summary>
            The IInstallReferenceItem interface represents a reference that has been set on an assembly in the GAC. 
            Instances of IInstallReferenceIteam are returned by the IInstallReferenceEnum interface.
            </summary>
        </member>
        <member name="M:System.GAC.IInstallReferenceItem.GetReference(System.GAC.FUSION_INSTALL_REFERENCE[]@,System.UInt32,System.IntPtr)">
            <summary>
            The IInstallReferenceItem::GetReference method returns a FUSION_INSTALL_REFERENCE structure. 
            </summary>
            <param name="ppRefData">A pointer to a FUSION_INSTALL_REFERENCE structure. The memory is allocated by the GetReference 
            method and is freed when IInstallReferenceItem is released. Callers must not hold a reference to this buffer after the 
            IInstallReferenceItem object is released.</param>
            <param name="dwFlags">Must be zero.</param>
            <param name="pvReserved">Must be null.</param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IInstallReferenceEnum">
            <summary>
            The IInstallReferenceEnum interface enumerates all references that are set on an assembly in the GAC.
            NOTE: References that belong to the assembly are locked for changes while those references are being enumerated. 
            </summary>
        </member>
        <member name="M:System.GAC.IInstallReferenceEnum.GetNextInstallReferenceItem(System.GAC.IInstallReferenceItem@,System.UInt32,System.IntPtr)">
            <summary>
            IInstallReferenceEnum::GetNextInstallReferenceItem returns the next reference information for an assembly. 
            </summary>
            <param name="ppRefItem">Pointer to a memory location that receives the IInstallReferenceItem pointer.</param>
            <param name="dwFlags">Must be zero.</param>
            <param name="pvReserved">Must be null.</param>
            <returns></returns>
        </member>
        <member name="T:System.GAC.IAssemblyCacheItem">
            <summary>
            Undocumented. Probably only for internal use.
            <see cref="M:System.GAC.IAssemblyCache.CreateAssemblyCacheItem(System.UInt32,System.IntPtr,System.GAC.IAssemblyCacheItem@,System.String)"/>
            </summary>
        </member>
        <member name="M:System.GAC.IAssemblyCacheItem.CreateStream(System.UInt32,System.String,System.UInt32,System.UInt32,System.Runtime.InteropServices.ComTypes.IStream@,System.Int64@)">
            <summary>
            Undocumented.
            </summary>
            <param name="dwFlags"></param>
            <param name="pszStreamName"></param>
            <param name="dwFormat"></param>
            <param name="dwFormatFlags"></param>
            <param name="ppIStream"></param>
            <param name="puliMaxSize"></param>
        </member>
        <member name="M:System.GAC.IAssemblyCacheItem.Commit(System.UInt32,System.Int64@)">
            <summary>
            Undocumented.
            </summary>
            <param name="dwFlags"></param>
            <param name="pulDisposition"></param>
        </member>
        <member name="M:System.GAC.IAssemblyCacheItem.AbortItem">
            <summary>
            Undocumented.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetRuntimes">
            <summary>
            Windows, OS wide, .NET Frameworks installed on this machine.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetRuntimes.Instance">
            <summary>
            Current system bitness
            </summary>
        </member>
        <member name="P:JetBrains.Util.Dotnet.MicrosoftDotNet.DotNetRuntimes.Instances32">
            <summary>
            Current system when running 32 bits, Wow on 64 bits.
            </summary>
        </member>
        <member name="F:JetBrains.Application.platforms.FrameworkIdentifier.NetCore45">
            <summary>
            .net core for windows 8 and 8.1
            </summary>
        </member>
        <member name="M:JetBrains.Util.Dotnet.MicrosoftDotNet.ReferenceAssemblies.GetReferenceAssembliesFolder">
            <summary>
            discovers reference assemblies starting from 3.5 client profile.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Dotnet.Mono.MonoInstance">
            <summary>
            Instance of mono installation. Every mono instance is equivalent to the whole .net framework on windows.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DevEnv.DevenvHostDiscovery">
            <summary>
            Shares some Devenv discovery code which is also required in non-devenv-specific code, like installers and assembly resolvers.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.VisualStudioRegistryPathNoHive">
            <summary>
            Gets the version-independent Registry Visuyal Studio path prefix.
            Currently, <c>"Software\Microsoft\VisualStudio"</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.VsOutOfGacAssemblyFoldersUnderInstalldir">
            <summary>
            The subfolders under VS InstallDir which might contain those DLLs previously in the GAC which are now side-by-side shipped within VS 15+ without a global registration.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.VsVersionMinRecognized7">
            <summary>
            This skips VS6 which is still found in the wild(!) [RSRP-462081] and would be useless on our discovered VSes list.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.VsVersionUnluckyDumped13">
            <summary>
            This skips the VS 13 which has never been released and 14 goes after 12 because fuck you that's why.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVs">
            <summary>
            Enumerates Visual Studio versions found installed on this machine. This should include side-by-side installations of the new VSes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVs(JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVsFlags)">
            <summary>
            Enumerates Visual Studio versions found installed on this machine. This should include side-by-side installations of the new VSes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.GetMsEnvDllPath">
            <summary>
            Knowing that VS environment is based on <c>msenv.dll</c>, gets the path of the loaded module.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.GetVisualStudioRegistryPath(System.String)">
            <summary>
            Gets the Visual Studio registry path prefix for a specific Registry hive.
            Example: <c>“Software\Microsoft\VisualStudio\8.0ReSharper”</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.GetVsAppDataPath(System.Environment.SpecialFolder,JetBrains.Util.DevEnv.Hive)">
            <summary>
            Gets the path to the Visual Studio local/roaming/common appdata folder for the given VS Hive.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.GetVsInstallDir(JetBrains.Util.DevEnv.Hive,JetBrains.Util.OnError)">
            <summary>
            Retrieves the Devenv Installdir for the specific hive.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.GetVsInstallDirFromRegistryRaw(JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.OnError)">
            <summary>
            Reads the Registry Hive at the supplied Registry path to read the InstallDir.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.TryGetVsVersionFromDllVersion">
            <summary>
            As recommended by MSFT, tries to get the full 4-component VS version from fileversion of <c>msenv.dll</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVsCore(JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVsFlags,JetBrains.Util.OnError)">
            <summary>
            Enumerates Visual Studio versions found installed on this machine. This should include side-by-side installations of the new VSes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DevEnv.DevenvHostDiscovery.GetInstalledVs15Lightweight_Build_2016_07_07(JetBrains.Util.OnError)">
            <summary>
            VS 15 lt Preview 3 on 2016-07-07.
            </summary>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVsFlags.AddPackagesListing">
            <summary>
            Fills the <see cref="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.PackagesIfKnown"/> list for those VS versions which expose this information.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.DisplayNameLong">
            <summary>
            The long display name for descriptions and tooltips.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.DisplayNameShort">
            <summary>
            The short display name for list items.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.Hive">
            <summary>
            The VS Hive, which consists of a two-component version and optional instance id and root suffix.
            This is enough for identifying the VS instance in most of the cases.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.InstallDir">
            <summary>
            InstallDir of VS, which is the directory with <c>devenv.exe</c>, <c>$(InstallRoot)/Common7/IDE</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.PackagesIfKnown">
            <summary>
            Gets the list of VS packages. <c>NULL</c> if not known. Empty if known to be empty.
            This info is only available for VS 15 RC and later, and if the <see cref="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.EnumInstalledVsFlags.AddPackagesListing"/> were specified.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVs.IsIncomplete">
            <summary>
            VS installation is incomplete. Applicable to VS 2017+ only.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVsPackage.RawVersion">
            <summary>
            Version. Didn't bother to parse the format yet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVsPackage.Type">
            <summary>
            Package type, see <see cref="T:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVsPackage.WellKnownTypes"/> for reference.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVsPackage.WellKnownTypes.Product">
            <summary>
            Should be the only Product component, identifies the installation itself.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DevEnv.DevenvHostDiscovery.InstalledVsPackage.WellKnownTypes.Workload">
            <summary>
            Workloads are big buttons in the installer to select the roles.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DevEnv.DevenvHostDiscovery.VsSetupConfigurationInterop">
            <summary>
            Calls into the VS Setup Configuration COM Object, if present on this machine.
            This should serve VS instances starting with VS15 RC.
            Brought into a separate class to help with containing possible JIT-time exceptions.
            </summary>
        </member>
        <member name="T:JetBrains.Util.IUserDataHolder">
            <summary>
            Represents the "user data holder" pattern.
            The user data holder pattern can be used for associating 
            client-specific data with instances of certain type. 
            To let associating of user data with instances of 
            some type it should implement IUserDataHolder interface.
            It allows putting object values by arbitrary keys 
            of type <see cref="T:JetBrains.Util.Key"/>.   
            </summary>   
            <example> Example of usage: 
            <code>
              private const Key KEY = new Key("descriptor");
              
              ....
              {
                MyDataType dataToStore = ... 
                holder.PutData(KEY, dataToStore); 
                ....
                MyDataType restoredData = (MyDataType)holder.GetData(KEY); 
              }
            </code>
            </example>
            <seealso cref="T:JetBrains.Util.Key"/>
        </member>
        <member name="M:JetBrains.Util.IUserDataHolder.PutData``1(JetBrains.Util.Key{``0},``0)">
            <summary>
            Stores given value by specified key.
            Use <code>PutData(key, null)</code> to remove the association.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IUserDataHolder.GetData``1(JetBrains.Util.Key{``0})">
            <summary>
            Retrieves value associated with given key.
            Returns null when no value is associated.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DevEnv.Hive">
            <summary>
            A hive, e.g. in Visual Studio, is a two-component version number, plus an optional string for the root suffix.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DevEnv.Hive.HiveString">
            <summary>
            Gets the canonical textual representation of the hive.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.TypeConverterBase`1">
            <summary>
            A base class for quickly implementing a <see cref="T:System.ComponentModel.TypeConverter"/> for some class <typeparamref name="T"/> (attached thru <see cref="T:System.ComponentModel.TypeConverterAttribute"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.TypeConverterBase`1.#ctor(System.Func{System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,`0,System.String},System.Func{System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.String,`0})">
            <summary>
            An overload which gets the full <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> into the methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.TypeConverterBase`1.#ctor(System.Func{System.Globalization.CultureInfo,`0,JetBrains.Util.ILogger,System.String},System.Func{System.Globalization.CultureInfo,System.String,JetBrains.Util.ILogger,`0})">
            <summary>
            An overload which supplies the logger into the methods, either the <see cref="T:JetBrains.Util.ILogger"/> obtained from the <see cref="T:System.ComponentModel.ITypeDescriptorContext"/>, or the default logger dumping into the static <see cref="T:JetBrains.Util.Logging.Logger"/> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.TypeConverterBase`1.#ctor(System.Func{`0,System.String},System.Func{System.String,`0})">
            <summary>
            The simplest overload which fits the most cases.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.ValueSerializerBase`1">
            <summary>
            A base class for quickly implementing a <see cref="T:System.Windows.Markup.ValueSerializer"/> for some class <typeparamref name="T"/> (attached thru <see cref="T:System.Windows.Markup.ValueSerializerAttribute"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.ValueSerializerBase`1.#ctor(System.Func{System.Windows.Markup.IValueSerializerContext,`0,System.String},System.Func{System.Windows.Markup.IValueSerializerContext,System.String,`0})">
            <summary>
            An overload which gets the full <see cref="T:System.Windows.Markup.IValueSerializerContext"/> into the methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.ValueSerializerBase`1.#ctor(System.Func{`0,JetBrains.Util.ILogger,System.String},System.Func{System.String,JetBrains.Util.ILogger,`0})">
            <summary>
            An overload which supplies the logger into the methods, either the <see cref="T:JetBrains.Util.ILogger"/> obtained from the <see cref="T:System.Windows.Markup.IValueSerializerContext"/>, or the default logger dumping into the static <see cref="T:JetBrains.Util.Logging.Logger"/> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.ValueSerializerBase`1.#ctor(System.Func{`0,System.String},System.Func{System.String,`0})">
            <summary>
            The simplest overload which fits the most cases.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.ErrorLevelException">
            <summary>
            An exception upon the process exit code (ERRORLEVEL) indicating an error.
            </summary>
        </member>
        <member name="F:JetBrains.Util.MethodImplAdvancedOptions.AggressiveInlining">
            <summary>
            Corresponds to <code>MethodImplOptions.AggressiveInlining</code> value in 4.5 framework. This value is just swallowed in lower frameworks
            </summary>
        </member>
        <member name="T:JetBrains.Util.Bdd.BddNode">
            <summary>
              <h1>Node structure</h1>
              2 PARTS = 2 integers (8 bytes)
              Rem. 3 byte for regular's node number => 8*256^3 bytes = 128 Mb for full node addressing, more than enough
              There are two types of nodes - REGULAR and SPECIAL. REGULAR nodes are stored in memory, SPECIAL are not.
              If highest bit of first node is 1, then node is REGULAR, otherwise SPECIAL.
              REGULAR node:
              Next two highest bits of first integer (very highest is for node type) marks following
              00 - left and right childs are REGULAR
              01 - left child is REGULAR, right child is SPECIAL
              10 - left child is SPECIAL, right is REGULAR
              11 - left and right childs are SPECIAL
              1 bit - flag
              4 bits + 5rd byte - variable; nodes with HIGHER variable can reference nodes with LOWER variable as child and NOT
              vice versa.
              2-4 bytes - left child. If left child is regular then link to memory. Otherwise(SPECIAL) 1 byte -
              highest_var_of_child/4,
              6-8 bytes - right child. the same
              
            
              Special node
            
              4 small bits of 1st byte + 5rd byte - variable of cluster
              2-4 bytes - value of cluster
              <h1>Operations to implement</h1>
              
            </summary>
        </member>
        <member name="T:JetBrains.Util.BitHacks">
            <summary>
            Inspired by http://graphics.stanford.edu/~seander/bithacks.html
            </summary>
        </member>
        <member name="T:JetBrains.Util.BooleanBoxes">
            <summary>
            Avoid boxing boolean by reusing the boxes for readonly purposes.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.StrongCachedValue`2">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Caches.ICachedValue`1"/> that holds value forever until <see cref="M:JetBrains.Util.Caches.StrongCachedValue`2.Clear"/> method is called.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.ICachedValue`1">
            <summary>
            Cached value with nonparameterized producer
            </summary>
            <typeparam name="T">type of object</typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.ICachedValueBase`1">
            <summary>
            Wrapper over object. Typical usage is <see cref="T:JetBrains.Util.Caches.WeakCachedValue`2"/>.
            </summary>
            <typeparam name="T">type of object</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValueBase`1.Set(`0)">
            <summary>
            Set object's value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValueBase`1.Clear">
            <summary>
            Resets object's value to default
            </summary>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValueBase`1.TryGet">
            <summary>
            Get current value in wrapper. If it's null (e.g. weak reference evicted) returns null
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate">
            <summary>
            Get current value and if it's null then produce value (using producer func)
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Caches.IParametrizedCachedValue`2">
            <summary>
            Cached value with parameterized producer. Use it in case you don't want to create tons of closure.
            </summary>
            <typeparam name="T">type of object</typeparam>
            <typeparam name="TFunctorParameter">type of addtitional paramater to producer function</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.IParametrizedCachedValue`2.GetOrCreate(`1)">
            <summary>
            Get current value and if it's null then produce value (using producer func with parameter)
            </summary>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IParametrizedCachedValue`2.GetOrCreate(`1,`0@)">
            <summary>
            Version of GetOrCreate that returns boolean value which designates whether value was created by producer or obtained from cache
            </summary>
            <param name="parameter"></param>
            <param name="result">gotten or created result</param>
            <returns>true if value was created by producer, false - value was in cache already</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IParametrizedCachedValue`2.TryGetSync">
            <summary>
            Get current value, waiting if current value is being created by "GetOrCreate" method
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Caches.WeakCachedValueBase`2">
            <summary>
            Base class for both <see cref="T:JetBrains.Util.Caches.WeakParametrizedCachedValue`3"/> and <see cref="T:JetBrains.Util.Caches.WeakCachedValue`2"/>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCacheItem"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.WeakParametrizedCachedValue`3">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Caches.IParametrizedCachedValue`2"/> that hold value on weak reference. Additionally, value is put into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>.
            So weak reference will survive garbage collections until it's value is evicted from cache. Cache is being touched not every time you invoke <see cref="M:JetBrains.Util.Caches.WeakParametrizedCachedValue`3.GetOrCreate(`1)"/>
            but every [cacheTouchFrequency] time. This allows to mix LRU and LFU policies together and inrease performance.
            </summary>
            <typeparam name="T">type of value </typeparam>
            <typeparam name="TCacheItem">Cache can contains more general type than <typeparamref name="T"/> </typeparam>
            <typeparam name="TParameter">Type of producer function's parameter</typeparam>  
        </member>
        <member name="T:JetBrains.Util.Caches.WeakCachedValue`2">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Caches.ICachedValue`1"/> that hold value on weak reference. Additionally, value is put into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>.
            So weak reference will survive garbage collections until it's value is evicted from cache. Cache is being touched not every time you invoke <see cref="M:JetBrains.Util.Caches.WeakCachedValue`2.GetOrCreate"/>
            but every [cacheTouchFrequency] time. This allows to mix LRU and LFU policies together and inrease performance.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCacheItem">Cache can contains more general type than <typeparamref name="T"/> </typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.IDictionaryBasedCache`2">
            <summary>
            Cache represented by fixed-size dictionary. The behavior is the same as <see cref="T:System.Collections.Generic.IDictionary`2"/> but dictionary doesn't grow infinitely.
            When cache is full, newest elements is put into it, evicting old one (latest or least freaquently used, depending on policy).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2">
            <summary>
            Unlimited cache that evicts their items by inactivity time using a timer
            It stores and updates access time for each item on TryGetFromCache() and AddToCache() methods
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2.#ctor(JetBrains.DataFlow.Lifetime,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="lifetime">Lifetime for managing timer</param>
            <param name="evictionAttemptIntervalMs">Eviction attempts interval. Min is 100 ms</param>
            <param name="itemLifetimeToEvictMs">Max age of item. If item is older it will be evicted. Min is 100 ms. Must be greater than <paramref name="evictionAttemptIntervalMs"/></param>
            <param name="comparer">custom comparer</param>
        </member>
        <member name="E:JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2.AfterItemEvicted">
            <summary>
            Called after the specified key is evicted from cache. Called from timer thread.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.EnumeratorEnumerable">
            <summary>
            If we can only get an enumerator, wraps it with an enumerable to allow for using LINQ and so on.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.Bunch4`1">
            <summary>
            Represents a 4-cell value type array.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.Bunch4`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.Bunch4`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch4`1.Length">
            <summary>
            Gets the maximum size of the <see cref="T:JetBrains.Util.Collections.Fixed.Bunch4`1"/> collection.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch4`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less then zero -or- greater than maximum length of the bunch.
            </exception>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.Bunch8`1">
            <summary>
            Represents a 8-cell value type array.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.Bunch8`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.Bunch8`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch8`1.Length">
            <summary>
            Gets the maximum size of the <see cref="T:JetBrains.Util.Collections.Fixed.Bunch8`1"/> collection.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch8`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less then zero -or- greater than maximum length of the bunch.
            </exception>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.Bunch16`1">
            <summary>
            Represents a 16-cell value type array.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.Bunch16`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.Bunch16`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch16`1.Length">
            <summary>
            Gets the maximum size of the <see cref="T:JetBrains.Util.Collections.Fixed.Bunch16`1"/> collection.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch16`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less then zero -or- greater than maximum length of the bunch.
            </exception>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.Bunch32`1">
            <summary>
            Represents a 32-cell value type array.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.Bunch32`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.Bunch32`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch32`1.Length">
            <summary>
            Gets the maximum size of the <see cref="T:JetBrains.Util.Collections.Fixed.Bunch32`1"/> collection.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch32`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less then zero -or- greater than maximum length of the bunch.
            </exception>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.Bunch64`1">
            <summary>
            Represents a 64-cell value type array.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.Bunch64`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.Bunch64`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch64`1.Length">
            <summary>
            Gets the maximum size of the <see cref="T:JetBrains.Util.Collections.Fixed.Bunch64`1"/> collection.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.Fixed.Bunch64`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less then zero -or- greater than maximum length of the bunch.
            </exception>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.List4`1">
            <summary>
            Represents a value type collection with fixed capacity equal to 4.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.List4`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.List4`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.List8`1">
            <summary>
            Represents a value type collection with fixed capacity equal to 8.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.List8`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.List8`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.List16`1">
            <summary>
            Represents a value type collection with fixed capacity equal to 16.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.List16`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.List16`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.List32`1">
            <summary>
            Represents a value type collection with fixed capacity equal to 32.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.List32`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.List32`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="T:JetBrains.Util.Collections.Fixed.List64`1">
            <summary>
            Represents a value type collection with fixed capacity equal to 64.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.Fixed.List64`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bunch.
            </summary>
            <returns>An <see cref="T:JetBrains.Util.Collections.Fixed.List64`1.Enumerator"/> that can be used to iterate through the bunch.</returns>
        </member>
        <member name="T:JetBrains.Application.Progress.CombinedProgressIndicator">
            <summary>
              Progress indicator that combined multiple indicators
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.IProgressIndicator">
            <summary>
            <para>Given to a lengthy task that knows its progress, used to enable the UI indications of the task progress.</para>
            <para>You should read all of the member summaries before using this class.</para>
            </summary>
            <seealso cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/>
        </member>
        <member name="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)">
            <summary>
            <para>Advances the progress within the range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> call.</para>
            <para><see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> MUST be called first.</para>
            </summary>
            <param name="units">A whole or fractional number of units from the [0..totalWorkUnits] range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> method.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)">
            <summary>
            <para>Starts the progress to run through the [0..totalWorkUnits] range. You MUST call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> at the end. Use <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> to identify the current execution span, once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>, and change the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> when doing <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.IProgressIndicator.Stop">
            <summary>
            <para>Completes the progress run. You MUST call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> if you previously called <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>.</para>
            <para>Generally, you SHOULD always call the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> pair on the given indicator, even if gotten no items to process, so that a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> could use up the parent range consistently.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicator.TaskName">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Threading.OnWaitTimeout">
            <summary>
              <para>Tells what to do if we performed a conditional wait with a timeout, and it has timed out.</para>
              <para>The default is to throw.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.OnWaitTimeout.Fail">
            <summary>
            Throws an exception, fails the task, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.OnWaitTimeout.Succeed">
            <summary>
            Abandons the wait and proceeds.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalListAsIList`1">
            <summary>
            A readonly helper to expose the <see cref="T:System.Collections.Generic.IEnumerable`1"/> and alike interface from <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1"/>. Boxes the structure explicitly.
            You SHOULD do C# <c>foreach</c> right on the list, which will cause the compiler to emit code which calls into the original struct public methods directly.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalListAsIList`1.Enumerator">
            <summary>
            Does not share the enumerator class/struct with the list itself because that one does not implement the interfaces, which allows to skip on <see cref="M:System.IDisposable.Dispose"/> and try-finally sections in emitted code.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalListEnumerator`1">
            <summary>
            The minimal enumerator implementation for the <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1"/>. Only supports C# <c>foreach</c>, does not have even <c>Dispose</c> to save on try-finally sections.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalListEx.IsEmpty``1(JetBrains.Util.dataStructures.FrugalLocalList{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection" /> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="T:JetBrains.Application.Progress.LiveCombinedProgressIndicator">
            <summary>
              Progress indicator that combined multiple indicators and support live add/remove indicator
            </summary>
        </member>
        <member name="T:JetBrains.Util.Memory.IMemoryGrave">
            <summary>
            A collection of objects to be checked for a memory leak.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPathOpenEx">
            <summary>
            FSP ext methods specifically related to opening underlying files for reading/writing/etc.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForAppend(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens the file, keeps the content, rewinds to the end, allows any concurrent operations on this same file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForAppendDenyWrite(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens the file, keeps the content, rewinds to the end, denies alien writes, allows alien reads.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForReading(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens a stream on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForReadingDenyWrite(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForReadingExclusive(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWriting(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens a stream on this file system path for writing, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWritingDenyWrite(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens a stream on this file system path for writing, preventing all other parties from writing the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWritingExclusive(JetBrains.Util.FileSystemPath)">
            <summary>
              <para>Opens a stream on this file system path for writing, preventing all other parties from reading or writing the stream at the same time. </para>
              <para>Most often you'd like to use <see cref="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWritingDenyWrite(JetBrains.Util.FileSystemPath)"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenStreamWithWaitingOnLock(JetBrains.Util.FileSystemPath,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Nullable{System.TimeSpan})">
            <summary>
            Opens a stream on this file system path. If the file is currently opened with access which conflicts with us, awaits for the file to get released for some time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadAllText2(JetBrains.Util.FileSystemPath,System.Text.Encoding)">
            <summary>
            If encoding is not specified, uses the smart detection algorithm of Visual Studio which has a good sense of when to treat a non-ASCII non-BOM file as UTF-8 or ANSI.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadBinaryStream(JetBrains.Util.FileSystemPath,System.Action{System.IO.BinaryReader})">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadBinaryStream``1(JetBrains.Util.FileSystemPath,System.Func{System.IO.BinaryReader,``0})">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStream(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStream``1(JetBrains.Util.FileSystemPath,System.Func{System.IO.Stream,``0})">
            <summary>
            Opens a stream on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStreamExclusive(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadTextStream(JetBrains.Util.FileSystemPath,System.Action{System.IO.StreamReader},System.Text.Encoding)">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadTextStream``1(JetBrains.Util.FileSystemPath,System.Func{System.IO.StreamReader,``0},System.Text.Encoding)">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteBinaryStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.BinaryWriter})">
            <summary>
            Opens a binary-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteStream(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for writing, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
              <para>Opens a stream on this file system path for writing, preventing all other parties from writing the stream at the same time.</para>
              <para>Most often you would like to use <see cref="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamExclusive(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
              <para>Opens a stream on this file system path for writing, preventing all other parties from reading or writing the stream at the same time.</para>
              <para>Most often you would like to use <see cref="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteTextStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.StreamWriter})">
            <summary>
            Opens a stream-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteTextStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Text.Encoding,System.Action{System.IO.StreamWriter})">
            <summary>
            Opens a stream-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.EnsureFileDirectory(JetBrains.Util.FileSystemPath)">
            <summary>
            Before writing a file, make sure its directory actually exists.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:JetBrains.Util.NumberUtilParsing.TryParseFloatingPoint(System.Byte*,System.UInt32,System.Double*)">
            <summary>
            Duplicates the code in <see cref="M:System.Double.TryParse(System.String,System.Double@)"/>, as borrowed from CoreCLR, with the following differences:
            (1) Parses only for <c>AllowLeadingSign+AllowExponent+AllowDecimalPoint</c>. No currency, no thousands.
            (2) Parses only for the Invariant Culture, only dots for decimal points.
            (3) Operates on the memory pointer rather than a string managed object. This is the key point.
            (4) Does not need a terminating zero at the end of the string. This allows to parse a part of the input stream.
            (5) The input is in bytes, and is assumed to be in a multibyte encoding such as ASCII or ANSI or UTF-8 — for normal doubles, that's no difference, with the exception of the “∞” char which might occur in the <see cref="F:System.Double.PositiveInfinity"/> <see cref="M:System.Double.ToString"/> in <c>R</c> mode, which is expected to be expressed as three UTF-8 bytes. Any unexpected byte value aborts parsing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.NumberUtilParsing.TryParseFloatingPoint(System.String,System.Double@)">
            <summary>
            Façade for parsing from a regular string, mostly for testing purposes, as it makes a slower version of <see cref="M:System.Double.Parse(System.String)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.NumberUtilParsing.NumberCpp.rgexp64Power10">
            <summary>
            exponents for both powers of 10 and 0.1
            </summary>
        </member>
        <member name="F:JetBrains.Util.NumberUtilParsing.NumberCpp.rgexp64Power10By16">
            <summary>
            // exponents for both powers of 10^16 and 0.1^16
            </summary>
        </member>
        <member name="M:JetBrains.Util.NumberUtilParsing.NumberCpp.AssembleIeeeDoubleBits(JetBrains.Util.NumberUtilParsing.NumberCpp.FloatingData*,System.Double*)">
            <summary>
            The <c>NumberToDouble</c> method from <c>number.cpp</c>.
            </summary>
            <param name="number"></param>
            <param name="value"></param>
        </member>
        <member name="F:JetBrains.Util.NumberUtilParsing.NumberCpp.FloatingData.Digits">
            <summary>
            ASCII chars, numbers only, buffer must be long enough for NumberMaxDigits (plus NULL), has <see cref="F:JetBrains.Util.NumberUtilParsing.NumberCpp.FloatingData.Precision"/> meaningful bytes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.NumberUtilParsing.NumberCpp.FloatingData.Precision">
            <summary>
            Number of meaningful digits.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ObservableRangeCollection`1">
            <summary> 
            Represents a dynamic data collection that provides notifications when items get added, removed, or when the whole list is refreshed. 
            </summary> 
            <typeparam name="T"></typeparam> 
        </member>
        <member name="M:JetBrains.Util.ObservableRangeCollection`1.AddRange(System.Collections.Generic.IList{`0})">
            <summary> 
            Adds the elements of the specified collection to the end of the ObservableCollection(Of T). 
            </summary> 
        </member>
        <member name="M:JetBrains.Util.ObservableRangeCollection`1.RemoveRange(System.Collections.Generic.IList{`0})">
            <summary> 
            Removes the first occurrence of each item in the specified collection from ObservableCollection(Of T). 
            </summary> 
        </member>
        <member name="M:JetBrains.Util.ObservableRangeCollection`1.Replace(`0)">
            <summary> 
            Clears the current collection and replaces it with the specified item. 
            </summary> 
        </member>
        <member name="M:JetBrains.Util.ObservableRangeCollection`1.ReplaceRange(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Clears the current collection and replaces it with the specified collection. 
            </summary> 
        </member>
        <member name="M:JetBrains.Util.ObservableRangeCollection`1.#ctor">
            <summary> 
            Initializes a new instance of the System.Collections.ObjectModel.ObservableCollection(Of T) class. 
            </summary> 
        </member>
        <member name="M:JetBrains.Util.ObservableRangeCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Initializes a new instance of the System.Collections.ObjectModel.ObservableCollection(Of T) class that contains elements copied from the specified collection. 
            </summary> 
            <param name="collection">collection: The collection from which the elements are copied.</param> 
            <exception cref="T:System.ArgumentNullException">The collection parameter cannot be null.</exception> 
        </member>
        <member name="T:JetBrains.Util.Memory.LeakWatchdog">
            <summary>
            An utility to monitor memory leaks.
            </summary>
            <remarks>
            The class made static to be able to survive R# suspend/resume.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Memory.LeakWatchdog.GetOrCreateGrave(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Get a memory grave for the specified lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.LeakWatchdog.RegisterObject(JetBrains.DataFlow.Lifetime,System.Object,System.String)">
            <summary>
            Register the object with the leak watchdog. Objects with the same lifetime will be placed in one memory grave.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.LeakWatchdog.RegisterTerminatedObject(System.Object,System.TimeSpan,JetBrains.Util.Memory.LeakWatchdog.Mode,System.Action{System.Int32})">
            <summary>
            Immediate starts to wait for the object to be collected.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.LeakWatchdog.Mode.Passive">
            <summary>
            Let objects to be garbage collected in the "natural" way.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.LeakWatchdog.Mode.ForceGc">
            <summary>
            Force GC to collect the objects.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Memory.LeakWatchdog.GcWaitingGrave">
            <summary>
            Wait for objects to be collected in the specified amount of full GC.
            </summary>
            <remarks>
            There is no timeout, because GC is non-deterministic.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.Memory.LeakWatchdog.GcWaitingGrave.GcWaitCount">
            <summary>
            In most cases 3 full GC is enough to collect an object.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Memory.LeakWatchdog.TimeLimitedGrave">
            <summary>
            Wait for objects to be collected for the specified timeout.
            </summary>
        </member>
        <member name="T:MimeTypes.MimeTypeMap">
            <remarks>https://github.com/samuelneff/MimeTypeMap</remarks>>
        </member>
        <member name="M:JetBrains.Util.Extension.JavaCompatibilityStringExtensions.ToRegistryValue(System.String)">
            Converts value string to it Windows representation.
            as a byte-encoded string.
            Encoding algorithm adds "/" character to capital letters, i.e.
            "A" is encoded as "/A". Character '\' is encoded as '//',
            '/' is encoded as  '\'.
            Then encoding scheme similar to jdk's native2ascii converter is used
            to convert java string to a byte array of ASCII characters.
        </member>
        <member name="M:JetBrains.Util.Extension.JavaCompatibilityStringExtensions.FromRegistryValue(System.String)">
            Converts value string from its Windows representation
            to java string.  See
            {@link #toWindowsValueString(String) toWindowsValueString()} for the
            description of the encoding algorithm.
        </member>
        <member name="T:JetBrains.Util.ReparsePoints">
            <summary>
            Wraps Windows NT APIs for working with NTFS reparse points. The first implementation supports Directory Junctions (aka Mount Points).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Frameworks.FrameworkRegistryData">
            <summary>
            Represents registry "Version" and "Release" keys that are necessary to built marketing version of .NET framework
            https://msdn.microsoft.com/en-us/library/hh925568.aspx 
            </summary>
        </member>
        <member name="P:JetBrains.Util.Frameworks.FrameworkRegistryData.Version">
            <summary>
            Raw value of "Version" registry key 
            </summary>
        </member>
        <member name="P:JetBrains.Util.Frameworks.FrameworkRegistryData.Release">
            <summary>
            Raw value of "Release" registry key
            </summary>
        </member>
        <member name="T:JetBrains.Util.StandardFolderLocationsStatic">
            <summary>
            This class gives standard folder locations for raw static utils.
            Any code running in shelled apps should use <c>HostFolderLocations</c> to get the desired locations and pass them to the corresponding utils. Only very static and basic code can use this class directly.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StandardFolderLocationsStatic.Constants.LocalAppdataCachesSubfolder">
            <summary>
            Subfolder under local-app-data for caches (specifically transient stuff).
            </summary>
        </member>
        <member name="F:JetBrains.Util.StandardFolderLocationsStatic.Constants.NonPerHostSubfolder">
            <summary>
            Replaces the host name when not per-host.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StandardFolderLocationsStatic.Constants.NotPerVersionFolderInfix">
            <summary>
            Replaces the version number when not per-wave.
            Goes after <see cref="F:JetBrains.Util.StandardFolderLocationsStatic.Constants.VersionSubfolderPrefix"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StandardFolderLocationsStatic.Constants.VersionSubfolderPrefix">
            <summary>
            Prefix for the version folder name.
            </summary>
        </member>
        <member name="T:JetBrains.Util.BackSlashSeparatedRelativePath">
            <summary>
            It represents registry-like paths or any relative path with back-slash as separator.
            Notes: Allows any printable characters as pathname except back-slash.
            Don't allow conversion from/to URI.
            You're not able to combine it with absolute path.
            </summary>
        </member>
        <member name="T:JetBrains.Util.IPath">
            <summary>
              Base API for path-like entities.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.Parse(System.String)">
            <summary>
              Creates a new instance of the same kind from text.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.ToDirectoryUri">
            <summary>
              Creates a system <see cref="T:System.Uri"/> object from this instance, making sure it ends in a slash.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.ToUri">
            <summary>
              Creates a system <see cref="T:System.Uri"/> object from this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.TryCombine(System.String)">
            <summary>
              Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.FileSystemPath.Empty"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.GetPathComponents">
            <summary>
            Splits the path by path separator without any special treatment, i.e. you're getting two leaduing empty path components for UNC paths.
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.IPath.Empty">
            <summary>
              Returns an empty instance of the same kind (which replaces NULL in our model).
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.ExtensionNoDot">
            <summary>
              Gets the file extension, without the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>bat</c></example>
        </member>
        <member name="P:JetBrains.Util.IPath.ExtensionWithDot">
            <summary>
              Gets the file extension, including the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>.bat</c></example>
        </member>
        <member name="P:JetBrains.Util.IPath.FirstComponent">
            <summary>
            Gets the first component of the path up to the first path separator, without any special treatment, i.e. it will be an empty string for an UNC or unix root path.
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.Name">
            <summary>
              Gets the local name of the file/directory (the component after the last separator).
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.Parent">
            <summary>
              Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BackSlashSeparatedRelativePath.CreateByCanonicalPath(System.String)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BackSlashSeparatedRelativePath.Combine(System.String)">
            <summary>
            Combines a path with one or more path components. Throws on failure.
            </summary>
            <remarks>
            Returns itself if component is null.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.BackSlashSeparatedRelativePath.JetBrains#Util#IPath#TryCombine(System.String)">
            <summary>
            Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.BackSlashSeparatedRelativePath.Empty"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BackSlashSeparatedRelativePath.Parent">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="T:JetBrains.Util.InvokeChildProcess">
            <summary>
              Helps with invoking a child process during a build.
            </summary>
        </member>
        <member name="F:JetBrains.Util.InvokeChildProcess.TimeoutChildProcess">
            <summary>
            The default timeout for running child processes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.InvokeChildProcess.StartInfo.AdditionalEnvironmentVariables">
            <summary>
            By default, a child process inherits all of the environment variables of the parent process.
            This dictionary allows to modify the list by setting the new ones or removing existing ones (by setting them a NULL value).
            </summary>
        </member>
        <member name="T:JetBrains.Util.InvokeChildProcess.PipeStreams">
            <summary>
            Determines what happens to the StdOut and StdErr streams of the child process.
            </summary>
        </member>
        <member name="M:JetBrains.Util.InvokeChildProcess.PipeStreams.IntoJetLogger(JetBrains.Util.InvokeChildProcess.TreatStderr,JetBrains.Util.ILogger,System.Nullable{JetBrains.Util.LoggingLevel})">
            <summary>
            Child process StdOut gets logged into the <see cref="F:JetBrains.Util.InvokeChildProcess.Logger"/> as <see cref="F:JetBrains.Util.LoggingLevel.INFO"/> (or custom level) messages.
            Child process StdErr gets logged into the <see cref="F:JetBrains.Util.InvokeChildProcess.Logger"/> as <see cref="F:JetBrains.Util.LoggingLevel.ERROR"/> or <see cref="F:JetBrains.Util.LoggingLevel.INFO"/> (or custom level) messages, depending on the <see cref="T:JetBrains.Util.InvokeChildProcess.TreatStderr"/> setting.
            If the message parses as a standard error or warning line (in accordance with csc/vbc/msbuild rules), then it gets logged as an error or as a warning.
            </summary>
            <param name="treatstderr">Allows to suppress treating StdErr lines as errors, considering them the same as StdOut.</param>
            <param name="logger">Optionally, gives the specific logger to log into.</param>
            <param name="levelDefault">Optionally changes the logging level for non-error messages from its default <see cref="F:JetBrains.Util.LoggingLevel.INFO"/>.</param>
        </member>
        <member name="M:JetBrains.Util.InvokeChildProcess.PipeStreams.IntoParentProcessStreams(JetBrains.Util.InvokeChildProcess.TreatStderr)">
            <summary>
            Child process StdOut gets piped into the parent process StdOut.
            Child process StdErr gets piped into either StdErr or StdOut of the parent process, depending on the <see cref="T:JetBrains.Util.InvokeChildProcess.TreatStderr"/> setting.
            </summary>
            <param name="treatstderr">Allows to suppress treating StdErr lines as errors, considering them the same as StdOut.</param>
        </member>
        <member name="T:JetBrains.Util.Threading.AsyncPipeReader">
            <summary>
            Reads from the reader end of the pipe which has been opened with Overlapped IO enabled.
            The read is asynchronous without holding up any threads, using OS ThreadpoolIO.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsBusy">
            <summary>
            Either placing a read async call, or analyzing its results and whether it's sync or async, or running the code inside the callback.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsInCallback">
            <summary>
            Set to True when executing callback code. Most importantly, we must not wait for a callback when inside a callback. Changed under the <see cref="F:JetBrains.Util.Threading.AsyncPipeReader.myIsBusy"/> lock only, allows to tell if we're taking the lock in some nested code of the callback.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsPendingRead">
            <summary>
            Set to TRUE when we issue a read request and until either take it sync or get the async callback. These two check whoever is the first one by checking this flag.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsReadChainStopped">
            <summary>
            Not processing or awaiting, usually because the lifetime has been terminated or pipe broken or some error has occured.
            Means there's no pending wait, we're not analyzing the pending read results, and we're not about to do a new pending read.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.#ctor(JetBrains.DataFlow.Lifetime,System.Void*,System.Action{JetBrains.Util.dataStructures.ByteBuffer},System.Action)">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="FOnRead">Reader callback. Must not do complex operations, as might occur on the OS IO pool thread and under a lock. The buffer is temporary for the callback duration only. MUST NOT terminate lifetime in it.</param>
            <param name="FUserOnEof">Optional. Notifies when reading the pipe breaks. Same callback limitations apply: OS thread, under lock. MUST NOT terminate lifetime in it.</param>
        </member>
        <member name="P:JetBrains.Util.Threading.AsyncPipeReader.IsRunning">
            <summary>
            Gets whether the lifetime has not yet been terminated and the pipe has not yet been closed on either end.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.AsyncPipeTextLineReader">
            <summary>
            Based on the <see cref="T:JetBrains.Util.Threading.AsyncPipeReader"/>, decodes text out of the raw bytes, and splits by lines.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeTextLineReader.ReadLinesWithDeferredCallback(JetBrains.DataFlow.Lifetime,System.Void*,System.Text.Encoding,System.Action{System.String})">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="encoding"></param>
            <param name="FOnReadLineDeferred">Reader callback. Called outside of any native callbacks, so it can be any much complex, but for the last call when EOF is encountered or lifetime is destroyed, which has to be sync.</param>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeTextLineReader.ReadLinesWithDirectCallback(JetBrains.DataFlow.Lifetime,System.Void*,System.Text.Encoding,JetBrains.Util.Threading.AsyncPipeTextLineReader.ReadLineDelegate)">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="encoding"></param>
            <param name="FOnReadLine">Reader callback. Must not do complex operations, as might occur on the OS IO pool thread and under a lock. The buffer is temporary for the callback duration only. MUST NOT terminate lifetime in it.</param>
        </member>
        <member name="T:JetBrains.Util.Threading.IReaderWriterLock">
            <summary>
            Base API for Shell Locks — Content Model Reader-Writer Lock.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock">
            <summary>
             Fetches read lock - the lock which is used to control read-access to ReSharper data (such as PSI, documents, etc.) and
             is obtained by threads that perform read-operations.
            </summary>
            <remarks>
             Read lock cannot be acquired when the write lock is acquired by another thread and execution will be blocked until the write lock is released.
             You do not need to acquire read lock in the UI thread (since write operations cannot be performed in any thread different from the UI thread).
             Use <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseReadLock"/> method to release read lock.
            <b>NOTE:</b> the best way to hold read lock for a block of code is to use <see cref="!:JetBrains.ReSharper.Resources.Shell.Shell.ReadLockCookie"></see>
            </remarks>
            <seealso cref="!:JetBrains.ReSharper.Resources.Shell.Shell.ReadLockCookie"/>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseReadLock"/>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock">
            <summary>
            Fetches write lock - the lock which is used to control write-access to ReSharper data (such as PSI, documents, etc.) and
            is obtained by threads that perform write-operations.
            </summary>
            <remarks>
            Write lock cannot be acquired when the read lock is acquired by another thread and execution will be blocked until the read lock is released.
            Acquiring of the write lock is allowed only in the UI thread (and so you cannot perform any write operations from non-UI thread).
            Note that you do not have to obtain the write lock explicitly in most of cases. All low-level write methods (such as PSI or document modifications)
            obtain write lock automatically. You may need to obtain write lock if your subsystem (similar to PSI or documents) has its own data to be modified in write operations only.
            Use <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseWriteLock"/> method to release write lock.
            <b>NOTE:</b> the best way to hold write lock for a block of code is to use <see cref="!:JetBrains.ReSharper.Resources.Shell.WriteLockCookie"></see>
            </remarks>
            <seealso cref="!:JetBrains.ReSharper.Resources.Shell.WriteLockCookie"/>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseWriteLock"/>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseReadLock">
            <summary>
             Releases read lock.
             For more information about read lock see <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock"/>.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock"/>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseWriteLock">
            <summary>
             Releases write lock.
             For more information about write lock see <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock"/>.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock"/>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsReadAccessAllowed">
            <summary>
            True if read access is allowed in the current thread.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock"/>
            <seealso cref="!:JetBrains.Application.IShellLocksEx.AssertReadAccessAllowed(JetBrains.Application.IShellLocks)"/>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsReadLockHeld">
            <summary>
            Indicates that the current thread owns the read lock
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsWriteAccessAllowed">
            <summary>
            True if write access is allowed in the current thread.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock"/>
            <seealso cref="!:JetBrains.Application.IShellLocksEx.AssertWriteAccessAllowed(JetBrains.Application.IShellLocks)"/>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsWriteLockHeld">
            <summary>
            Indicates that the current thread owns the write lock
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsWriteLockRequested">
            <summary>
            Indicates that any thread requests for write lock, but not yet granted
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Queue(JetBrains.DataFlow.Lifetime,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Queues <paramref name="action"/> on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with given priority
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="priority"></param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that was created. Its execution progress can be viewed by <see cref="P:System.Threading.Tasks.Task.Status"/></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.QueueAt(JetBrains.DataFlow.Lifetime,System.Action,System.DateTime)">
            <summary>
            Queues <paramref name="action"/> on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with priority <see cref="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal"/> with certain delay expressed by <paramref name="date"/>
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="date">Date, when task will be queued to execution, should have Local kind</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that was created. Its execution progress can be viewed by <see cref="P:System.Threading.Tasks.Task.Status"/></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.QueueRecurring(JetBrains.DataFlow.Lifetime,System.Action,System.DateTime,System.TimeSpan)">
            <summary>
            Queues <paramref name="action"/> reccurenly on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with priority <see cref="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal"/> with certain delay 
            expressed by <paramref name="firstTime"/>
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="firstTime">Date, when task will be queued to execution, should have Local kind</param>
            <param name="interval">Interval between end and begin of execution of two adjancent repetition. If action execution time extends <paramref name="interval"/> then 
            they will be executed sequentially one by one. It's guaranteed that new action repetition can't start before old one is finished.</param>    
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Create(JetBrains.DataFlow.Lifetime,System.Action,System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)">
            <summary>
            Creates task in <see cref="F:System.Threading.Tasks.TaskStatus.Created"/> state. <paramref name="checkForInterrupt"/> and lifetime termitation is beeing propated into task, that can 
            throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> and finish execution in  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state. State <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state is not supported.
            In case of normal execution, <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> is assigned to task.
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="checkForInterrupt"></param>
            <param name="options"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Create``1(JetBrains.DataFlow.Lifetime,System.Func{``0},System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)">
            <summary>
            Creates task in <see cref="F:System.Threading.Tasks.TaskStatus.Created"/> state. <paramref name="checkForInterrupt"/> and lifetime termitation is beeing propated into task, that can 
            throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> and finish execution in  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state. State <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state is not supported.
            In case of normal execution, <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> is assigned to task.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(JetBrains.DataFlow.Lifetime,System.Func{System.Boolean},System.Boolean,System.Boolean,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Must be used with <code>using</code>. On dispose synchronously waits all activities that were enqueued by <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.Action)"/> and <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueDependentJobs(System.Collections.Generic.IEnumerable{System.Action},JetBrains.Util.OneToSetMap{System.Action,System.Action})"/>
            </summary>
            <param name="lifetime"></param>
            <param name="checkForInterrupt">if null inherits current thread's <see cref="T:JetBrains.Application.InterruptableActivityCookie"/> into all jobs</param>
            <param name="sync">whether to execute all enqueued jobs in the same thread as enqueue call</param>
            <param name="takeReadLock">whether to take readlock in each job. True by default (legacy of MulticoreFibersPool)</param>
            <param name="options">options to all tasks in barrier</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler">
            <summary>
            Scheduler of all tasks created by our code either <see cref="M:JetBrains.Application.Threading.Tasks.TaskHost.Create(JetBrains.DataFlow.Lifetime,System.Action,System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)"/>, <see cref="T:System.Threading.Tasks.Task"/> constructor, continuations, etc. Manages execution and timer threads.    
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.Factory">
            <summary>
            Factory of all task. Can be used to obtain functionality such as <see cref="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})"/>,
            <see cref="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})"/>    
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.RunEmpty(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Creates an empty task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:System.Threading.Tasks.Task`1"/> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{System.Threading.Tasks.Task})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:System.Threading.Tasks.Task"/> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:System.Threading.Tasks.Task`1"/> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Func{System.Threading.Tasks.Task})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:System.Threading.Tasks.Task"/> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Started``1(``0,System.Threading.Tasks.TaskScheduler)">
            <summary>
            In the client code, you should use <c>StartNew</c> directly as much as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.GetTaskScheduler(JetBrains.Threading.JetDispatcher)">
            <summary>
            Allows to schedule async tasks execution on a Dispatcher thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.ContinueWithTask(System.Threading.Tasks.Task,JetBrains.DataFlow.Lifetime,System.Threading.Tasks.Task)">
            <summary>
            Awaits for <paramref name="thіs"/> task to complete, then executes <paramref name="taskAfter"/>, and returns the task that represents this execution.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,System.Action,System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,System.Func{``0},System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.While(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,System.Func{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.While(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Yield(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
              <para>Frees the current thread of execution and re-schedules asynchronously to the free-threaded scheduler with default priority.</para>
              <para>For advanced options and custom priorities, see <see cref="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.YieldTo(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Application.Threading.Tasks.Scheduling,System.Nullable{JetBrains.Util.Threading.Tasks.TaskPriority})"/>.</para>
            </summary>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.YieldTo(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Application.Threading.Tasks.Scheduling,System.Nullable{JetBrains.Util.Threading.Tasks.TaskPriority})">
            <summary>
            Frees the current thread of execution and re-schedules asynchronously to the given scheduler.
            </summary>
            <param name="tasker">Task host that owns the schedulers and knows into priorities.</param>
            <param name="scheduling">The target scheduler shorthand enum member.</param>
            <param name="priority">Optionally, the priority.</param>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.ITaskHostEx2.SchedulerAwaiter">
            <summary>
            Yields implementation.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.ITaskHostEx2.TaskCreationOptionsNetfx45.HideSchedulerFlag">
            <summary>
            Gives the value of the <see cref="T:System.Threading.Tasks.TaskCreationOptions"/><c>::HideScheduler</c> flag.
            It's only present with netfx45, and we're compiling against netfx40, so we can't use the declaration, but we're running against netfx45 in most-most cases, and it's but a number, so we can use it numerically.
            But pure netfx40 would make the check for flags it does not understand, so make sure not to use the numerical value when running without netfx45.
            For that, we keep this field with the ready-for-use value <c>0</c> or the actual flag <c>16</c>, and check in cctor if there is such a value among the enum fields.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.JetDispatcherTaskScheduler">
            <summary>
            Allows to schedule async tasks execution on a Dispatcher thread.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.JetTaskEx">
            <summary>
            Local extensions to the Async Tasks.
            Some of them would be available out of the box with Netfx 45.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.JetTaskEx.myCompletedTask">
            <summary>
            An already completed task.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.FromResult``1(``0)">
            <summary>
            Creates a started and completed tasks which yields the given result.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.IsProcessCancelled(System.Threading.Tasks.Task)">
            <summary>
            Task is faulted because of PCE
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.ParseAggregateException(System.Exception@,System.AggregateException)">
            <summary>
            Try to find out ProcessCancelledException in AggregateException. If no PCE but some other exception exist, return it.
            </summary>
            <param name="toUpdate">Return value that can be updated based on possibleAggregateException</param>
            <param name="possibleAggregateException">AggregateException or null</param>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.Delay(System.TimeSpan,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a started tasks which will get a completed state after the specified amount of time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.While(System.Func{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.While(System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.While(JetBrains.DataFlow.IProperty{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.JetTaskEx.CompletedTask">
            <summary>
            Gets a task that is initially in the completed state.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Serialization.MemberwiseSerializableAttribute">
            <summary>
              <para>Means that the artifact should be serialized on member-by-member basis, by reading values of all public fields or properties.</para>
              <para>When restoring, values should be assigned either back to fields and properties (if writable), or to constructor parameters.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Serialization.XamlSerializableAttribute">
            <summary>
            Means that the artifact should be serialized into XAML.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.IHaveNugetPackageFileItem">
            <summary>
            For extracting a package from various artifact containers.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.JetPackageManifest">
            <summary>
            Same as <see cref="T:NuGet.Manifest"/>, but serializable.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable">
            <summary>
            Allows an object to support serialization into an <see cref="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage"/>. To support deserialization, implement a constructor taking a storage as the single parameter.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.IStructuredStorageSerializable.GetObjectData(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Populates an <see cref="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage"/> with the data needed to serialize the target object.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.JetPackageReference">
            <summary>
            A serializable version of the <see cref="T:NuGet.PackageReference"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalPackagesMeta.OpenInFolder(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath)">
            <summary>
            Opens the meta stored in the folder (usually, the solution's Packages folder) for the duration of the lifetime.
            Deserializes when opening, serializes upon termination of the lifetime, holds the lock to the file the whole duration.
            </summary>
            <param name="lifetime">When to serialize back and close file.</param>
            <param name="dirPackages">Usually, the solution Packages folder.</param>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.PackageFileSize">
            <summary>
            Validates the copy of .nupkg stored in the expanded folder.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.PackageVersionString">
            <summary>
            String representation of the package semantic version, to defer costly parsing — this speeds up mass-serialization considerably.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.TryReadFromDirectoryAttributes(JetBrains.Util.FileSystemPath)">
            <summary>
            Reads the package local expansion metadata which can validate that it has not been tampered with, written right into the package expansion directory extended attributes (more specifically, an alternate data stream named <see cref="F:JetBrains.Util.Storage.Packages.LocalPackagesMeta.SinglePackageMetadataFileName"/>). This is used in case we're linking package folders from the common storage, so the per-Packages-folder local metadata file is not sufficient because it does not know about packages written to the central storage by other parties.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.TryWriteToDirectoryAttributes(JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord)">
            <summary>
            See <see cref="M:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.TryReadFromDirectoryAttributes(JetBrains.Util.FileSystemPath)"/>.
            “Try” because the filesystem might not support this (but in that case linking the packages folders to the central storage won't be supported either).
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.ExpandedFilesTimestamp">
            <summary>
            Validates the files expanded from out of the package. Their size is checked against the package contents, and their stamp must all match this one.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PackageRecord.PackageFileTimestamp">
            <summary>
            Validates the copy of .nupkg stored in the expanded folder.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.LocalPackagesMeta.PkgIdString">
            <summary>
            Operates on strings, without parsing the semver. Profitable for mass-serialization.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache">
            <summary>
              <para>Represents a central NTSF folder into which all packages are actually expanded upon local-restore and then linked into individual Packages folders with directory junctions as needed.</para>
              <para>The actual folder path might be <c>NULL</c>, which means that the central folder is not available (e.g. due to the lack of filesystem support for junctions), and local package folders must be used normally in such a case.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache.Create(JetBrains.Util.FileSystemPath)">
            <summary>
            Creates the custom directory (does not check OS features, use <see cref="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache.CreateIfSupported(JetBrains.Util.FileSystemPath)"/> if not sure, use <see cref="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache.CreateInLocalAppDataIfSupported"/> for machine-default location).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache.CreateIfSupported(JetBrains.Util.FileSystemPath)">
            <summary>
            If the volume supports junctions.
            Always returns a non-NULL instance, but it might have a NULL path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache.CreateInLocalAppDataIfSupported">
            <summary>
            Creates at the default machine location, if OS and file system support the necessary features.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession">
            <summary>
              <para>Restores a specific set of Nuget package into the packages directory, mostly the same way as Nuget will do.</para>
              <para>As opposed to the standard Nuget procedure:</para>
              <para>• Ensures the folder contains no more packages than the retrieved list, to prevent projects from using non-whitelisted pkgs by accident. Operates on the Backlog folder to quickly retrieve such packages whenif we switch context.</para>
              <para>• Ensures the expanded content still matches the original packages (the file set and their content, by timestamp of the last time we wrote them).</para>
              <para>• Fixes exceptions in Nuget which probably resulted from some race (NP-1199).</para>
              <para>• Operates on the already-retrieved package body, as an artifact object.</para>
              <para>• Uses a slightly optimized procedure for accessing the artifact body (not so important).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.PackagesBacklogFolder">
            <summary>
            Gets relative path from the <see cref="!:PackagesFolder"/> to the to the folder in which expanded packages not currently referenced are hidden from accidental use in project references for potential reuse when we switch a branch and need them again.
            The name of the folder does not match the regex on Package ID (<c>\w</c>), so it shan't interfere with normal packages.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.myCentralCacheDirectory">
            <summary>
            Directory to the <see cref="T:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache"/>, if were supplied and we decided to put it to use.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.myFolderLocalNames">
            <summary>
            Tracks the folders in Packages directory which we have used — we will hide unuseds.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesCentralCache)">
            <summary>
            Opens the session. You can declare more packages as used while the session is open.
            The intended use is to close the session as soon as you are done with the restore, and then proceed using the packages — it's a restore-time session, not working-time session.
            Upon close, session will clean up packages you have not touched.
            </summary>
            <param name="lifetime"></param>
            <param name="dirPackages">The <c>Packages</c> dir. Note that it's not the product home dir but usually the <see cref="!:NugetBuildConvention.Const.Folder.PackagesFolder"/> under it.</param>
            <param name="centralcache">Optional central cache. If gives a non-NULL dir, and packages folder supports junctions, will use directory junctions to the central cache instead of the local backlog dir.</param>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.BacklogUnusedPackages">
            <summary>
            This is done automatically when session is closed, but you can call it at any time as well. Adding more packages won't break things.
            All packages which were not mentioned in this session are hidden from the packages directory, to make sure they're not accidentally referenced without also adding a reference to the package.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.ValidateExpandedPackage(JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.Packages.NugetPackageFileItem,JetBrains.Util.Storage.Packages.LocalPackagesMeta,JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.ValidationScope,JetBrains.Util.ILogger)">
            <summary>
            For a package already expanded on disk, validates that it likely corresponds to the pkg we got, that it were written by our authorized process, and that its file set is intact.
            </summary>
            <param name="dirExpanded">Dir with package files, will be validated against the pkg.</param>
            <param name="pkg">Original package.</param>
            <param name="meta">Metadata for all the expanded packages — applies to packages expanded locally in the packages folder; central cache has them on individual folders, that's why optional.</param>
            <param name="scope">How many to check.</param>
            <param name="logger"></param>
            <returns>If valid.</returns>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.CleanupBacklogOrCache(JetBrains.Util.FileSystemPath)">
            <summary>
            Does not let the backlog folder grow infinitely.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.MoveExtraPackagesToBacklog">
            <summary>
            Backlogs unused packages, so that there were no accidental references into them from around the solution.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.TryGetMetadataRecordForPackage(JetBrains.Util.Storage.Packages.NugetPackageFileItem,JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.Packages.LocalPackagesMeta)">
            <summary>
            Gets the record with metadata on package expansion, which allows to validate the actual package files on disk against what must be there in a valid expanded package.
            Metadata is looked up in two places: (1) on the expansion directory itself — this supports the case when packages are expanded into the central storage and then linked with junctions to actual package folders; (2) in the local-meta file in the Packages folder, which supports the case without junctions.
            </summary>
            <param name="pkgid">ID of the package to look for.</param>
            <param name="dirExpanded">The directory into which the package is expanded, if applicable. Looks for metadata on the directory itself, which is the case with the junctions way. This is the preferred location.</param>
            <param name="meta">The local-meta file from Packages, if available. Checked after the on-dir storage. Supposedly, they're the same.</param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.ValidationScope.Full">
            <summary>
            Asserts that locally expanded files match the actual package.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.ValidationScope.NupkgFileOnly">
            <summary>
            Only checks the original package file, nupkg, in that its disk copy matches the recorded metadata.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.NugetHelpers">
            <summary>
            Nuget package helpers which might be specific to build-related types, but are not specific to build semantic.
            </summary>
            <remarks>
              <para><c>NugetApplicationPackageConvention</c> — Nuget package layouts, locations, constants, etc for application shell aware needs.</para>
              <para><see cref="T:JetBrains.Util.Storage.Packages.NugetHelpers"/> — very generic Nuget helpers in the <c>Util</c>, not aware of Build nor Application Shell packages layout.</para>
              <para><c>NugetHelpersShell</c> — Nuget services for working with the Application Shell packages.</para>
              <para><c>NugetHelpersBuild</c> — Nuget services for supporting the Build infrasturcture and build operations not aware of the Application Shell packages.</para>
              <para><c>NugetApplicationPackageTasks</c> — Application Shell packages logic.</para>
            </remarks>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetHelpers.ProgramDatabasePackageIdAppendix">
            <summary>
            Add to the package ID of the main package to get the ID of the Nuget package with the program database for that subplatform, separated with a dot.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.CreateOpcPartUri(JetBrains.Util.RelativePath)">
            <summary>
            Mimics Nuget's helper for turning paths into OPC Pack URIs.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.CreateSourceRepository(NuGet.ISettings)">
            <summary>
            Creates the source repo, with per-machine caching enabled.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.CreateSourceRepositoryNoMachineCache(NuGet.ISettings)">
            <summary>
            Creates the source repo, with per-machine caching skipped.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.FindPackage``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Gets the package by ID. A missing package is an error.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.FindPackageAndItsReferences``1(System.Collections.Generic.IEnumerable{``0},System.String,JetBrains.Util.OnError)">
            <summary>
            Gets the package by ID, plus all its references, transitively. A missing reference is an error.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.FindPackages``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets the packages by ID. A missing package is an error.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.FindPackagesCore``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Predicate{System.String},JetBrains.Util.OnError)">
            <summary>
            Gets the package by ID, plus all its references, transitively. A missing reference is an error.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.FilterDependencySets(System.Collections.Generic.IEnumerable{NuGet.PackageDependencySet})">
            <summary>
            Restores the Nuget logic for filtering dependency sets by the target framework.
            Calling Nuget native API has a drawback of throwing exeptions when it finds surprising records in the Registry of the local machine, and also makes excessive allocations.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.FindPackagesWithSymbols``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            For a set of packages with binaries, tries to look up corresponding packages with symbols in the total packages set.
            </summary>
            <typeparam name="TPackage"></typeparam>
            <param name="packagesWithBinaries">Subset of binaries packages.</param>
            <param name="allpackages">The total set of packages to consider.</param>
            <returns>The set of found symbol packages.</returns>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.GetPackageFileName(JetBrains.Util.Storage.Packages.IHaveNugetPackageFileItem)">
            <summary>
            Gets the local name of the package file with the given ID and version.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.GetPackageFileName(NuGet.IPackageName)">
            <summary>
            Gets the local name of the package file with the given ID and version.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.MightHaveDependencyOn(JetBrains.Util.Storage.SimpleFileItem,System.String)">
            <summary>
            Fast-checks if the package has a dependency on another package.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.RetrievePackageCore(System.Func{System.Boolean,NuGet.IPackage},System.Object,JetBrains.Util.OnError)">
            <summary>
            Gets the package in a reliable way, working around problems like inability to retrieve bytes of the actually-returned package.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetHelpers.SanitizePackageBuilder(NuGet.IPackageBuilder)">
            <summary>
            Reports all known package errors in a non-breaking fashion.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.Candidates">
            <summary>
            All candidates conflicting over the path.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.ChosenFile">
            <summary>
            The file which would be chosen for the output.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.Path">
            <summary>
            When merging files from several packages, the relative path which several files are targeting.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.FileInPackage.File">
            <summary>
            File, if known. As it will be holding all the file bytes for the whole operation duration, might be NULL and only certain file props might be set.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.FileInPackage.FileSize">
            <summary>
            Must be set even if the file is not set.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.FileInPackage.Path">
            <summary>
            <see cref="F:JetBrains.Util.Storage.Packages.NugetHelpers.ExtractedFileConflict.FileInPackage.File"/>.<see cref="P:JetBrains.Util.Storage.SimpleFileItem.RelativePath"/>
            Must be set even if the file is not set.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.NugetPackageFileItem">
            <summary>
            Represents an in-memory serializable Nuget package item, much like a <see cref="T:JetBrains.Util.Storage.SimpleFileItem"/> is for a file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageFileItem.#ctor(JetBrains.Util.Storage.Packages.JetPackageManifest,JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Identity ctor.
            </summary>
            <param name="manifest"></param>
            <param name="file"></param>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageFileItem.#ctor(JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Reads manifest from the package file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageFileItem.#ctor(NuGet.IPackage)">
            <summary>
            Reads the package and detaches from the instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageFileItem.#ctor(NuGet.IPackageBuilder)">
            <summary>
            A newly-created package item from a builder.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetPackageFileItem.File">
            <summary>
            The package file stream contents.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetPackageFileItem.Manifest">
            <summary>
            The manifest of the package.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageFileItem.Load">
            <summary>
            Loads the package with Nuget.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.NugetPackageIntrospection">
            <summary>
              <para>Uses alternative methods for introspecting Nuget packages, which can give up to 2x total speed and greatly reduces intermediate memory usage.</para>
              <para>Does not reference the Nuget itself, so is netfx35-friendly.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.EnumNugetEntriesDirectory``1(JetBrains.Util.Storage.SimpleFileItem,JetBrains.Util.Storage.Packages.NugetPackageIntrospection.FilterFlags,JetBrains.Util.Storage.Packages.NugetTargetFramework,System.Func{JetBrains.Util.Storage.Packages.NugetPartPaths,System.Boolean},System.Func{System.Collections.Generic.IList{JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry},``0})">
            <summary>
              <para>Uses direct ZIP directory access for retrieving Nuget content file items.</para>
              <para>Benefits:</para>
              <para>• Nuget uses the .NET OPC implementation which isn't so fast on itself, SharpZipLib feels considerably faster.</para>
              <para>• Nuget would copy all the streams before handing them out, while ZIP access allows to inftale on the fly.</para>
              <para>• Nuget does the shadow copying for streams of ALL files, in one gulp and before we filter them. Here we skip all but needed.</para>
            </summary>
            <param name="fiNugetPackage">The file item with the package itself (the <c>JetBrains.Application.SinceClr4.BuildScript.NugetPackageFileItem::File</c>).</param>
            <param name="λFilter">Optional filter to avoid getting unneeded file streams.</param>
            <param name="λEntries">Processing function. Called on the entries which passed the filter.</param>
            <param name="flags">Flags to skip certain items, for speed.</param>
            <param name="targetfx">
              <para>Allows to limit the extracted content items by a specific Target Framework.</para>
              <para>Not filtering (not <see cref="P:JetBrains.Util.Storage.Packages.NugetTargetFramework.IsFiltering"/>): gets the union of all the content items for any frameworks; might yield items with the same <see cref="F:JetBrains.Util.Storage.Packages.NugetPartPaths.EffectivePathJet"/> (but different <see cref="F:JetBrains.Util.Storage.Packages.NugetPartPaths.PartPath"/> of course). This is the legacy behavior.</para>
              <para>Filtering (<see cref="P:JetBrains.Util.Storage.Packages.NugetTargetFramework.IsFiltering"/>):</para>
              <para>• Illegal if not <see cref="F:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.FilterFlags.JetContentItemsOnly"/>.</para>
              <para>• Returns content items for this specific framework only.</para>
              <para>• If limiting for the specific framework yields an empty list, falls back to the original behavior as if this were <c>NULL</c>. This is a compatibility fix to make sure that we're still able to support projects targeting the non-solution-standard fx version and their custom nuget references.</para>
              <para>The commonly-used value would be <see cref="F:JetBrains.Util.Storage.Packages.NugetTargetFramework.ToolsetDefault"/>.</para>
            </param>
            <returns>The list of matching content items.</returns>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.EnumNugetEntriesStream(JetBrains.Util.Storage.SimpleFileItem,JetBrains.Util.Storage.Packages.NugetPackageIntrospection.FilterFlags,System.Action{JetBrains.Util.Storage.Packages.NugetPartPaths,System.IO.Stream},System.Func{JetBrains.Util.Storage.Packages.NugetPartPaths,System.Boolean})">
            <summary>
              <para>Uses direct ZIP stream access for retrieving Nuget content file items.</para>
              <para>Benefits:</para>
              <para>• Nuget uses the .NET OPC implementation which isn't so fast on itself, SharpZipLib feels considerably faster.</para>
              <para>• Nuget would copy all the streams before handing them out, while ZIP access allows to inftale on the fly.</para>
              <para>• Nuget does the shadow copying for streams of ALL files, in one gulp and before we filter them. Here we skip all but needed.</para>
            </summary>
            <param name="fiNugetPackage">The file item with the package itself (the <c>JetBrains.Application.SinceClr4.BuildScript.NugetPackageFileItem::File</c>).</param>
            <param name="λEntry">Processing function. Called for each item which passes all the filters. The stream is temporary and probably not seekable.</param>
            <param name="λFilter">Optional filter to avoid getting unneeded file streams.</param>
            <param name="flags">Flags to skip certain items, for speed.</param>
            <returns>The list of matching content items.</returns>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.GetJetContentFileItemsFast(JetBrains.Util.Storage.SimpleFileItem,System.Func{JetBrains.Util.Storage.Packages.NugetPartPaths,System.Boolean},JetBrains.Util.Storage.Packages.NugetTargetFramework)">
            <summary>
              <para>Uses direct ZIP access for retrieving Nuget content file items.</para>
              <para>Benefits:</para>
              <para>• Nuget uses the .NET OPC implementation which isn't so fast on itself, SharpZipLib feels considerably faster.</para>
              <para>• Nuget would copy all the streams before handing them out, while ZIP access allows to inftale on the fly.</para>
              <para>• Nuget does the shadow copying for streams of ALL files, in one gulp and before we filter them. Here we skip all but needed.</para>
            </summary>
            <param name="fiNugetPackage">The file item with the package itself (the <c>JetBrains.Application.SinceClr4.BuildScript.NugetPackageFileItem::File</c>).</param>
            <param name="λFilter">Optional filter to avoid getting unneeded file streams.</param>
            <param name="targetfx">If not specified, </param>
            <returns>The list of matching content items.</returns>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.GetPackageManifestFast(JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Using Nuget's own package for getting a manifest results in copying the full package stream and then copying the metadata a few times. Try skipping all that.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.GetPackageManifestFast_SystemPackaging(JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Using Nuget's own package for getting a manifest results in copying the full package stream and then copying the metadata a few times. Try skipping all that.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.GetPackageManifestFast_Zip(JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Using Nuget's own package for getting a manifest results in copying the full package stream and then copying the metadata a few times. Try skipping all that.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.GetNugetManifestPartName(ICSharpCode.SharpZipLib.Zip.ZipFile,System.Object,JetBrains.Util.OnError)">
            <summary>
            Looks up the relationships file in the package, and reads the Nuget Manifest relationship target to learn the part which has the package manifest.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.FilterFlags.JetContentItemsOnly">
            <summary>
            Only take those items for which <see cref="M:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.TryGetJetEffectivePath(JetBrains.Util.RelativePath)"/> is defined, i.e. those recognized as content items by our system.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.FilterFlags.DoNotSkipEmptyFolderFileMarker">
            <summary>
            Do not skip <see cref="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.PackageEmptyFileName">empty folder maker</see>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.CreateFileItem">
            <summary>
            Inflates the part into an uncompressed copy in the memory.
            Uses the <see cref="F:JetBrains.Util.Storage.Packages.NugetPartPaths.EffectivePathJet"/> path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.CreatePartPathFileItem">
            <summary>
            Inflates the part into an uncompressed copy in the memory.
            Uses the full part path of the file, <see cref="F:JetBrains.Util.Storage.Packages.NugetPartPaths.PartPath"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.ReadRandomAccessStream``1(System.Func{System.IO.Stream,``0})">
            <summary>
            Inflates the part on-demand. Prefer this method if you only need to peek into the head of the stream.
            Guarantees the stream has random-access capabilities, but this comes at a cost of doubled memory use. Call <see cref="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.ReadSequentialStream``1(System.Func{System.IO.Stream,``0})"/> unless you need random access.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.ReadSequentialStream``1(System.Func{System.IO.Stream,``0})">
            <summary>
            Inflates the part on-demand. Prefer this method if you only need to peek into the head of the stream.
            The stream might be returned as sequential-only, depending on the ZIP options used.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.IsNull">
            <summary>
            Allows to tell uninitialized structs, e.g. with TryGet methods.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.Packages.NugetPackageIntrospection.NugetEntry.UncompressedLength">
            <summary>
            Gets the uncompressed length of the entry without actually inflating the bytes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetPartPaths.EffectivePathJet">
            <summary>
            <see cref="M:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.TryGetJetEffectivePath(JetBrains.Util.RelativePath)"/>.
            Might be undefined for some of the parts.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetPartPaths.PartPath">
            <summary>
            The path equivalent of the Part URI in the OPC package.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.NugetTargetFramework">
            <summary>
            Specifies filtering by target framework when fast-extracting the nuget packages.
            The NULL value means the toolset-default targetfx should be used.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetTargetFramework.DontFilter">
            <summary>
            Gets the union of all the content items for any frameworks; might yield items with the same <see cref="F:JetBrains.Util.Storage.Packages.NugetPartPaths.EffectivePathJet"/> (but different <see cref="F:JetBrains.Util.Storage.Packages.NugetPartPaths.PartPath"/> of course). This is the legacy behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.Packages.NugetTargetFramework.ToolsetDefault">
            <summary>
            Filters by the netfx of <see cref="F:JetBrains.Util.ToolsetInfo.CurrentDefaultTargetFx"/>, which is the default target netfx version for the managed projects in the solution.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.Packages.NugetTargetFramework.#ctor(System.Boolean,System.Runtime.Versioning.FrameworkName)">
            <summary>
            This weird combination is required so that the NULL value of the structure were the preferred omitted-default value (use current toolset).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.Packages.PackageIdentity">
            <summary>
            Most like the <see cref="T:NuGet.PackageName"/> class, but with correct equality members implementation.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.LineEndings">
            <summary>
              <para>Utilities for handling line endings in text files. Also used by the <c>Document</c> to break the document text into the lines.</para>
              <para>If you have a document already, use its ext methods to learn line ending stats for it, like what's the most popular line ending in the current document, or just the first line ending.</para>
              <para>This class has the same functions for the case when you have no document object but only its text.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.mySmallBuffer">
            <summary>
            Lazy one-line buffer for fetching the first line ending quickly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.DetectLineEndings(JetBrains.Util.TextRange,JetBrains.Text.IBuffer)">
            <summary>
            Rebuilds a part of the index (or the whole index).
            </summary>
            <param name="rangeWholeLines">The part to rebuild. Range ends must be at start offsets of some lines (or end-offset-with-line-break, which is the same).</param>
            <param name="buffer"></param>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.AverageLineLength">
            <summary>
            Assumed average line length, to estimate the new lines buffer size.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.GetFirstLineEnding(JetBrains.Text.IBuffer)">
            <summary>
            Gets the very first line ending of the document.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.GetMostPopularLineEnding(JetBrains.Text.IBuffer)">
            <summary>
              <para>Scans the line endings of the document, returns the most popular one.</para>
              <para>NOTE: if you got a document object, call the overload on the document for better perf.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.GetMostPopularLineEnding(System.Collections.Generic.List{JetBrains.Util.Text.LineEndings.LineSegment},JetBrains.Text.IBuffer)">
            <summary>
              <para>Scans the line endings of the document, returns the most popular one.</para>
              <para>NOTE: if you got a document object, call the overload on the document for better perf.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.DetectLineEndingsCore(JetBrains.Util.TextRange,JetBrains.Text.IBuffer,JetBrains.Util.Text.LineEndings.Flags,System.Nullable{JetBrains.Util.Text.LineEndings.DetectLineEndingsContext})">
            <summary>
            Rebuilds a part of the index (or the whole index).
            </summary>
            <param name="range">The part to scan, see flags for special end handling.</param>
            <param name="buffer"></param>
            <param name="flags"></param>
            <param name="mctx">Optional previous context. Allows to parse incrementally, must be the result from the previous contiguous range. The new context is returned.</param>
        </member>
        <member name="T:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext">
            <summary>
            Replaces the former lambda function, collects the context needed for the common <see cref="M:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.commitLine(System.Int32)"/> function (which were a lambda).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.news">
            <summary>
            Newly-collected line segments.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.offsCurrEndNoLB">
            <summary>
            Line end-no-line-break for the line we're currently collecting, -1 if not encountered yet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.offsCurrStart">
            <summary>
            Line start for the line we're currently collecting.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.commitLine(System.Int32)">
            <summary>
             Adds a new line when we detect a complete line break char
            </summary>
            <param name="offsWithLB">The new end with line break.</param>
        </member>
        <member name="T:JetBrains.Util.Text.LineEndings.LineEnding">
            <summary>
              <para>Supported line endings. This list is in sync with Visual Studio Text Buffer implementation, which is required to guarantee that we lineate the documents in the same manner, and this is essential for switching between disk-backed and VS ROT backed document implementations correctly.</para>
              <para>The implementation has been retrieved from the classical VS Text Buffer implementation of the pre-MEF age, actually.</para>
              <para>Enum member values are little-endian representations of the line ending chars in UTF-16LE with zero chars skipped, which gives one-char (high zero), two-char (for CRLF) and zero-char (for the very last line in file) endings.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.LF">
            <summary>
            LF Line Feed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.CR">
            <summary>
            CR Carriage Return.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.CRLF">
            <summary>
            CR Carriage Return.
            LF Line Feed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.LS">
            <summary>
            LS Line Separator.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.PS">
            <summary>
            PS Paragraph Separator.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.VT">
            <summary>
            VT Vertical Tabulation.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.FF">
            <summary>
            FF Form Feed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.NEL">
            <summary>
            NEL New Line.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineEnding.Eof">
            <summary>
            An implicit line enging at the end of the file without an explicit line ending.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.Flags.LineEndsAtRangeEnd">
            <summary>
            The range ends at a whole line, so the line ending should be committed even if possibly a leading char (like \r). If also <see cref="F:JetBrains.Util.Text.LineEndings.Flags.DocumentEndsAtBufferEnd"/>, then it should be committed even without any line ending. If not <see cref="F:JetBrains.Util.Text.LineEndings.Flags.DocumentEndsAtBufferEnd"/> and there's no line ending char at the end of the range, then it is an error.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.Flags.DocumentEndsAtBufferEnd">
            <summary>
            The buffer end is the document end, so if the range goes up to the buffer end, it should be treated as an EOF and a no-ending line should be committed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.Flags.FirstLineOnly">
            <summary>
            Break after committing the very first line.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineSegment.myPackedLengths">
            <summary>
            Keeps the line lenghts: lower 30 bits are the full line segment length, including the line break chars; the higher two bits are the line ending length, of whose values the valid ones are 0, 1, 2.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.LineSegment.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.EndOffsetNoLineBreak">
            <summary>
            Index after the last non-line-break character of the line. This denotes the line length.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.EndOffsetWithLineBreak">
            <summary>
            Index after the last character of the line, including any line break characters it has.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.ExtentNoLineBreak">
            <summary>
            Gets the line extent, not including the line break characters.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.ExtentWithLineBreak">
            <summary>
            Gets the line extent, including the line break characters.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.LengthNoLineBreak">
            <summary>
            Gets the number of non-line-break characters in the line.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.LengthWithLineBreak">
            <summary>
            Gets the number of characters in the line, including the line break characters.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.StartOffset">
            <summary>
            Index of the first character in the line.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler">
            <summary>
            Allows to schedule async tasks execution on the Reentrancy Guard.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler.#ctor(JetBrains.Threading.ReentrancyGuard,JetBrains.Util.Threading.IReaderWriterLock)">
            <summary>
            Sets up the scheduler for the given guard.
            </summary>
            <param name="guard">The guard instance, also defines the target STA thread.</param>
            <param name="rwlocks">Optional. Takes reader lock on with the given object, if supplied.</param>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.FreeThreaded">
            <summary>
            Tasks will be run on an MTA thread pool, with maximum parallelism.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.MainDispatcher">
            <summary>
            Tasks will be run with the <see cref="T:JetBrains.Threading.JetDispatcher">Dispatcher</see> of the main thread (one of the <c>IThreading</c> components) — i.e. on the main thread when smb pumps the Windows Message Queue. No reentrancy guarantee for these.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.MainGuard">
            <summary>
            Tasks will be run with the <see cref="T:JetBrains.Threading.ReentrancyGuard">Guard</see> of the main thread (one of the <c>IThreading</c> components) — i.e. on the main thread when smb pumps the Windows Message Queue and when no other guarded tasks are running. Tasks executed with the Guard will never reenter one another. NOTE: eventually, all such tasks will be taking the reader lock automatically (if available in the current Shell).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.TaskBarrier">
            <summary>
            Replace of MulticoreFibersPool. When you dispose this object it synchronously waits all task that were enqueued by <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.String,System.Action)"/> and <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueDependentJobs(System.Collections.Generic.IEnumerable{System.Action},JetBrains.Util.OneToSetMap{System.Action,System.Action})"/>
            Create an instance with <see cref="M:JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(JetBrains.DataFlow.Lifetime,System.Func{System.Boolean},System.Boolean,System.Boolean,System.Threading.Tasks.TaskCreationOptions)"/>  
            </summary>
        </member>
        <member name="T:JetBrains.Util.SafeDisposable">
            <summary>
            By extending this class you ensures that object will be disposed by finalizer. If one forget to invoke <see cref="M:JetBrains.Util.SafeDisposable.Dispose"/>,
            resources will be released by finalizer but <see cref="M:JetBrains.Util.Logging.Logger.LogError(System.String)"/> is called in this case. If one invoked dispose second time error would be logger too
            (this behavior could be suppressed by overriding <see cref="P:JetBrains.Util.SafeDisposable.WarnOnSecondDispose"/> in inheritors). The finalizer works only in Development mode (JET_MODE_ASSERT). In
            Production mode this class is much like <see cref="T:System.IDisposable"/> with checks for second dispose.
            </summary>
        </member>
        <member name="M:JetBrains.Util.SafeDisposable.DisposeIfNecessary(System.Object)">
            <summary>
            Dispose object only if its class implements <see cref="T:System.IDisposable"/>
            </summary>
            <param name="o">object to dispose</param>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueTask(System.Threading.Tasks.Task)">
            <summary>
            Enqueue a custom (possibly already running) task under the task barrier. If task is not started it will be started.
            </summary>
            <remarks>Note that custom tasks (in contrast with tasks created by EnqueueJob) will not share check-for-interrupt, proiority, and sync and read-lock flag defined in TaskBarrier ctor.</remarks>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.String,System.Action)">
            <summary>
            Create and start a new task under the task barrier.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.TaskJetProperties">
            <summary>
            Additional task properties that influence on its execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.Priority">
            <summary>
            Task execution priority. Higher priorities are executed first.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.TakeReadLock">
            <summary>
            Whether to take system ReadLock on task execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.ExecutionId">
            <summary>
            Internal number that designated in which order tasks are entered into <see cref="!:JetScheduler.QueueTask(System.Threading.Tasks.Task)"/> method
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.Name">
            <summary>
            Internal number that designated in which order tasks are entered into <see cref="!:JetScheduler.QueueTask(System.Threading.Tasks.Task)"/> method
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.ScheduledTime">
            <summary>
            For scheduled tasks with delayed execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.AssignedToExecutor">
            <summary>
            internal status of task
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.Start(System.Threading.Tasks.Task,JetBrains.Application.Threading.Tasks.ITaskHost,System.Boolean)">
            <summary>
            Helper that parametrize task start mode: synchronous (on the same thread, instantly) or asynchronous (on thread pool managed by <see cref="T:JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler"/>)
            </summary>
            <param name="task"></param>
            <param name="host"></param>
            <param name="sync">if true run task synchronously (on the same thread)</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.WaitOnMonitor(JetBrains.Application.Threading.Tasks.ITaskHost,System.Object,System.Int32)">
            <summary>
            Wait on monitor <code>mySentry</code> with awareness about MainThread
            </summary>
            <param name="tasks"></param>
            <param name="sentry"></param>
            <param name="timeToWaitMillis"></param>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.CantBeJetTask(System.Threading.Tasks.Task)">
            <summary>
            Sometimes some external action can be scheduled here with some state. 
            https://youtrack.jetbrains.com/issue/RSRP-440328
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.TaskEx.False">
            <summary>
            An already completed task.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.FromResult``1(``0)">
            <summary>
            Creates a started and completed tasks which yields the given result.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.Delay(System.TimeSpan,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a started tasks which will get a completed state after the specified amount of time.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.While(System.Func{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.While(System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.While(JetBrains.DataFlow.IProperty{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskEx.CompletedTask">
            <summary>
            Gets a task that is initially in the completed state.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.Tasks.TaskSemaphore">
            <summary>
            Allows to limit the number of async activities to be executed in parallel, with asynchronous waits for the available resources.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myFreeCount">
            <summary>
            The current count of free objects, modified under <see cref="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myLockObject"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myWaits">
            <summary>
            The queue of waiting parties when <see cref="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myFreeCount"/> is zero and there's still demand, modified under <see cref="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myLockObject"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Tasks.TaskSemaphore.ExecuteUnderSemaphoreAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Awaits for the semaphore resources to be available and claims one resource, then invokes the <paramref name="tasker" /> and executes its chain of tasks, then releases the semaphore and completes the returned task with the result of the <paramref name="tasker" />'s task.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Tasks.TaskSemaphore.UsingSemaphoreAsync">
            <summary>
              <para>Waits to take the semaphore, asynchronously, and yields a token to be used with the <c>using(){}</c> construct to release the semaphore.</para>
              <para>This overload supports the <c>async/await</c> syntax.</para>
            </summary>
            <example>
              <code>
            using(await sema.UsingSemaphoreAsync())
            {
              …
            }
            </code></example>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.ToolsetInfo.CurrentDefaultTargetFx">
            <summary>
            Gets the default target netfx version for the managed projects in the solution, unless overridden by their specific needs (like supporting newer VS versions).
            This is the default Nuget package content extraction framework.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ToolsetInfo.CurrentDevToolset">
            <summary>
            Gets the VS version of the main toolset currently used for developing the ReSharper Ultimate family of products.
            This is the default value for Visual Studio version, MSBuild version, and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferencesOriginalDictionary.CreateXmlHtmlNamedCharacterReferencesDictionary">
            <summary>
            The original dictionary borrowed from the full list of known character entity names.
            The below BLOBs are produced with <see cref="M:JetBrains.Util.XmlHtmlNamedCharacterReferences.RenderHashTable"/> and contain native hash tables for lookup by entity name string and by character.
            Previously, this dictionary were used immediately, but it imposed a JIT and cctor penalty on startup.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2">
            <summary>
              <para>Mapping from one family of objects into another and vice versa.</para>
              <para>Uses the Compact Map inside. This consumes less memory and won't hit the LOH, but is a few times slower. So in perf-critical scenarios without big mem pressure choose the <see cref="T:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2.Add(`0,`1)">
            <summary>
            Adds a new mapping to the map. Both ends must be unique in their maps.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2.SetMapping(`0,`1,System.Boolean)">
            <summary>
            Adds a new mapping to the map. You should use <see cref="M:JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2.Add(`0,`1)"/> whenever possible, as it throws on dpulicate keys.
            </summary>
            <param name="left">Left key.</param>
            <param name="right">Right key.</param>
            <param name="bIgnoreConflicts">Whether to ignore duplicate keys in left and right collections silently. Not recommended. The conflicting mappings will be dropped.</param>
        </member>
        <member name="P:JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2.Count">
            <summary>
            Get the number of mappings.
            As we implement the identity mapping, the number of items on both sides is always in sync.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2">
            <summary>
              <para>Mapping from one family of objects into another and vice versa.</para>
              <para>Uses the runtime <see cref="T:System.Collections.Generic.Dictionary`2"/> for storage. As compared to the <see cref="T:JetBrains.Util.dataStructures.BidirectionalMapOnCompactMap`2"/>, this is a few times faster. With large amounts of memory it will use more mem (and might get into LOH).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.Add(`0,`1)">
            <summary>
            Adds a new mapping to the map. Both ends must be unique in their maps.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.SetMapping(`0,`1,System.Boolean)">
            <summary>
            Adds a new mapping to the map. You should use <see cref="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.Add(`0,`1)"/> whenever possible, as it throws on dpulicate keys.
            </summary>
            <param name="left">Left key.</param>
            <param name="right">Right key.</param>
            <param name="bIgnoreConflicts">Whether to ignore duplicate keys in left and right collections silently. Not recommended. The conflicting mappings will be dropped.</param>
        </member>
        <member name="P:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.Count">
            <summary>
            Get the number of mappings.
            As we implement the identity mapping, the number of items on both sides is always in sync.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.NaturalSort">
            <summary>
            Compares strings by their natural sorting order, which is, case-insensitively and treating digits and numbers, where 2 goes before 10.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner">
            <summary>
            Represents a string-like object over a managed memory buffer presented as a byte array, written in the UTF-16LE encoding.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.IStringSourceOwner">
            <summary>
            An interface to switchable implementations behind the <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <summary>
              <para>Returns a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource"/> which is guaranteed to be hosted in the managed memory, i.e. its lifetime won't terminate.</para>
              <para>Required if you plan on using the string longer than the lifetime it's been produced under.</para>
              <para>Native strings will be rendered as runtime strings. Non-native strings, e.g. strings or substrings, will be returned AS IS.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed``2(JetBrains.Util.dataStructures.Sources.StringSource@,``0,JetBrains.Util.dataStructures.Sources.StringSourceFixedDelegate{``0,``1})">
            <summary>
              <para>Processes a string as a fixed pointer to the char array.</para>
              <para>This char array MIGHT NOT be zero-terminated!!</para>
              <para>It MUST NOT be modified.</para>
              <para>It might be a subrange of some other runtime string object, or a pointer to a native memory area, or some stack/reusable buffer.</para>
            </summary>
            <typeparam name="TContext">A user-defined context which allows to use non-closure lambdas.</typeparam>
            <typeparam name="TResult">Processing result.</typeparam>
            <param name="ss">Instance.</param>
            <param name="context">A user-defined context which allows to use non-closure lambdas.</param>
            <param name="λ"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner.Create(System.Byte[],System.UInt32,System.UInt32)">
            <summary>
            Creates a string source over a byte array.
            </summary>
            <param name="array">The array.</param>
            <param name="cbstart">The index to the first byte of the string, in bytes.</param>
            <param name="cblength">The length of the string in bytes.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.CollectionSourceDebugView`1">
            <summary>
            Renders collection source contents for the debugger.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.EmptyStringSourceOwner">
            <summary>
            Represents an empty string.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner">
            <summary>
            A string in the native memory.
            Cannot be directly treated as an <c>LPCWSTR</c> because for it zero-termination is not guaranteed.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.Create(JetBrains.DataFlow.Lifetime,System.Char*,System.UInt32)">
            <summary>
            Stringsources a native memory range. Checks the lifetime before accessing the memory range (not safe from races though, rule this out with external means of control).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.CreateWithoutLifetime(System.Char*,System.UInt32)">
            <summary>
            Stringsources a native memory range. Has NO means for checking that the mem is still valid, so don't use unless really have to.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.RuntimeStringSourceOwner">
            <summary>
            Wraps a runtime string object as a string source.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.RuntimeSubStringSourceOwner">
            <summary>
            Wraps a runtime string object as a string source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.IsEmpty(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Gets whether the string is empty.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.IsEmpty(System.Nullable{JetBrains.Util.dataStructures.Sources.StringSource})">
            <summary>
            Gets whether the string is empty.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.Split(JetBrains.Util.dataStructures.Sources.StringSource,System.Char[])">
            <summary>
            Returns an array of string sources that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            Parameter specify whether to return empty array elements.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separators" />.
            </returns>
            <param name="thіs"></param>
            <param name="separators">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.Split(JetBrains.Util.dataStructures.Sources.StringSource,System.Char[],System.StringSplitOptions)">
            <summary>
            Returns an array of string sources that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            Parameter specify whether to return empty array elements.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separators" />.
            </returns>
            <param name="thіs"></param>
            <param name="separators">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned,
            or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.ToRuntimeString(System.Nullable{JetBrains.Util.dataStructures.Sources.StringSource})">
            <summary>
              <para>Renders the runtime string object for this string source.</para>
              <para>This specific operation is what a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource"/> tries to avoid by providing a string-like API to some non-allocating object.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSourceOwnerHelpers.GetCountViaEnumeration``1(JetBrains.Util.dataStructures.Sources.CollectionSource{``0}@)">
            <summary>
            Counts items by iterating the collection. Revert to this impl if you can't count the items faster.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.StringSourcePodData">
            <summary>
            An empty placeholder which allocates memory for POD data of string source owners.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ReinterpretCast">
            <summary>
            In a generic method, allows to reinterpret-cast a value type to the matching generic parameter type without boxing it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReinterpretCast.ValueTypeOrNullable``2(``0)">
            <summary>
            Call on POD structs only!
            Reinterpret-casts types bluntly.
            </summary>
        </member>
        <member name="T:JetBrains.Util.BinarySearchResult`1">
            <seealso cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)"/>
        </member>
        <member name="M:JetBrains.Util.BinarySearchResult`1.InsertAt(`0)">
            <summary>
            Inserts an item into a sorted array so that to maintain the sorting order.
            </summary>
            <returns>The index the item was inserted at (equals to <see cref="P:JetBrains.Util.BinarySearchResult`1.InsertAtIndex"/>).</returns>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.HitIndex">
            <summary>
            Gets the index of the search hit, should there be any.
            In case of a search miss, throws.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.HitItem">
            <summary>
            If the search found an item, returns that item. Otherwise, throws.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.InsertAtIndex">
            <summary>
            If you're maintaining a sorted array, use this index for inserting new elements.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.InsertAtIndex2">
            <summary>
            If you're maintaining a sorted array, use this index for inserting new elements.
            Makes stable order if you're doing binsearch with <see cref="F:JetBrains.Util.dataStructures.OfEqualItems.TakeLast"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.IsHit">
            <summary>
            Gets whether the search found any results.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotAboveTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotAboveTargetOrFirst">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotAboveTargetOrMinus1">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns -1.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotBelowTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotBelowTargetOrCount">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns the number of items in the list (the first free index).
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotBelowTargetOrLast">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotAboveTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotAboveTargetOrFirst">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotBelowTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotBelowTargetOrLast">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="T:JetBrains.Util.IEquatableList`1">
            <summary>
            A list whose <see cref="M:System.Object.Equals(System.Object)"/> compares the items in their exact sequence (<see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Util.EquatableList`1">
            <summary>
            A list whose <see cref="M:System.Object.Equals(System.Object)"/> compares the items in their exact sequence (<see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.ICountable`1">
            <summary>
            Exposes the enumerator, which supports a simple iteration over a collection of a specified type 
            and count of objects in the collection.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.IFreezable">
            <summary>
            Freezable pattern: allows to use serializers which require writable members (e.g. XAML) and then still have a readonly object.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.IIndexable`1">
            <summary>
            Countable readonly collection with access by index
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.ObjectPool`1">
            <remarks>
            All methods of this class are thread safe
            </remarks>>
            <typeparam name="T">The type of the entities in the pool</typeparam>
        </member>
        <member name="M:JetBrains.Util.Collections.ObjectPool`1.GetObject(JetBrains.DataFlow.Lifetime)">
            <summary>
            Gets an object from the pool. Object is returned to the pool as lifetime is terminated.
            If there are no vacant objects the new one is created using the factory passed to the constructor
            </summary>
            <param name="lifetime">Lifetime of the object using, terminate it when finish using of the object in order to return it to the pool</param>
            <returns>Return an object from the pool</returns>
        </member>
        <member name="M:JetBrains.Util.Collections.ObjectPool`1.GetObject">
            <summary>
            Gets an object from the pool. Object must be returned to the pool via <see cref="M:JetBrains.Util.Collections.ObjectPool`1.ReturnObject(`0)"/> method.
            If there are no vacant objects the new one is created using the factory passed to the constructor
            </summary>
            <returns>Return an object from the pool</returns>
        </member>
        <member name="M:JetBrains.Util.Collections.ObjectPool`1.CreateAndGetObject(JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates the new object using factory passed to the constructor and returns it
            </summary>
            <param name="lifetime"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.ObjectPool`1.AddObjectToPool(`0)">
            <summary>
            Adds another object to the pool
            </summary>
            <param name="object"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.ObjectPool`1.ReturnObject(`0)">
            <summary>
            Return the object taken with <see cref="M:JetBrains.Util.Collections.ObjectPool`1.GetObject"/> method to the pool. 
            If there are no vacant objects the new one is created using the factory passed to the constructor
            </summary>
        </member>
        <member name="T:JetBrains.Util.CommandLineBuilderJet">
            <summary>
            Mimics the MSBuild's <c>CommandLineBuilder</c> by its API over our <see cref="T:JetBrains.Util.CommandLineUtil"/> so that to avoid references to MSBuild utils.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CommandLineBuilderJet.AppendParameterWithQuoting(System.String)">
            <summary>
            Appends a separate command line parameter, quoting it if required for consistent parsing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CommandLineBuilderJet.op_Implicit(JetBrains.Util.CommandLineBuilderJet)~System.String">
            <summary>
            Turns into a command line string.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods">
            <summary>
            Non-thread-bound part of the dispatcher platform-specific implementation. This is exposed with static methods on the <see cref="T:JetBrains.Threading.JetDispatcher"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods.CreatePerThreadInstance">
            <summary>
            Creates per-thread instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods.PumpMessagesOnce">
            <summary>
            Pumps all the Windows messages (and async actions) currently on the queue, and terminates.
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods.Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods.Run(System.TimeSpan)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout" /> period of time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherStaticMethods.Run">
            <summary>
            Employs the current thread.
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="!:BeginInvokeShutdown" /> is invoked for this dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.JetConcurrentQueue`1">
            <summary>
            Concurrent blocking queue with predefined size. All operations are thread safe. Operations like <code>ToArray</code> or <code>GetEnumerator</code>
            takes queue snapshot at some moment.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.#ctor(System.Int32)">
            <summary>
            Constructs queue with predefined size. Queue size is defined logarithmically. Queue is not growing, nor shrinking.
            </summary>
            <param name="logMaxSize">From 1 to 20. Real queue size will be 1&lt;&lt;<see cref="!:logMaxSize"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryAdd(`0)">
            <summary>
            Enqueues to the tail of the queue. Increases tail.
            </summary>
            <param name="t"></param>
            <returns></returns>    
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            Dequeues from the head of the queue. Moves head.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryPeek(`0@)">
            <summary>
            Peeks from the head of the queue. Leaves head untouched. Sequential peeks will return same result if no other thread dequeues or clears simultaneously.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryTake(`0@)">
            <summary>
            Same as <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)"/>. Implementation of <see cref="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)"/>
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.Dequeue">
            <summary>
            Same as <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)"/> but returns <code>null</code> <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)"/> returns false
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.Peek">
            <summary>
            Same as <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryPeek(`0@)"/> but returns <code>null</code> when <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryPeek(`0@)"/> returns false
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.Concurrency.JetConcurrentQueue`1.Count">
            <summary>
            Number of elements in queue snapshot.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Concurrency.JetConcurrentQueue`1.SyncRoot">
            <summary>
            Not real SyncRoot, but you can use it for external synchronization
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.UnixJetDispatcher">
            <summary>
            Proccesses async operations like single-threaded executor, not pump any widow sytem's events.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.RunThreadWaitTimeout">
            <summary>
            Timeout for <see cref="M:JetBrains.Threading.JetDispatcher.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)"/> method's waiting for messages.
            If non-infinite, wakes the thread from time to time, which is nice for the tests (but not essential).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myDispatchers">
            <summary>
            Dispatchers by their owning threads.
            Copy-on-write: instances are readonly, reads are lock-free, writes are lock-and-replace (<see cref="F:JetBrains.Threading.JetDispatcher.myDispatchersWriterLock"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myDispatchersWriterLock">
            <summary>
            Syncs write access to <see cref="F:JetBrains.Threading.JetDispatcher.myDispatchers"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myDontRun">
            <summary>
            Means the <see cref="M:JetBrains.Threading.JetDispatcher.Run"/> method should abort.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.OptionQueueReasonableSizeLimit">
            <summary>
            Report an exception when the queue reaches this limit. Shouldn't be stacking these many actions on the queue.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.#ctor">
            <summary>
            Creates an instance, for use only from <see cref="P:JetBrains.Threading.JetDispatcher.CurrentDispatcher"/>.
            Must be called under the <see cref="F:JetBrains.Threading.JetDispatcher.myDispatchersWriterLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.GetThreadStaticData">
            <summary>
            Gets implementation-specific <see cref="T:JetBrains.Util.IUserDataHolder"/>. Use only in dispatcher's internals.
            </summary>        
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.Thread">
            <summary>
            Gets the thread the dispatcher is running on.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AssertFreeThreaded">
            <summary>
            Asserts that the calling method is free-threaded. A marker function that does not do anything.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CreateDispatcherThread(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Creates a new <see cref="F:System.Threading.ApartmentState.STA"/> <see cref="T:System.Threading.Thread"/> that is controlled by a <see cref="T:JetBrains.Threading.JetDispatcher"/>.
            To stop the thread, use <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvokeShutdown"/>.
            </summary>
            <param name="lifetime"></param>
            <param name="name">Arbitrary name for the new thread.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.FromThread(System.Threading.Thread)">
            <summary>
            <para>Tries to get a dispatcher for the specified <paramref name="thread"/>, if already created.</para>
            <para>Returns <c>Null</c> if no dispatcher is running on that thread. To create a new dispatcher, use the <see cref="P:JetBrains.Threading.JetDispatcher.CurrentDispatcher"/> property on the desired thread.</para>
            </summary>
            <param name="thread">The thread to get a dispatcher for.</param>
            <returns>The existing dispatcher for that thread, or <c>Null</c>.</returns>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.PumpMessagesOnce">
            <summary>
            <para>Pumps all the Windows messages (and async actions) currently on the queue, and terminates.</para>
            <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.</para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition"/> is true, but for at most <paramref name="timeout"/> period of time, if the thread supports message pumps; sleeps otherwise.</para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="ontimeout"/> is <see cref="F:JetBrains.Threading.OnWaitTimeout.Fail"/>, in which case an exception is thrown.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.</para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(System.Func{System.Boolean},System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition"/> is true, but for at most <paramref name="timeout"/> period of time, if the thread supports message pumps; sleeps otherwise.</para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="ontimeout"/> is <see cref="F:JetBrains.Threading.OnWaitTimeout.Fail"/>, in which case an exception is thrown.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(System.Threading.Tasks.Task,System.TimeSpan,System.Boolean)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until the given task <paramref name="waitUntilDone" /> is completed, but for at most <paramref name="timeout" /> period of time.</para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(System.Threading.Tasks.Task,System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until the given task <paramref name="waitUntilDone"/> is completed, but for at most <paramref name="timeout"/> period of time, if the thread supports message pumps; sleeps otherwise.</para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="ontimeout"/> is <see cref="F:JetBrains.Threading.OnWaitTimeout.Fail"/>, in which case an exception is thrown.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(System.TimeSpan)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout" /> period of time.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(System.TimeSpan)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout" /> period of time, if the thread supports message pumps.</para>
              <para>Sleeps out the given amount of time otherwise.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run">
            <summary>
              <para>Employs the current thread.</para>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvokeShutdown"/> is invoked for this dispatcher.</para>
              <para>This method only works on threads which support message pumps, and there is no sleep-version because that would be an infinite sleep.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Sleep(System.Func{System.Boolean},System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
            Implements sleeping for the run-or-sleep methods family, for non-STA threads.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AssertAccess">
            <summary>
            Throws if the current thread is not the thread associated with this dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AssertAsyncBehaviorSupported">
            <summary>
            Throws if asynchronous operations are not supported on the dispatcher thread.
            </summary>
            <seealso cref="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited"/>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Invoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, asynchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvoke(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, asynchronously.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="F:JetBrains.Threading.JetDispatcher.Logger"/>.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvokeShutdown">
            <summary>
            Shuts down a dispatcher on its thread, asynchronously.
            Breaks the <see cref="M:JetBrains.Threading.JetDispatcher.Run"/>, if any.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginOrInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginOrInvoke(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="F:JetBrains.Threading.JetDispatcher.Logger"/>.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CheckAccess">
            <summary>
            Returns whether the calling thread is the thread associated with this dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.IsSupportedOnThisThread">
            <summary>
            Gets whether the current thread has been initialized with the apartment which supports the Dispatcher pattern (<see cref="F:System.Threading.ApartmentState.STA"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.CurrentDispatcher">
            <summary>
            Gets or creates a dispatcher for the current thread.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited">
            <summary>
            <para>Gets or sets whether posting messages to the dispatcher thread is allowed or not.</para>
            <para>If the thread has no message pump, or is not pumping currently, you can prohibit queueing the deferred actions thru this dispatcher by raising this flag.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.IsShutDown">
            <summary>
            Gets whether this dispatcher has been shut down and will not <see cref="M:JetBrains.Threading.JetDispatcher.Run"/> any more requests.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.Closure">
            <summary>
            Implements a method that runs on another thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.Closure.myAction">
            <summary>
            Action to execute, <c>Null</c>ed if the lifetime is terminated (execution is canceled).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.Closure.Generation">
            <summary>
            Execution generation to which this schedulled action closure belongs. See usage for details.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Closure.Execute">
            <summary>
            Executes the marshalled action.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, asynchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.BeginInvoke(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, asynchronously.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="F:JetBrains.Threading.JetDispatcher.Logger"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.BeginOrInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.BeginOrInvoke(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="F:JetBrains.Threading.JetDispatcher.Logger"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.Invoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.BeginInvokeCore(JetBrains.Threading.JetDispatcher.Closure)">
            <summary>
            Actually schedules deferred invocation of the action.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.UnixJetDispatcherStaticMethods.PumpMessagesOnce">
            <summary>
            Pumps all the Windows messages (and async actions) currently on the queue, and terminates.
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.UnixJetDispatcherStaticMethods.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition"/> is true, but for at most <paramref name="timeout"/> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout"/> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.UnixJetDispatcherStaticMethods.Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition"/> is true, but for at most <paramref name="timeout"/> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout"/> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.UnixJetDispatcherStaticMethods.Run(System.TimeSpan)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout"/> period of time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixJetDispatcher.UnixJetDispatcherStaticMethods.Run">
            <summary>
            Employs the current thread.
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="!:BeginInvokeShutdown"/> is invoked for this dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.WinJetDispatcher">
            <summary>
            Emulates the <c>System.Windows.Threading.Dispatcher</c> class on top of netfx40.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.OptionCallNativeMarshallerEveryItems">
            <summary>
            To increase reliability, the system marshaller will be additionally called when a multiple of this number is reached on the queue (if the first marshaller calls are lost due to some accident (e.g. system marshaller silently ignoring message postings when the Windows messages queue is full), we might never ever process the queue).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.OptionCallNativeMarshallerForFirstItems">
            <summary>
            To increase reliability, the system marshaller will be called for these first items added to the queue.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myControlInstanceForStaticMethods">
            <summary>
            There're static methods that require a control this.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myExternalIdleProcessing">
            <summary>
            Main thread modification only. Any thread access. <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.SetIdleProcessingExternalDriver(JetBrains.DataFlow.Lifetime,JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver)"/> backend.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myGeneration">
            <summary>
            Provides the generation number for <see cref="F:JetBrains.Threading.JetDispatcher.Closure.Generation"/>.
            Can be read free-threaded (because in absence of synchronization you cannot prove violation of invariants).
            Incremented under the <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.myQueueLock"/>.
            Must not be zero.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myMarshaller">
            <summary>
            System implementation of the entity actually deferring the execution.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myPreTranslates">
            <summary>
            Custom message translators that could be registered on the fly, and will be executed before the standard message procesing.
            </summary>
            <remarks>The collection is copy-on-write.</remarks>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myPriorityBuckets">
            <summary>
            A lazy-inited queue (plus some additional state/cache) per each item priority class.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.myQueueLock">
            <summary>
            Syncs write access to <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.myPriorityBuckets"/>, their fields, and their queues, and <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.myGeneration"/>, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, asynchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.BeginInvoke(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, asynchronously.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="T:JetBrains.Util.Logging.Logger"/>.</param>
            <param name="priority"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.BeginOrInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.BeginOrInvoke(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="T:JetBrains.Util.Logging.Logger"/>.</param>
            <param name="priority"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.Invoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the dispatcher thread, synchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.RegisterPreTranslate(JetBrains.DataFlow.Lifetime,System.Func{JetBrains.Interop.WinApi.MSG,System.Boolean})">
            <summary>
            Register a custom Windows message processor and put it at the beginning of the handler list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.SetIdleProcessingExternalDriver(JetBrains.DataFlow.Lifetime,JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver)">
            <summary>
            See <see cref="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver"/>, <see cref="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnIdle"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.BeginInvokeCore(JetBrains.Threading.JetDispatcher.Closure,System.Boolean)">
            <summary>
            Actually schedules deferred invocation of the action.
            </summary>
            <param name="closure"></param>
            <param name="isProbing">A synthetic scheduled item to make sure the queue gets pumped, see usages.</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.Init">
            <summary>
            Init the instance (activities not related to the registration of this instance).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ProcessQueue(System.Int32)">
            <summary>
              <para>Called indirectly from <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.BeginInvokeCore(JetBrains.Threading.JetDispatcher.Closure,System.Boolean)"/> by executing thru the marshaller asynchronously.</para>
              <para>Starts processing the higest-priority actions, if any, then lower, and so on, down to the lowest-allowed <paramref name="nMinBucket"/>.</para>
            </summary>
            <param name="nMinBucket">The lowest buckets in <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.myPriorityBuckets"/> which can be processed on this call.</param>
            <returns>Whether processing has been interrupted without doing all of the items it could do (e.g. by idle state revocation). This mimcs the return value semantic of </returns>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.DispatcherPriorityBucket.FProcessQueue">
            <summary>
            Lazy-created delegate which invokes <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ProcessQueue(System.Int32)"/> for this priority class.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.DispatcherPriorityBucket.ItemsQueuedSinceLastExecution">
            <summary>
            Calculates the items added to <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.DispatcherPriorityBucket.PendingInvocationsQueue"/> since the last time those items were processed by the executor.
            This is needed to post to the underlying marshaller only so rarely, and to make sure we post one more marshaller request when we start queueing nested items for execution (BeginInvoke from within another BeginInvoke execution which pumps messages).
            Also reset when the queue gets empty.
            Accessed under <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.myQueueLock"/> only.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.DispatcherPriorityBucket.PendingInvocationsQueue">
            <summary>
              <para>Default implementation of all the known marshallers (<see cref="T:System.Windows.Forms.WindowsFormsSynchronizationContext"/> in WinForms and <see cref="T:System.Windows.Threading.Dispatcher"/> in Avalon) would post a new Windows message on the queue on every <c>BeginInvoke</c> call. This poses a problem because we might really have lots and lots of <c>BeginInvoke</c> calls (some of them canceled later), and the Windows messages queue is of a finite size.</para>
              <para>We only post one (or a few) requests on the <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.myMarshaller"/>, and the actual actions to process reside on the queue here.</para>
              <para>This field is lazy-inited on first use.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.myDriver">
            <summary>
            Written on the main thread, read on any thread, sync not required.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IsContiueIdle">
            <summary>
            If we're running idle tasks, tells if we're OK to run more.
            Calls <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.IsContiueIdle"/> if avail, otherwise OK.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.TryRequestIdleProcessing">
            <summary>
            Calls <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing"/> on the current one, returns whether present and successful (= do not call default impl).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnExternalDriverIdle">
            <summary>
            Callback functor to give out to driver on <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.Set(JetBrains.DataFlow.Lifetime,JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.Reset">
            <summary>
            Undoer for <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.Set(JetBrains.DataFlow.Lifetime,JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver)"/>, called upon lifetime termination or on a fault.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IdleProcessingResult">
            <summary>
            Idle processing results, values must map to <c>FDoIdle</c> return values.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IdleProcessingResult.AllDone">
            <summary>
            Don't call <see cref="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnIdle"/> callback until you're asked again with <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IdleProcessingResult.HaveMore">
            <summary>
            Call <see cref="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnIdle"/> once more as soon as the idle state is achieved again.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver">
            <summary>
              <para>User handler to install the IDLE processing external driver.</para>
              <para>By default, IDLE tasks are scheduled with an idle priority level of the system Dispatcher. Installing an external driver replaces this with a custom implementation.</para>
              <para>An example of the custom implementation is the Visual Studio <c>FDoIdle</c> callback.</para>
              <para>This handler gets installed with <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.SetIdleProcessingExternalDriver(JetBrains.DataFlow.Lifetime,JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver)"/>, only one at a time.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.IsContiueIdle">
            <summary>
              <para><see cref="T:JetBrains.Threading.JetDispatcher"/> calls this on the external idle driver while processing the idle tasks on the queue, asks whether it's OK to continue doing so, or the idle state might not hold anymore.</para>
              <para>Maps to <c>IMsoComponentManager::FContinueIdle</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing">
            <summary>
              <para><see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing"/> will be called when implementation thinks it should ping the underlying scheduler (not per every scheduled event, but with throttling) to schedule the idle processing.</para>
              <para>After that, the driver should call the <see cref="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnIdle"/> callback it has been given upon registration when it thinks the idle state has been reached, and continue doing so as long as it gets <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IdleProcessingResult.HaveMore"/>. After the idle events have been processed by this <see cref="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnIdle"/> callback with a successful return value, it is guaranteed that the driver will be called for <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.TryRequestIdleProcessing"/> anew at least once the next time new idle events are added.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.OnIdle">
            <summary>
            Given you when you register a new external driver with <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.Set(JetBrains.DataFlow.Lifetime,JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver)"/>. Call when you detect the idle time after you've been requested for that with <see cref="M:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing"/> and until this delegate returns <see cref="F:JetBrains.Util.Concurrency.WinJetDispatcher.ExternalIdleProcessing.IdleProcessingResult.AllDone"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.InternalPumpMessagesOnce">
            <summary>
            Implements a custom message pump for pumping all of the messages currently in the queue.
            </summary>
            <returns>The number of messages pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.InternalWaitForMessages(System.UInt32)">
            <summary>
            Waits until there are messages in the queue, for the <paramref name="timeout" /> milliseconds at most (-1 to wait infinitely).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.JetBrains#Util#Concurrency#IJetDispatcherStaticMethods#PumpMessagesOnce">
            <summary>
            Pumps all the Windows messages (and async actions) currently on the queue, and terminates.
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.JetBrains#Util#Concurrency#IJetDispatcherStaticMethods#Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.JetBrains#Util#Concurrency#IJetDispatcherStaticMethods#Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.JetBrains#Util#Concurrency#IJetDispatcherStaticMethods#Run(System.TimeSpan)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout" /> period of time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinJetDispatcher.WinJetDispatcherStaticMethods.JetBrains#Util#Concurrency#IJetDispatcherStaticMethods#Run">
            <summary>
            Employs the current thread.
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="!:BeginInvokeShutdown"/> is invoked for this dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ISignal`1">
            <summary>
            An event-like signal that can be sinked by any number of listeners, fired by any number of external callers, and takes part in the data flow infrastructure.
            Suitable for use in MVC's codebehind, when the event should be fireable by the views.
            </summary>
            <typeparam name="TValue">The type of the payload, should a signal have any. <see cref="T:System.Boolean"/> is the simplest default.</typeparam>
            <remarks>
            <para>The signal uses an <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> as its underlying transport. 
            The signal is considered to be fired when the property value changes, 
            has both <see cref="T:JetBrains.DataFlow.PropertyChangedEventArgs`1"/> and <see cref="T:JetBrains.DataFlow.PropertyChangedEventArgs`1"/>, 
            and the value is falling (changes to <c>default(TValue)</c>).</para>
            <para>For the signal to take part in the data flow, use its underlying property in the bindings.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ISignal`1.Advise(JetBrains.DataFlow.Lifetime,System.Action{`0})">
            <summary>
            Advises the signal event for the duration of the <paramref name="lifetime"/> so that the <paramref name="handler"/> is called when the signal fires.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignal`1.Fire(`0)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignal`1.Fire(`0,System.Object)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
            <param name="cookie">A cookie for the <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)"/> of the underlying <see cref="P:JetBrains.DataFlow.ISignal`1.Property"/>.</param>
        </member>
        <member name="P:JetBrains.DataFlow.ISignal`1.Id">
            <summary>
            Gets the identifier of this signal.
            Getting the ID from the underlying property will lazy-create the property, while this getter is cheap.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ISignal`1.Property">
            <summary>
            Gets the underlying property of the signal.
            Initially, the signal has no underlying property attached (unless you explicitly give it in the constructor).
            When the getter is accessed, an underlying property is created.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ISignal`1.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataFlow.ISignalOptionalFiring`1.IsAnyoneSinking">
            <summary>
            Gets whether anyone is sinking this signal at all.
            If not, you can skip preparing the event args and firing the event altogether.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Signal`1">
            <summary>
            <para>An event-like signal that can be advised by any number of event sinks, fired by any number of external callers, and takes part in the data flow infrastructure.</para>
            <para>Suitable for use in MVC's codebehind, when the event should be fireable by the views.</para>
            </summary>
            <typeparam name="TValue">The type of the payload, should a signal have any. <see cref="T:System.Boolean"/> is the simplest default.</typeparam>
        </member>
        <member name="T:JetBrains.DataFlow.IUntypedSignal">
            <summary>
            A type-invariant interface to the <see cref="T:JetBrains.DataFlow.Signal`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedSignal.Advise(System.Action{System.Object},JetBrains.DataFlow.Lifetime)">
            <summary>
            Advises the signal event for the duration of the <paramref name="lifetime"/> so that the <paramref name="handler"/> is called when the signal fires.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedSignal.Fire(System.Object,System.Object)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
            <param name="cookie">A cookie for the <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)"/> of the underlying <see cref="P:JetBrains.DataFlow.IUntypedSignal.Property"/>.</param>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedSignal.Id">
            <summary>
            Gets the identifier of this signal.
            Getting the ID from the underlying property will lazy-create the property, while this getter is cheap.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedSignal.Property">
            <summary>
            Gets the underlying property of the signal.
            Initially, the signal has no underlying property attached (unless you explicitly give it in the constructor).
            When the getter is accessed, an underlying property is created.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedSignal.ArgumentType">
            <summary>
            Gets the type of the signal arguments object. This is the type parameter of the typed <see cref="T:JetBrains.DataFlow.ISignal`1"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition">
            <summary>
            Makes the object operable for writing/firing on the given thread only.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.IStandardPrecondition">
            <summary>
            <para>Base interface for standard preconditions.</para>
            <para>These exist to allow fast implementations for standard preconditions on signals and properties, such as thread affinity and readonly validators.</para>
            <para>When implemented as custom preconditions on a property, handlers are attached to <see cref="T:JetBrains.DataFlow.IProperty`1"/>'s <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> event. In case of a <see cref="T:JetBrains.DataFlow.ISignal`1"/> or <see cref="T:JetBrains.DataFlow.ISimpleSignal"/>, the handlers are attached to <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> of the underlying <see cref="P:JetBrains.DataFlow.ISignal`1.Property"/> of the signal, which causes the property to be created in the first place and cause all the firings routed thru it. Standard preconditions are implemented in the object core and do not cause any external handlers called or underlying properties created.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread(JetBrains.DataFlow.Lifetime,System.Threading.Thread)">
            <summary>
            Makes the object operable for writing/firing on the given thread only.
            It's an error to call this method more than once (without disposing of the previous result first).
            </summary>
            <param name="lifetime">Lifetime of the validator.</param>
            <param name="thread">The thread to which the object should be affined for writing/firing from now on.</param>
            <returns>Undo token.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition">
            <summary>
            Locks writes/firings on the object by requiring all the modification attempts to provide a valid token equal to the given one.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
             <summary>
             Locks writes/firings on the object by requiring all the modification attempts to provide a valid token equal to the given one.
             It's an error to call this method more than once (without disposing of the previous result first).
             </summary>
            <param name="lifetime">Lifetime for the readonly lock.</param>
            <param name="token">A token that must be provided by all the parties trying to change the object state.
            <c>Null</c>
            is ignored and no precondition is set.</param>
            <returns>Undo token.</returns>
             <remarks>A <c>Null</c> value for <paramref name="token"/> is allowed only to support temporary [debug] conditions where some component has a readonly token data field set to <c>Null</c> for use in both preconditions and callers, to temporarily allow foreign writers/firers.</remarks>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myId">
            <summary>
            Stores the identifier of the signal. This is always not <c>Null</c>.
            Used for lazy-creating the <see cref="F:JetBrains.DataFlow.Signal`1.myProperty"/> with this ID.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myProperty">
            <summary>
            The underlying property useful for data flow bindings.
            Lazy-created at the moment when it's first requested externally via <see cref="P:JetBrains.DataFlow.Signal`1.Property"/>.
            Until that moment, is <c>Null</c> unless passed into the ctor.
            This is done to break the property-signal-property chain and allow for using both signals in the property and properties in the signal.
            Access must be synchronized via <see cref="F:JetBrains.DataFlow.Signal`1.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myReadOnlyLock">
            <summary>
            Non-<c>Null</c> when the object has a standard precondition on read-only lock set thru <see cref="T:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.mySinks">
            <summary>
            Stores the event sinks.
            Write access must be synchronized with <see cref="F:JetBrains.DataFlow.Signal`1.myLock"/> and should do copy-on-write.
            Read access is free-threaded.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myThreadAffinedTo">
            <summary>
            Non-<c>Null</c> when the object has a standard precondition on thread affinity set thru <see cref="T:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myUnderlyingPropertyAffineToThread">
            <summary>
            Helps with propagating <see cref="M:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread(JetBrains.DataFlow.Lifetime,System.Threading.Thread)"/> to the underlying property, if it exists.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myUnderlyingPropertyReadOnlyLock">
            <summary>
            Helps with propagating <see cref="M:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)"/> to the underlying property, if it exists.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(System.String)">
            <summary>Creates the signal.</summary>
            <param name="id">
            <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>Creates the signal.</summary>
            <param name="lifetime">
            <para>Defines the lifetime for the signal.</para>
            <para>When lifetime terminates, all of the handlers are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{`0},JetBrains.Util.ILogger)">
            <summary>Creates the signal.</summary>
            <param name="lifetime">
            <para>Defines the lifetime for the signal.</para>
            <para>When lifetime terminates, all of the handlers are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Optional logging engine override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0})">
            <summary>
            Creates the signal on the existing underlying property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnAfterAdvise(System.Action{`0})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnAfterUnadvise(System.Action{`0})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnBeforeAdvise(System.Action{`0})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.AdviseCore(System.Action{`0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Core implementation of the Advise methods family
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.AttachToProperty(JetBrains.DataFlow.IProperty{`0})">
            <summary>
            Attaches to the underlying property, either in ctor or upon lazy-creation.
            It's assumed that a lock is taken externally by the caller, as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Init(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{`0})">
            <summary>
            Shared part of the ctor.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.NotifySinks(`0)">
            <summary>
            Iterates on the sinks registered for handling the signal.
            Invokes each in turn, maintaining the exception isolation.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnUnderlyingPropertyChanged(JetBrains.DataFlow.PropertyChangedEventArgs{`0})">
            <summary>
            When working over a property, checks for its changes, whether to notify the sinks of the event happening.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.JetBrains#DataFlow#StandardPreconditions#IReadOnlyPrecondition#LockReadOnly(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
             <summary>
             Locks writes/firings on the object by requiring all the modification attempts to provide a valid token equal to the given one.
             It's an error to call this method more than once (without disposing of the previous result first).
             </summary>
            <param name="lifetime"></param>
            <param name="token">A token that must be provided by all the parties trying to change the object state.
            <c>Null</c>
            is ignored and no precondition is set.</param>
            <returns>Undo token.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Fire(`0)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Fire(`0,System.Object)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
            <param name="cookie">A cookie for the <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)"/> of the underlying <see cref="P:JetBrains.DataFlow.ISignal`1.Property"/>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.JetBrains#DataFlow#StandardPreconditions#IThreadAffinityPrecondition#AffineToThread(JetBrains.DataFlow.Lifetime,System.Threading.Thread)">
            <summary>
            Makes the object operable for writing/firing on the given thread only.
            It's an error to call this method more than once (without disposing of the previous result first).
            </summary>
            <param name="lifetime"></param>
            <param name="thread">The thread to which the object should be affined for writing/firing from now on.</param>
            <returns>Undo token.</returns>
        </member>
        <member name="P:JetBrains.DataFlow.Signal`1.Id">
            <summary>
            Gets the identifier of this signal.
            Getting the ID from the underlying property will lazy-create the property, while this getter is cheap.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Signal`1.Property">
            <summary>
            Gets the underlying property of the signal.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple">
            <summary>
            A stream which allows to access memory outside the process' virtual address space. That would be RAM if enough is available, or it might be paged out to disk.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.mySubstreamsFixedLength">
            <summary>
            List of substreams currently opened within the body of the main stream, which have a fixed length and cannot be grown.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.mySubstreamAppending">
            <summary>
            At most one substream currently writing at the end of the main stream; this one has a growing length.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.DefaultBankSizeExponent">
            <summary>
            The default exponent (base is 2) for the bank size.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.DefaultOpenBanksLimit">
            <summary>
            The default number of banks which can be mapped into process memory at the same time.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.myMruBank">
            <summary>
            MRU bank from <see cref="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.myBanks"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.myBanks">
            <summary>
            Caches a few open banks.
            The idea is that the structured storage file system managing code would be writing the content and the filesystem tables intermittently, so the file tables' banks better be left open.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.myBankSizeExponent">
            <summary>
            The exponent (base is 2) for the bank size.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.myOpenBanksLimit">
            <summary>
            The number of banks which can be mapped into process memory at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.#ctor(JetBrains.DataFlow.Lifetime,System.UInt64,JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.BankSpec)">
            <summary>
            </summary>
            <param name="lifetime">The lifetime for unmanaged resources behind the stream.</param>
            <param name="qwLengthLimit">The maximum length of the stream. This memory is not initially committed. Must be a multiple of the bank size.</param>
            <param name="bankspec">Bank fine tuning.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.#ctor(JetBrains.DataFlow.Lifetime,System.Void*,System.UInt64,System.UInt64,JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.BankSpec)">
            <summary>
            </summary>
            <param name="lifetime">The lifetime for unmanaged resources behind the stream.</param>
            <param name="hExternalMmf">An externally-created MMF, to attach to, or NULL to create a new one.</param>
            <param name="qwLengthLimit">The maximum length of the stream (this memory is not initially committed), if no external MMF is specified. Otherwise it's assumed to be the size of the pre-allocated MMF. Must be a multiple of the bank size.</param>
            <param name="qwWrittenLength">This number of bytes at the beginning of the <see cref="!:hExternalMmf"/> is considered as already written. Stream <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Length"/> returns this value.</param>
            <param name="bankspec">Bank fine tuning.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Attach(JetBrains.DataFlow.Lifetime,System.Void*,System.UInt64,System.UInt64,JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.BankSpec)">
            <summary>
            Attaches to an existing memory-mapped file.
            </summary>
            <param name="lifetime">Stream lifetime, and lifetime of all the MMF views it opens. The MMF itself isn't destroyed when the lifetime ends.</param>
            <param name="hExistingMmf">An already-open MMF of size <paramref name="qwMmfSize"/>.</param>
            <param name="qwMmfSize">Total size of the <paramref name="hExistingMmf"/>. Must be a multiple of the bank size.</param>
            <param name="qwWrittenLength">This number of bytes at the beginning of the <see cref="!:hExistingMmf"/> is considered as already written. Stream <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Length"/> returns this value.</param>
            <param name="bankspec">Bank fine tuning.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.CreateStandardMmf(JetBrains.DataFlow.Lifetime,System.UInt64)">
            <summary>
            Allocates an MMF the standard way, just as this object would do by default.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.ReadAt(System.UInt64,System.Void*,System.UInt32)">
            <summary>
            Reads a sequence of bytes from the current stream at the specified position without touching the stream <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Position"/> value.
            </summary>
            <param name="ulOffset">The stream offset to start reading at. The <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Position"/> is not considered or modified by this call.</param>
            <param name="pv">Points to the first byte of the destination buffer.</param>
            <param name="cb">The number of bytes to copy.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.ReleaseBanks">
            <summary>
            You can call this if you're not going to be using this object for some time. They'll be reopened automatically.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.WriteAt(System.UInt64,System.Void*,System.UInt32)">
            <summary>
            Writes a sequence of bytes to the current stream at the specified position without touching the stream <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Position"/> value. The stream <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Length"/> might however increase.
            </summary>
            <param name="ulOffset">The stream offset to start writing at. The <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Position"/> is not considered or modified by this call.</param>
            <param name="pv">Points to the first byte of the source buffer.</param>
            <param name="cb">The number of bytes to copy.</param>
            <returns>We don't return the number of written bytes because reading less than requested is a failure HR and will be thrown out as an exception.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.GetBankByViewPointer(System.UInt64,JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Bank@)">
            <summary>
            Gets the cached or openes a new bank whose view starts at the given offset (must be a multiple of the bank size).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.OpenSubstreamFixedLength(JetBrains.DataFlow.Lifetime,System.UInt64,System.UInt64,JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.ReadWrite)">
            <summary>
            Opens a stream which looks on a view within the body of this stream.
            Obviously, cannot change its length.
            </summary>
            <param name="lifetime"></param>
            <param name="start"></param>
            <param name="length"></param>
            <param name="rw"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.OpenSubstreamForAppending(JetBrains.DataFlow.Lifetime)">
            <summary>
            Opens a stream which writes to the end of this stream. Can grow both its length and the parent stream length. Can't have more than one such. Always RW.
            </summary>
            <param name="lifetime"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.LengthLimit">
            <summary>
            Gets the maximum <see cref="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Length"/> this object is allowed to reach.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.CanOpenSubstreamForAppendingNow">
            <summary>
            As only one appender substream can be opened at any given time, tells whether the <see cref="M:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.OpenSubstreamForAppending(JetBrains.DataFlow.Lifetime)"/> option is available.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.BankSpec">
            <summary>
            Defines how many banks and of which size this stream should use for accessing the memory.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.BankSpec.wBankSizeExponent">
            <summary>
            Optional. Allows to change the exponent (base 2) of the bank size. Zero means use default <see cref="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.DefaultBankSizeExponent"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.BankSpec.wOpenBanksLimit">
            <summary>
            Optional. Max number of banks which can be mapped into process memory at the same time.  Zero means use default <see cref="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.DefaultOpenBanksLimit"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.StateFlags.IsFrozen">
            <summary>
            <see cref="M:JetBrains.Util.Collections.IFreezable.Freeze"/> has been called.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Substream">
            <summary>
            An effective stream on subrange, in that it does not add an extra layer of calls.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Substream.SubFlags.IsFrozen">
            <summary>
            <see cref="M:JetBrains.Util.Collections.IFreezable.Freeze"/> has been called, here or on parent.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.BankSwitchingMemoryStreamSimple.Substream.SubFlags.IsFixedLength">
            <summary>
            This stream can't grow by writing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)">
            <summary>
              <para>Searches a one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1"/> for a value using the binary search algorithm.</para>
              <para>The desired item is identified by its so-called key given in <paramref name="keyLookFor"/>, and a transformation is defined as <paramref name="FGetKeyOfItem"/> for getting a key out of each list item. The comparison (and list sorting requirement) applies to these keys derived from the items.</para>
              <para>Optionally, the comparer could be overridden. This is recommended for custom value types to avoid boxing, unless they're <see cref="T:System.IComparable`1"/>.</para>
              <para>The advantage of this method over the one using a locator, <see cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,JetBrains.Util.Locator{``0})"/>, is that it can work on cached delegates/comparers and does not require creating a closure for each new location session. Also, there's no locator left-right argument confusion.</para>
            </summary>
            <typeparam name="TItem">Type of the actual items in the list.</typeparam>
            <typeparam name="TKey">Type of the so-called key by which the items are sorted and located in the list. This could be either an actual field/property of the item, or a completely synthetic value calculated on the item.</typeparam>
            <param name="list">The list of items to search. Must be sorted by their keys.</param>
            <param name="keyLookFor">Key we're looking for. If it is equal to a key of some item in the list, that item is returned as a search result. If no items correspond to the key, the result points “in between” array items, see return value members for telling this cases apart or using the found location, for example, <see cref="M:JetBrains.Util.BinarySearchResult`1.InsertAt(`0)"/>.</param>
            <param name="index">Starting index of the list range to search in. <c>0</c> is the default.</param>
            <param name="length">Length of the list range to search in. <c>-1</c> is the default and means that the whole list must be searched.</param>
            <param name="FGetKeyOfItem">
              <para>A transformation which produces a key for any of the list items. Items are sorted by these keys, and keys are used for locating items. This could be either an actual field/property of the item, or a completely synthetic value calculated on the item.</para>
              <para>In performance-critical scenarios, cache this delegate. Normally it's a static method and thus does not require a new closure each time.</para>
            </param>
            <param name="keycomparer">A custom comparer over item keys, if needed. If omitted, the <see cref="P:System.Collections.Generic.Comparer`1.Default">standard comparer</see> is used.</param>
            <param name="which">If there're multiple equal items in the list, which one of them should be taken for a hit.</param>
            <returns>The search result which can tell you if any item was hit, at which index to insert the new item, what's the closest index before/after the search target, and so on.</returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)">
            <summary>
              <para>Searches a one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1"/> for a value using the binary search algorithm.</para>
              <para>This overload does comparison right on the items. If the list is sorted by just one property of the item, use the overload with item-key metaphor.</para>
              <para>Optionally, the comparer could be overridden. This is recommended for custom value types to avoid boxing, unless they're <see cref="T:System.IComparable`1"/>.</para>
              <para>The advantage of this method over the one using a locator, <see cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,JetBrains.Util.Locator{``0})"/>, is that it can work on cached delegates/comparers and does not require creating a closure for each new location session. Also, there's no locator left-right argument confusion.</para>
            </summary>
            <typeparam name="TItem">Type of the actual items in the list. They're the sorting keys of the list as well.</typeparam>
            <param name="list">The list of items to search. Must be sorted by their keys.</param>
            <param name="itemLookFor">Item we're looking for, which itself is also the sorting/search key. If it is equal to some item in the list, that item is returned as a search result. If no items are hit, the result points “in between” array items, see return value members for telling this cases apart or using the found location, for example, <see cref="M:JetBrains.Util.BinarySearchResult`1.InsertAt(`0)"/>.</param>
            <param name="index">Starting index of the list range to search in. <c>0</c> is the default.</param>
            <param name="length">Length of the list range to search in. <c>-1</c> is the default and means that the whole list must be searched.</param>
            <param name="keycomparer">A custom comparer over items, if needed. If omitted, the <see cref="P:System.Collections.Generic.Comparer`1.Default">standard comparer</see> is used.</param>
            <param name="which">If there're multiple equal items in the list, which one of them should be taken for a hit.</param>
            <returns>The search result which can tell you if any item was hit, at which index to insert the new item, what's the closest index before/after the search target, and so on.</returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.GetOrCreateValue``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Func{``1})">
            <summary>
            Looks up an item in a binary-search-ready (sorted) list which is being used as a dictionary (values stored in the list are associated with some kind of keys which you use for comparing items in the list).
            Returns the found item.
            If not found, creates a new item, insers into the list on the proper position to maintain sorting, and returns this new item.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="list">Sorted list.</param>
            <param name="FGetKeyOfItem">The transformation for getting a key ot of an item stored in the list.</param>
            <param name="FCreateIfMissing">If the item is not found, this functor is called to create a new item.</param>
            <param name="key">The key whose item you would like to find in the list.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.TryGetValue``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0})">
            <summary>
            Looks up an item in a binary-search-ready (sorted) list which is being used as a dictionary (values stored in the list are associated with some kind of keys which you use for comparing items in the list).
            Returns the found item.
            If not found, returns <c>Null</c> coerced to the item type.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="list">Sorted list.</param>
            <param name="FGetKeyOfItem">The transformation for getting a key ot of an item stored in the list.</param>
            <param name="key">The key whose item you would like to find in the list.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.RemoveValue``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0})">
            <summary>
            Looks up an item in a binary-search-ready (sorted) list which is being used as a dictionary (values stored in the list are associated with some kind of keys which you use for comparing items in the list), and removes it.
            Returns whether the item was found.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="list">Sorted list.</param>
            <param name="FGetKeyOfItem">The transformation for getting a key ot of an item stored in the list.</param>
            <param name="key">The key whose item you would like to find in the list.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearchEx``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1"/> for the index of a specific value.
            </summary>
            <typeparam name="TItem">The type of the elements of the list.</typeparam>
            <param name="thіs">The sorted list to search.</param>
            <param name="item">The item to find.</param>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearchEx``1(System.Collections.Generic.IList{``0},JetBrains.Util.Locator{``0})">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1"/> for a value using the specified <paramref name="locator">comparer</paramref>.
            </summary>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="locator">The comparer to use when comparing elements. Delegate should compare its parameter to the item you're looking for.</param>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,JetBrains.Util.Locator{``0})">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1"/> for a value using the specified <paramref name="locator">comparer</paramref>.
            </summary>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="index"></param>
            <param name="length"></param>
            <param name="locator">The comparer to use when comparing elements.</param>
            <returns>The index of the specified value in the specified array, if value is found. If value is not found and value is less than one or more elements in array, a negative number which is the bitwise complement of the index of the first element that is larger than value. If value is not found and value is greater than any of the elements in array, a negative number which is the bitwise complement of (the index of the last element plus 1). </returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},JetBrains.Util.Locator{``0})">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1"/> for a value using the specified <paramref name="locator">comparer</paramref>.
            </summary>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="locator">The comparer to use when comparing elements.</param>
            <returns>The index of the specified value in the specified array, if value is found. If value is not found and value is less than one or more elements in array, a negative number which is the bitwise complement of the index of the first element that is larger than value. If value is not found and value is greater than any of the elements in array, a negative number which is the bitwise complement of (the index of the last element plus 1). </returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.OfEqualItems">
            <summary>
            If there're multiple equal items in the list, which one of them should be taken for a hit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.OfEqualItems.TakeAny">
            <summary>
            If there're multiple equal items in the list, take any of them for a hit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.OfEqualItems.TakeFirst">
            <summary>
            If there're multiple equal items in the list (must be contiguous in a sorted list), take the lowest-index one for a hit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.OfEqualItems.TakeLast">
            <summary>
            If there're multiple equal items in the list (must be contiguous in a sorted list), take the highest-index one for a hit.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream">
            <summary>
            Wraps a sequential stream with a view which supports seek operations. For that, it has to keep a copy of already-passed bytes, even if you skip them when seeking, so use only when needed (like, when you want to analyze a header of a sequential stream with a reader which requires seeking).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.#ctor(System.IO.Stream,System.Nullable{System.Int64})">
            <summary>
            </summary>
            <param name="sequentialstream">The stream to be wrapped. At this point, will be wrapped even if seekable.</param>
            <param name="customlength">If the <see cref="P:System.IO.Stream.Length"/> property of the underlying stream is irrelevant (which might be a case with a sequential stream), you must provide its value by some external knowledge, otherwise the seekable APIs might not be able to operate. Leave empty to use from the underlying stream.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.PumpIntoCache(System.Int32@)">
            <summary>
            Ensures we can read <paramref name="count"/> bytes from the current <see cref="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Position"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.CollectionSource`1">
            <summary>
              <para>A value type which implements a set of <see cref="T:System.Collections.Generic.ICollection`1"/>-like accessors. The collection interface itself is not implemented to avoid accidental boxing.</para>
              <para>This can be used to represents a specialized view on a larger collection or a data source, or a result of dynamic calculation, which does not allocate memory per-instance.</para>
              <para>The <see cref="T:JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner`1"/> serves as a common backend for a set of such collections (or even is a singleton), while the reference-type and value-type parameters in the collection source instance allow to define the context to make the collection source owner serve a specific collection.</para>
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.DataPod">
            <summary>
            POD data member.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.DataRefX">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSource`1.FromCollection(System.Collections.Generic.ICollection{`0})">
            <summary>
            Wraps an actual collection object with a collection source.
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.Enumerator.DataPod">
            <summary>
            POD data member.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.Enumerator.DataRefX">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.Enumerator.DataRefY">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSourceEx.AsCollectionSource``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Wraps an actual collection object with a collection source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSourceEx.AsEnumCollectionSource``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps an enumerable with a collection source so that it's not committed to a collection but enumerated anew on each request.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.CollectionSourcePodData">
            <summary>
            An empty placeholder which allocates memory for POD data of collection source owners.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.RealCollectionSourceOwner`1">
            <summary>
            Wraps a real collection into a collection source.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.StringSource">
            <summary>
              <para>Represents a string which has not yet been calculated as a runtime string object.</para>
              <para>Allows for most string-related operations without allocation of a real runtime string.</para>
              <para>Like with <c>HSTRING</c></para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.StringSource.Empty">
            <summary>
              <para>Gets a source for an empty string.</para>
              <para>This is equivalent to a NULL value for this structure.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.StringSource.DataPod">
            <summary>
            POD data member.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.StringSource.DataRefX">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.AsManagedStringSource">
            <summary>
              <para>Returns a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource"/> which is guaranteed to be hosted in the managed memory, i.e. its lifetime won't terminate.</para>
              <para>Required if you plan on using the string longer than the lifetime it's been produced under.</para>
              <para>Native strings will be rendered as runtime strings. Non-native strings, e.g. strings or substrings, will be returned AS IS.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.Fixed``2(``0,JetBrains.Util.dataStructures.Sources.StringSourceFixedDelegate{``0,``1})">
            <summary>
              <para>Processes a string as a fixed pointer to the char array.</para>
              <para>This char array MIGHT NOT be zero-terminated!!</para>
              <para>It MUST NOT be modified.</para>
              <para>It might be a subrange of some other runtime string object, or a pointer to a native memory area, or some stack/reusable buffer.</para>
            </summary>
            <typeparam name="TContext">A user-defined context which allows to use non-closure lambdas.</typeparam>
            <typeparam name="TResult">Processing result.</typeparam>
            <param name="context">A user-defined context which allows to use non-closure lambdas.</param>
            <param name="λ"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.ToRuntimeString">
            <summary>
              <para>Renders the runtime string object for this string source.</para>
              <para>This specific operation is what a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource"/> tries to avoid by providing a string-like API to some non-allocating object.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.Sources.StringSource.IsEmpty">
            <summary>
            Gets whether the string is empty.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.SubStream">
            <summary>
            Sometimes we have to trick some feature into thinking that it works on its own stream, while actually it gets only a substream from some other larger stream (or file).
            An example would be features like ZIP which would seek into beginning and the end.
            Another case is appending to a larger stream, while some features would like to rewind first.
            And it also won't dispose the underlying stream on close.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.SubStream.#ctor(System.IO.Stream,System.Int64,System.Nullable{System.Int64},System.IO.FileAccess)">
            <summary>
            </summary>
            <param name="stream">The underlying stream. Won't be disposed of!</param>
            <param name="start">Start of the view.</param>
            <param name="length">Length of the view. A nonnegative number means a fixed length, and <c>NULL</c> means “to the current end of the underlying stream”, and it allows growing the stream on write.</param>
            <param name="rwfilter">Allows to limit operations on the underlying stream.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.SubStream.Append(System.IO.Stream)">
            <summary>
            Creates a substream for appending to the end of another stream.
            Writable, growable, asserts at end.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.UncloseableStream">
            <summary>
            Wraps a <see cref="T:System.IO.Stream"/> instance and does not the consumer of this class to close that instance.
            </summary>
        </member>
        <member name="T:JetBrains.Util.StringSlicesEnumerable">
            <summary>
            Enumerates substrings of the <see cref="T:System.String"/> value using one or many delimiters.
            Does not produce any new <see cref="T:System.String"/> or other reference type object.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StringSlicesEnumerable.mySource">
            <summary>
            The source string to be delimited with <see cref="F:JetBrains.Util.StringSlicesEnumerable.mySeparator"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StringSlicesEnumerable.mySeparator">
            <summary>
            The unicode character that delimit the substrings of <see cref="F:JetBrains.Util.StringSlicesEnumerable.mySource"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.#ctor(System.String,System.Char,System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separator"/>.</param>
            <param name="separator">A unicode character that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.#ctor(System.String,System.Char[],System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separators"/>.</param>
            <param name="separators">A unicode characters that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.IndexOf(System.String,System.StringComparison)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified substring in source string.
            </summary>
            <param name="substringToSeek">The substring to seek.</param>
            <param name="comparison">One of the enumeration values that specifies the rules for the search.</param>
            <returns>The zero-based index number of <paramref name="substringToSeek"/> if that substring is found, or -1 if it is not. 
            If value is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the substring of source string.
            </summary>
            <returns>
            A <see cref="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator"/> that can be used to iterate through the substrings of source string.
            </returns>
        </member>
        <member name="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator">
            <summary>
            Iterates through the substing of the source string delimited by specified character.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator.#ctor(System.String,System.Char,System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separator"/>.</param>
            <param name="separator">A unicode character that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator.#ctor(System.String,System.Char[],System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separators"/>.</param>
            <param name="separators">A unicode characters that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.FileSystemInteraction.DeleteDirectoryNonRecursive(JetBrains.Util.FileSystemPath,System.Int32,System.Exception@)">
            <summary>
            Attempts to delete the directory object without recursing inside.
            Might return an exception in <paramref name="ex" /> instead of throwing out, so that in cases where we expect regular failures (like with deleting recursive folders) it were not causing too many exceptions.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DirectoryEntryData">
            <summary>
            Data object for the advanced <c>GetChild*</c> methods family on a file system path.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.BaseDir">
            <summary>
            The base dir for <see cref="F:JetBrains.Util.DirectoryEntryData.RelativePath"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.RelativePath">
            <summary>
            Path of this item, relative to <see cref="F:JetBrains.Util.DirectoryEntryData.BaseDir"/>. Will only have more than one component if recursive.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.FileModificationTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.FileCreationTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.FileAccessTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.Attributes">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.Length">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DirectoryEntryData.GetAbsolutePath">
            <summary>
            Concats into the abs path.
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.DirectoryEntryData.Existence">
            <summary>
            Tells files from dirs, if you're enumerating for both.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ILogger">
            <summary>
            Interface to the logger which can be passed to subsystems to replace the default logger in them.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FilesInUse">
            <summary>
            Helps getting info on who's locking the files-in-use which cannot be opened, moved, or deleted.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FilesInUse.QueryFilesInUse(JetBrains.Util.FileSystemPath[])">
            <summary>
            Tries to get the info on who's locking the files.
            </summary>
            <param name="files"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Reflection.AssemblyNameInfoParseException">
            <summary>
            <para>A distinct exception type for assembly name parse errors.</para>
            <para>Catch <see cref="T:System.ArgumentException"/> to trap all of the <see cref="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(System.String)"/> cases.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PublicKeyToken">
            <summary>
            Wraps the Public Key Token value for the assembly identity.
            Possible values:
            (1) A valid 64-bit token is assigned.
            (2) A NULL value is explicitly assigned (results in <c>PublicKeyToken=null</c> or <c>=neutral</c> in the identity string).
            (3) No value assigned (runtime tells this apart from the NULL case, and no <c>PublicKeyToken=null</c> string is added to the textual identity string in this case).
            Holds these states, and allows to get/set the token as a byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PublicKeyToken.myExtra">
            <summary>
            <c>NULL</c> value =&gt; no token has been set on this object (neither NULL or value).
            <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myExtra_NullOrNeutral"/> value =&gt; either NULL or Neutral has been set as the token.
            <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myExtra_Deferred"/> =&gt; the token has been set, <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myValue"/> has the value, the array hasn't been computed yet.
            Otherwise, a byte[], the token has been set, <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myValue"/> has the value, and this is its array version.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PublicKeyToken.myValue">
            <summary>
            The value, unless it's NotSet or NULL or Neutral.
            Otherwise, must be zero.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PublicKeyToken.Parse(System.String)">
            <summary>
            Parses the token value text, just like the value of the PublikKeyToken attribute in this assembly textual identity string.
            Throws an argument exception on error.
            </summary>
            <exception cref="T:System.ArgumentException">Parse error.</exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PublicKeyToken.TryParse(System.String)">
            <summary>
            Parses the token value text, just like the value of the PublikKeyToken attribute in this assembly textual identity string.
            Silently returns <see cref="P:JetBrains.Metadata.Utils.PublicKeyToken.NotSet"/> on a parse error.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PublicKeyToken.TryParseCore(System.String,JetBrains.Util.OnError)">
            <summary>
            Parses the token value text, just like the value of the PublikKeyToken attribute in this assembly textual identity string.
            Throws an argument exception on error.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection`1.Create(System.String)">
            <summary>
            Creates a new item filed under the given unique name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection`1.TryGetItem(System.String)">
            <summary>
            Gets an existing item by its name, or <c>Null</c> if there is no item with such a name.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.StructuredStorage.IStructuredStorageCollection`1.Item(System.String)">
            <summary>
            Gets an existing item by its name.
            Throws an exception if the item is missing.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple">
            <summary>
            A Structured Storage implementation for fast in-memory operations in the "write once, read many" fashion.
            The format is NOT compatible with any standard readers.
            Not all possible operations are implemented.
            The supported operations are: write a newly-created stream (hence, one at a time); read an existing stream (any number). Others might be suboptimal or unavailable.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage">
            <summary>
              <para>Means for storing hierarchical data within a single object, similar to COM Structured Storage.</para>
              <para>Semantially, a storage is like a folder, and a stream is like a file.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.INamedItem">
            <summary>
            A common basic interface for accessing items with a name.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.StructuredStorage.INamedItem.Name">
            <summary>
            The item name.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Storages">
            <summary>
            Child storages, just like subfolders.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage.Streams">
            <summary>
            Streams of this storage, just like child files in a folder.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord">
            <summary>
            Represents a filesystem tree node for either a storage or a stream (see <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.ContentLength"/> to tell).
            The record length in <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.SizeOfRecord"/> does not include the last <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.wsz"/> field, because it's just a marker.
            Immediately follwed by the node name (would have a zero char, even if empty), <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.SizeOfRecord"/> from the record RVA.
            After that comes the content bytes, <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.ContentLength"/> long unless it's <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.StgContentLengthValue"/>, at Record RVA + <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.SizeOfRecord"/> bytes + (<see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.CchName"/> + 1 zero-terminator) chars (!).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.StgContentLengthValue">
            <summary>
            The special value in the <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.ContentLength"/> field if the node represents a storage rather than a stream. Note that there can be a storage without any children, yet existing.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.RvaParent">
            <summary>
            RVA to the parent.
            Can be NULL on the root storage, or if the node has been deleted from the tree (=unlinked).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.RvaPrevSibling">
            <summary>
            Prev sibling, or NULL for the first child or a node without a parent.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.RvaNextSibling">
            <summary>
            Next sibling, or NULL for the first child or a node without a parent.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.RvaFirstChild">
            <summary>
            First child, or NULL if it's a stream, or a storage with zero children.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.RvaLastChild">
            <summary>
            Last child, or NULL if it's a stream, or a storage with zero children.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.ContentLength">
            <summary>
            For a stream node, the content length of that stream.
            For a storage node, the special <see cref="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.StgContentLengthValue"/> value.
            That's how we tell them.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.CchName">
            <summary>
            Length of the string, in chars, not including the terminating zero (which must also be written).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.BankSwitchingStructuredStorageSimple.NodeRecord.wsz">
            <summary>
            Not in the structure! Just marks the beginning of the string, UTF-16LE, zero-terminated (ready for use in the runtime).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage">
            <summary>
            Implements a Structured Storage over ZIP file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.EscapeRules">
            <summary>
            ASCII range, XML-safe and printable-safe and filename-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.CreateOnStream(JetBrains.DataFlow.Lifetime,System.IO.Stream)">
            <summary>
            Creates a new OPC structured storage in a stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.OpenStream(System.IO.Stream,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Opens the stream for reading an OPC storage in it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.OpenStream(JetBrains.DataFlow.Lifetime,System.IO.Stream)">
            <summary>
            Opens the stream for reading a ZIP storage in it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.OpenStream``1(System.IO.Stream,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,``0})">
            <summary>
            Opens the stream for reading an OPC storage in it.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.TreeLeaf.CacheStream">
            <summary>
            When writing new content, gets kept here until we commit to the ZIP.
            For if we do a full commit after each write, it gets to rebuild the whole ZIP on each iteration, and feels O(n2) on writes.
            And if we submit it to ZIP and do not commit, it won't return the newly-submitted streams when opening entries. So we got to keep them in own cache for a while.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.TreeLeaf.ZipEntry">
            <summary>
            The originating ZIP entry of this stream, if created over an unmodified stream from the loaded storage.
            Keeps the index (for fast reading) and the entry transport name. When opening by entry, only uses the index when it still matches the name, ie is a safe bet.
            For modified or newly-created entries, we keep their streams until we are ready to commit the archive, so this will be NULL.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ZipStructuredStorage.TreeNode.ZipEntry">
            <summary>
            Set to an entry if this node has been created from a real zip directory entry, or to NULL if it's been created because some child entry exists for a dir/file.
            Used to delete the entry.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.Low">
            <summary>
            Lowest level for background task.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.BelowNormal">
            <summary>
            Low level for non-urgent tasks.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.Normal">
            <summary>
            Most common priority in system. Used in <see cref="T:JetBrains.Application.Threading.Tasks.TaskBarrier"/>. When you don't need fast response, use this activity.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal">
            <summary>
            Intermediate level. Until this priority (inclusively) tasks are executed synchronously in Unit Tests.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.High">
            <summary>
            For urgent tasks. Starting with this priority tasks are executed asynchronously (if not invoked with RunSynchronously()) in Unit Tests.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.Realtime">
            <summary>
            Highest priority
            </summary>
        </member>
        <member name="T:JetBrains.Util.JetFileSystemWatcher">
            <summary>
            Better managed API for watching file system changes
            </summary>
        </member>
        <member name="T:JetBrains.Util.Formats.AsmConfigFile.AssemblyBindingRedirections">
            <summary>
            Produces the default assembly binding redirections for a product assembly.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Formats.AsmConfigFile.Attr">
            <summary>
            Attribute names.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Formats.AsmConfigFile.Elem">
            <summary>
            Element names.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Formats.AsmConfigFile.Nsp">
            <summary>
            Namespace aliases.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Formats.AsmConfigFile.Xmlns">
            <summary>
            XML Namespaces.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.AnonymousLogger">
            <summary>
            An anonymous delegate-based implementation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.DataFlow.Lifetime,JetBrains.Util.LoggingLevel,System.String)">
            <summary>
            Logs the same message twice, with “Opening” and “Closing” prefix, when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="level"></param>
            <param name="message"></param>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.DataFlow.Lifetime,JetBrains.Util.LoggingLevel,System.String,System.Object[])">
            <summary>
            Logs the same message twice, with “Opening” and “Closing” prefix, when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="level"></param>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.DataFlow.Lifetime,JetBrains.Util.LoggingLevel,JetBrains.Util.Pair{System.String,System.String})">
            <summary>
            Logs a pair of messages (no prefix added) when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.Util.LoggingLevel,System.String,System.Object[])">
            <summary>
            Logs the same message twice, with “Opening” and “Closing” prefix, when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="level"></param>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogExceptionSilently(JetBrains.Util.ILogger,System.Exception)">
            <summary>
            Logs the exception without notifying the registered listeners about it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch(JetBrains.Util.ILogger,System.Action,JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch(JetBrains.Util.ILogger,System.Action,JetBrains.Util.ExceptionOrigin,JetBrains.Util.LoggingLevel)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch``1(JetBrains.Util.ILogger,System.Func{``0},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch``1(JetBrains.Util.ILogger,System.Func{``0},JetBrains.Util.ExceptionOrigin,JetBrains.Util.LoggingLevel)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchNullable``1(JetBrains.Util.ILogger,System.Func{``0},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchSilent(JetBrains.Util.ILogger,System.Action)">
            <summary>
            Executes the <paramref name="action" />. Catches all of the exceptions, suppresses them (logs silently), and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchSilent``1(JetBrains.Util.ILogger,System.Func{``0})">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchIgnore(JetBrains.Util.ILogger,System.Action)">
            <summary>
            Executes the <paramref name="action" />. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchIgnore``1(JetBrains.Util.ILogger,System.Func{``0})">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.DropException(JetBrains.Util.ILogger,System.Exception)">
            <summary>
            Drops the exception by doing nothing with it, not even logging it silently (unlike <see cref="M:JetBrains.Util.ILoggerEx.LogExceptionSilently(JetBrains.Util.ILogger,System.Exception)"/>).
            Use it to:
            (1) Stub catch-alls to avoid "empty general catch clause" warnings.
            (2) Explicitly mark such exception-hiding places for the later reviewing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.Byte*,System.UInt32,System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.Byte*,System.UInt32,JetBrains.Util.Maths.OWORD)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x64(System.Byte*,System.UInt32,System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
            <remarks>
            Speed estimation data.
            AMD64 native process:
                 128bit hash x64 version — 1x
                 128bit hash x86 version — 0.5x
                 32bit  hash             — 0.5x
            AND64 WoW6432 process:
                 128bit hash x64 version — 0.1x
                 128bit hash x86 version — 0.3x
                 32bit  hash             — 0.5x
            If you have WoW as an option, would better use the x86 version.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x64(System.Byte*,System.UInt32,JetBrains.Util.Maths.OWORD)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
            <remarks>
            Speed estimation data.
            AMD64 native process:
                 128bit hash x64 version — 1x
                 128bit hash x86 version — 0.5x
                 32bit  hash             — 0.5x
            AND64 WoW6432 process:
                 128bit hash x64 version — 0.1x
                 128bit hash x86 version — 0.3x
                 32bit  hash             — 0.5x
            If you have WoW as an option, would better use the x86 version.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.String)">
            <summary>
            Murmur Hash, which is a public domain algorithm. String helper.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3(System.String)">
            <summary>
            Murmur Hash, which is a public domain algorithm. String helper.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_Parts(System.Byte*,System.Int32,System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Murmur Hash, which is a public domain algorithm.
            This version works on a buffer split into two parts.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3(System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Murmur Hash v3, which is a public domain algorithm.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Maths.OWORD">
            <summary>
            Wrapper for unsigned 218 bit integers.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AppDomainAssembliesResolver.AssemblyByIdentity">
            <summary>
            Cache assemblies by their shortname and Major.Minor version.
            3rd/4th version numbers are insignificant in our standard versioning policy (they're binary compatible, and there shouldn't be running more than one at a time).
            Major.Minor should probably be respected in case we might want to run more than one product with quite different versions of some assembly — resolver shouldn't mix them up.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AppDomainAssembliesResolver.Install(JetBrains.DataFlow.Lifetime)">
            <summary>
            Installs the current resolver instance into the appdomain's <see cref="E:System.AppDomain.AssemblyResolve"/> event.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.FAVOR_MAJOR_MINOR_DISTANCE">
            <summary>
            Favors the short assembly name and Major.Minor version components when comparing.
            TODO: what happens to culture, PK, etc?
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.AllPossibleExtensionsForModules">
            <summary>
            A list of the valid assembly file extensions.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameExtensions.ParseAssemblyName(System.String)">
            <summary>
            Safe method to parse assembly name without anexception.
            </summary>
            <param name="assemblyFullName"></param>
            <returns>Parsed <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo"/> if successful, null otherwise</returns>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameExtensions.DistanceAwareComparer">
            <summary>
            A comparer which calculates the distance between assembly names and applies a threshold.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.DistanceAwareComparer.DefaultFavorMajorMinorComparer">
            <summary>
            Favors the short assembly name and Major.Minor version components when comparing.
            TODO: what happens to culture, PK, etc?
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameExtensions.NameAndVersionComparer">
            <summary>
            Compares only the <see cref="P:JetBrains.Metadata.Utils.AssemblyNameInfo.Name">Simple Name</see> and <see cref="P:JetBrains.Metadata.Utils.AssemblyNameInfo.Version">Version</see> out of the assembly name fields.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameInfo">
            <summary>
            Managed-code class which incorporates assembly display name and it's parts.
            Use it instead of the <see cref="T:System.Reflection.AssemblyName"/> because AssemblyName
            relies on reflection and other unmanaged code to store and read name.
            Call <c>AssemblyNameReader::GetAssemblyName</c> to get AssemblyNameInfo of an assembly file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameInfo.myCulture">
            <summary>
            String representation of the culture.
            <c>NULL</c> means culture is not set.
            <see cref="F:JetBrains.Metadata.Utils.AssemblyNameInfo.CultureNeutral"/> means the culture is set to Neutral (in CLR or Invariant Culture, they have an empty string for a name).
            Any other value is the culture name.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameInfo.myProcessorArchitecture">
            <summary>
            The processor architecture. A value of <c>NULL</c> means that it has not been set (its text representation of “None” is not a valid value for the attribute text).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameInfo.myCustom">
            <summary>
            The Custom field.
            <c>NULL</c> means not set.
            <see cref="F:System.Reflection.Missing.Value"/> means explicitly set to “null”.
            A byte array value means the real custom data.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.#ctor(System.String)">
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.TryParse(System.String)">
            <summary>
              <para>A no-throw version of the <see cref="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(System.String)"/>.</para>
              <para>Parses the string as an assembly textual identity string, i.e. a full name of an assembly.</para>
              <para>Mostly same as the CLR <see cref="T:System.Reflection.AssemblyName"/> does with its .ctor, but in a more memory-efficient manner, and with caching.</para>
              <para>Matches very closely the Fusion/CLR parsing rules, and can handle most of the complicated escaping/formatting cases, according to the grammar.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(System.String)">
            <summary>
              <para>Parses the string as an assembly textual identity string, i.e. a full name of an assembly.</para>
              <para>Mostly same as the CLR <see cref="T:System.Reflection.AssemblyName"/> does with its .ctor, but in a more memory-efficient manner, and with caching.</para>
              <para>Matches very closely the Fusion/CLR parsing rules, and can handle most of the complicated escaping/formatting cases, according to the grammar.</para>
            </summary>
            <exception cref="T:System.ArgumentException">Any parse errors.</exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
              <para>Parses the string as an assembly textual identity string, i.e. a full name of an assembly.</para>
              <para>Mostly same as the CLR <see cref="T:System.Reflection.AssemblyName"/> does with its .ctor, but in a more memory-efficient manner, and with caching.</para>
              <para>Matches very closely the Fusion/CLR parsing rules, and can handle most of the complicated escaping/formatting cases, according to the grammar.</para>
            </summary>
            <exception cref="T:System.ArgumentException">Any parse errors.</exception>
        </member>
        <member name="P:JetBrains.Metadata.Utils.AssemblyNameInfo.IsStrongName">
            <summary>
            True if the assembly identity has a strong name, ie. either a full public key or a token.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.AssemblyTextualIdentityParser">
            <summary>
            Expected format, as defined in coreclr: <c>simple name (, attr = value)*</c>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeString(System.String,System.Text.StringBuilder)">
            <summary>
            Escapes a string against the textual identity parser rules, so that it were lexed back as a string if encountered as the simple name, attribute or a value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parse(System.String,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parsed@)">
            <summary>
            Parses an assembly textual identity string (aka FullName) from a runtime string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parse(JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parsed@)">
            <summary>
            Parses an assembly textual identity string (aka FullName) from a string source, which can be a substring or a native memory range or whatever else. Only fixes the string once, so it's OK to do encoding translation on-the-fly. Resulting substrings will be subranges into this same string source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parse(System.Char*,System.UInt32,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks,JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parsed@)">
            <summary>
            Parses the fixed string.
            Wrap into a native string source if want to call from outside.
            This method is kept for perf to do a fixed() operator on the runtime string rather than going thru string source's Fixed operation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.TrimTrailingWhitespace(System.Char*,System.Char*,System.Boolean)">
            <summary>
            Trailing wsp handling (wsp lexes into a string, but not if it's at the end of an unquoted string).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode.ClrDefault">
            <summary>
            Gets the default value used by the CLR version of the parser (as in <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.ParserState.BeforeOptionalAttr">
            <summary>
            Before either an attribute value (,x=y), or EOF.
            After either the simple name or another attribute value.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.PreprocessorCharHandling.BacktrackInput">
            <summary>
            Backtracking: use the same char on the next step.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks.AllowUnterminatedQuotedStrings">
            <summary>
            EOF terminates an unterminated quoted string with CLR AssemblyName std parsing. Turns on this mode.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks.AllowShorterVersionNumbers">
            <summary>
            If a version number has less than four components, subst missing ones with FFFFh.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks.ClrDefault">
            <summary>
            Gets the default value which provides better compatibility with the CLR version of the parser (as in <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.CodeDomAssemblyReferences">
            <summary>
            A helper class for tracking which assembly references might be involved within a CodeDOM session.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.CodeDomEx.MakeTypeReference(System.String,JetBrains.Util.Reflection.CodeDomAssemblyReferences,JetBrains.Metadata.Utils.AssemblyNameInfo[])">
            <summary>
            Correctly creates the code type reference.
            Use other overloads whenever possible, resort to this only if the type cannot be represented as <see cref="T:System.Type"/> or <c>PartCatalogType</c>.
            </summary>
            <param name="sFullyQualifiedName">FQN of the type (no assembly qualification).</param>
            <param name="refs">Tracks assembly references usage.</param>
            <param name="referencedassembly">If you know the originating assembly, track its usage.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Reflection.CodeDomEx.WriteCodeToFile(System.CodeDom.CodeCompileUnit,JetBrains.Util.FileSystemPath)">
            <summary>
            Writes code in any case, even if it is the same (touches the file date, used in normal build that looks at input/output dates).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Serialization.CsexpArchive">
            <summary>
            Like an MFC Archive, handles read and write operations with the same API.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Serialization.CsexpReader.BuffersCbSize">
            <summary>
            For reuse when we need max buf size, allows to avoid field reads.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.GetCurrentStringTokenCbSize">
            <summary>
            If the current <see cref="P:JetBrains.Util.Serialization.CsexpReader.TokenKind"/> is a <see cref="F:JetBrains.Util.Serialization.CsexpTokenKind.String"/>, gets its length, in bytes.
            Otherwise, throws.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadBufferValue">
            <summary>
            Allocates a new buffer to read the value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadBufferValue(System.Byte[],System.UInt32)">
            <summary>
            Reads the value of the current string token into a user-supplied buffer.
            Returns the number of bytes actually copied. The buffer must be large enough to fit the <see cref="M:JetBrains.Util.Serialization.CsexpReader.GetCurrentStringTokenCbSize"/> size.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadBufferValue(JetBrains.Util.PersistentMap.UnsafeWriter.Cookie)">
            <summary>
            Reads the value of the current string token into a user-supplied native memory buffer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadDecValue">
            <summary>
            Reads the current string value as an encoded unsigned decimal number.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadHexValue">
            <summary>
            Reads the current string value as an encoded hex number.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadStringValue(System.String)">
            <summary>
            Reads the value of the current String token as a managed string.
            </summary>
            <param name="assertThisValue">Optional. If defined, will check that it's equal to token, and throw an exception otherwise; no heap memory will be allocated unless the string is too large.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.Skip">
            <summary>
            Skips the current token to the next one. Returns the next state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.GetUnderlyingStreamPosition">
            <summary>
            Gets the current position of the input bytes stream (note: the underlying stream might be positioned elsewhere).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpReader.ReadByteSlow">
            <summary>
            Reads a single input byte in case of a precache miss.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpWriterEx.BeginWriteList(JetBrains.Util.Serialization.CsexpWriter)">
            <summary>
            Opens-cloes the nested list.
            To begin the use of this object, you must open the single toplevel list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpWriterEx.BeginWriteNamedList(JetBrains.Util.Serialization.CsexpWriter,System.String)">
            <summary>
            Opens-cloes the nested list.
            To begin the use of this object, you must open the single toplevel list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpWriterEx.WriteNameValue(JetBrains.Util.Serialization.CsexpWriter,System.String,System.String)">
            <summary>
            A helper which writes a nested list of two items, name and value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpWriterEx.WriteNameValue``1(JetBrains.Util.Serialization.CsexpWriter,System.String,``0)">
            <summary>
            A helper which writes a nested list of two items, name and value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpWriterEx.WriteValue``1(JetBrains.Util.Serialization.CsexpWriter,``0)">
            <summary>
            A helper which writes a string conversion of a typed value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Serialization.CsexpWriterEx.WriteDoubleTextValue(JetBrains.Util.Serialization.CsexpWriter,System.Double)">
            <summary>
            A helper which writes a double value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.IInMemoryStream.GetBufferFromPosition(System.Int64,System.IO.SeekOrigin,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="startPosition"></param>
            <param name="origin"></param>
            <param name="needBytes">Minimum byte count what we expect</param>
            <param name="avalableBytes">Avalable bytes. It is more or equal then needBytes</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Storage.IInMemoryStream.GetBufferEndAtPosition(System.Int64,System.IO.SeekOrigin,System.Int32,System.Int32@)">
            <summary>
            Return pointer to buffer
            Return value + <see cref="!:avalableBytes "/> points at <see cref="!:endOffset"/>
            </summary>
            <param name="endOffset"></param>
            <param name="origin"></param>
            <param name="needBytes">Minimum byte count what we expect</param>
            <param name="avalableBytes">Avalable bytes. It is more or equal then needBytes</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Storage.SimpleFileItem">
            <summary>
            Base class for artifacts representing a simple file. Can be realized onto disk by request, but does not have a “path” outside the step which requests it be written on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.#ctor(JetBrains.Util.RelativePath,JetBrains.Util.dataStructures.ChunkedMemoryStream)">
            <summary>
            Identity ctor.
            </summary>
            <param name="relativePath">
              <para>The file name of this file item. Might also be placed in a subfolder.</para>
              <para>Must not be an up-going relative path.</para>
            </param>
            <param name="fileContent">The byte content of the file. Must be an immutable stream, will be frozen by the ctor.</param>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.#ctor(JetBrains.Util.Storage.SimpleFileItem)">
            <summary>
            Clone ctor. Most useful for typed inheritors.
            </summary>
            <param name="sample"></param>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.#ctor(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Deserialiation ctor.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.AsAnotherPath(JetBrains.Util.RelativePath)">
            <summary>
            Returns a clone which shares the content stream, but uses a different file path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.AsAnotherPath(System.Func{JetBrains.Util.RelativePath,JetBrains.Util.RelativePath})">
            <summary>
            Returns a clone which shares the content stream, but uses a different file path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.ComputeHash(System.IO.Stream)">
            <summary>
            Exposes the function which is used for computing <see cref="P:JetBrains.Util.Storage.SimpleFileItem.ContentHash"/> over the file content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.CreateFromDisk(JetBrains.Util.FileSystemPath)">
            <summary>
              <para>Creates an in-memory file item from a physical disk file.</para>
              <para>When the read completes, the created file item has no connection with the disk file. The latter can be modified or deleted.</para>
            </summary>
            <param name="path">Path to the disk file to be read. Must exist as a file. Its local name will be used as the name of the file item.</param>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItem.CreateFromStream(JetBrains.Util.RelativePath,System.Action{System.IO.Stream})">
            <summary>
            Creates a new file by writing the content into a stream.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.SimpleFileItem.ContentHash">
            <summary>
            Lazily-computed file content hash, for quickly comparing file contents.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.SimpleFileItem.FileContent">
            <summary>
              <para>The byte content of the file. This stream is frozen, initially positioned at the beginning, and does not share its current position with other callers.</para>
            </summary>
            <remarks>A shallow clone is created for each caller. This means that (a) callers don't affect each other's stream positions, (b) there is a slight memory penalty for creating a small wrapper object on each call, and (c) the full contents of the underlying buffers are not cloned but reused immutably.</remarks>
        </member>
        <member name="P:JetBrains.Util.Storage.SimpleFileItem.RelativePath">
            <summary>
              <para>The file name of this file item. Might also be placed in a subfolder.</para>
              <para>Must not be an up-going relative path.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SimpleFileItemEx.RealizeOnDisk(JetBrains.Util.Storage.SimpleFileItem,JetBrains.DataFlow.Lifetime,JetBrains.Util.IWorkingDirectory)">
            <summary>
            Temporarily realizes the file item as a physical disk file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.SimpleFileItemEx.FileCheck.SkipContentHashCheck">
            <summary>
            Does not read the file content from disk to make sure its hash matches that of the in-memory copy.
            Not recommended for the real installation, but can be used to speed up in some simple cases like PWC pre-extraction.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage">
            <summary>
            Wraps a native COM storage with the managed <see cref="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Interop.WinApi.Declarations.Interfaces.IStorage,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.ImplementationFlags)">
            <summary>
            Wraps a native COM storage with the managed <see cref="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage"/> interface.
            </summary>
            <param name="lifetime">The lifetime to deterministically close all of the storages and streams.</param>
            <param name="storage">The native storage.</param>
            <param name="implflags">If this storage implementation requires name mangling.</param>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.#ctor(JetBrains.Util.RelativePath,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool)">
            <summary>
            Internal ctor for substorages.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.ComStructuredStorageStream.#ctor(JetBrains.Util.RelativePath,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenOrCreate)">
            <summary>
            The stream is only opened when calling Open, to avoid keeping the COM reference open for too long.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.ImplementationFlags.MangleLongNamesDownTo31">
            <summary>
            Docfile impl can't have names longer than 31, mangling and table lookup required.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.ImplementationFlags.NeverWriteNonemptyStreams">
            <summary>
            ITSS impl can't write nonempty streams. Have to be cloned if opened for writing.
            // TODO: actually, it's surfaced that ITSS can't actually seek for writing, not write to already-existing streams. Deal with that if such a case surfaces.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.ImplementationFlags.IsOpeningSubStoragesForWriting">
            <summary>
            Means substorages should be opened with <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.STGM.STGM_READWRITE"/> instead of <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.STGM.STGM_READ"/>.
            ITSS ignores these flags, but docfiles impl won't open child storages for writing under a readonly storage.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler">
            <summary>
            COM compound files only handle 31 chars of name length. Have to mangle anything that is longer than that.
            The full names will be stored in the property storage.
            Note that the character set is quite permissive, nearly no mangling is needed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler.MaxUnmangledLength">
            <summary>
            Technical limit is 31, but 31-long names will be an additional indication that they have been mangled
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler_PropertyPerName">
            <summary>
            The original impl.
            Looks up mangled names right in the property storage stream, writes each new mangling directly to the stream.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler_SingleList">
            <summary>
            Gen 2 impl. Stores the single name mangling list in the property storage stream.
            Reads the stream when first needed, saves (if modified) before closing the storage.
            Does the lookups and modifications in an in-memory dictionary.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler_SingleList.myMapMangledToUnmangled">
            <summary>
            NULL until it's actually read from the persisted form, upon the first read/write call.
            Written when the lifetime ends.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler_SingleList.SerializedNamesSeparatorChar">
            <summary>
            A char which separates names in the mangled names table. Must not be valid for file names.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.NameMangler_SingleList.Serialize">
            <summary>
            Serializes the name mapping before closing the storage, in case there were any modifications.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStorageRecord.myOpenStorage">
            <summary>
            NULLed when closed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStorageRecord.myLocks">
            <summary>
            Ownership locks on this storage.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStorageRecord.CloseComObjectsCore">
            <summary>
            A separate func, to avoid capturing anything in a closure, fuck csc.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStorageRecord.Path">
            <summary>
            Path, starting from the root storage we've opened (not including it).
            </summary>
        </member>
        <member name="P:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStorageRecord.OpenStorage">
            <summary>
            The open physical storage object.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool">
            <summary>
            Pools opening the physical <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IStorage"/> objects. Does not keep them opened once and forever.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool.myOpenStorages">
            <summary>
            Sorted list of open storages.
            Topmost first, deeper go next.
            Usually only as large as substorages depth.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool.CollectGarbage">
            <summary>
            Close the storages which have no locks.
            They're kept open for some time to avoid re-opening the same storage with each next call.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool.OpenStorage(JetBrains.Util.RelativePath,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenOrCreateOrTryOpen)">
            <summary>
            Opens the storage. Does not add the lock (will be GCed when <see cref="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorage.OpenStoragesPool.CollectGarbage"/> is called or another storage is opened, so for onstack use only).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.CreateDiskFile(JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Creates a new empty storage on a disk file, and fills it with a user callback.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.CreateMemoryStream(JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Creates a new empty storage, fills it with a user callback, and returns it as a memory stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.CreateOnLockBytes(JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Creates a new empty storage on user-supplied COM resizable memory exposed as <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.CreateOnLockBytes(JetBrains.DataFlow.Lifetime,JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat)">
            <summary>
            Creates a new empty storage on user-supplied COM resizable memory exposed as <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes"/>, and fills it with a user callback.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.CreateOnStream(JetBrains.DataFlow.Lifetime,System.IO.Stream,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat)">
            <summary>
            Creates a new empty storage.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ModifyLockBytes(JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Opens an already-initialized storage in user-supplied COM resizable memory exposed as <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes"/>, and processes it with a user callback (for just reading and writing).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.OpenDiskFile``1(JetBrains.Util.FileSystemPath,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,``0})">
            <summary>
            Opens an already-initialized storage in a disk file, and processes it with a user callback (for just reading, or possibly modification).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.OpenLockBytes(JetBrains.DataFlow.Lifetime,JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.ReadWrite)">
            <summary>
            Opens an already-initialized storage in user-supplied COM resizable memory exposed as <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes"/>, and processes it with a user callback (for just reading, or possibly modification).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.OpenStream(JetBrains.DataFlow.Lifetime,System.IO.Stream,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat)">
            <summary>
            Opens an already-initialized storage in a stream of some sort (for just reading, or possibly modification).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ReadLockBytes``1(JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,``0})">
            <summary>
            Opens an already-initialized storage in user-supplied COM resizable memory exposed as <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes"/>, and processes it with a user callback (for just reading).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ReadStream``1(System.IO.Stream,JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,``0})">
            <summary>
            Opens an already-initialized storage in a stream of some sort, and processes it with a user callback (for just reading, or possibly modification).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat.ComCompoundFile">
            <summary>
            System-implemented, no compression, 31-char names only.
            Typical DOC, MSI, XLS, younameit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.ComStructuredStorages.ComStorageFormat.InfoTechStorage">
            <summary>
            InfoTech storage implementation from IE4, long filenames, decent compression.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.DiskFolderStructuredStorage">
            <summary>
            Represents a disk folder as a structured storage.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.IStructuredStorageEx.CopyTo(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Copies the contents of one storage into another.
            Note that a clone of <paramref name="thіs" /> itself is not added under <paramref name="dest" />, just the clones of its child storages/streams.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage">
            <summary>
            Implements a Structured Storage over the OPC Package, such as a ZIP file package.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.CreateMemoryStream(System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Creates a new OPC structured storage, writes it into a memory stream, and returns that stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.CreateOnStream(JetBrains.DataFlow.Lifetime,System.IO.Stream)">
            <summary>
            Creates a new OPC structured storage in a stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.OpenStream(System.IO.Stream,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Opens the stream for reading an OPC storage in it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.OpenStream(JetBrains.DataFlow.Lifetime,System.IO.Stream)">
            <summary>
            Opens the stream for reading an OPC storage in it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.OpenStream``1(System.IO.Stream,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,``0})">
            <summary>
            Opens the stream for reading an OPC storage in it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.GetPartPath(System.IO.Packaging.PackagePart)">
            <summary>
            Use this method for getting the relative path for the part. Don't use <see cref="P:System.IO.Packaging.PackagePart.Uri"/> directly.
            </summary>
            <param name="part"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.GetPartUri(JetBrains.Util.RelativePath)">
            <summary>
            The inverse to <see cref="M:JetBrains.Util.Storage.StructuredStorage.PackageStructuredStorage.GetPartPath(System.IO.Packaging.PackagePart)"/>. Serves turning the path into the URI correctly.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.RuntimeStructuredStorage">
            <summary>
            A set of runtime objects holding all the data, not backed with any media.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.ReadWrite">
            <summary>
            Compatible with <see cref="T:System.IO.FileAccess"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.StreamOpenFlags">
            <summary>
            The logical flags for opening streams, with all the options usually available in CreateFile.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.StreamOpenFlags.StreamOpenFlags.IsValidCombination(JetBrains.Util.OnError)">
            <summary>
            Checks if the flags are compatible.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.DefaultStorageFormat">
            <summary>
            The default for creating a new stream if the format is not explicitly specified.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.PublicFilesPreferredFormat">
            <summary>
            The preferred format for publicly-exposed files for which in-system performance is not as critical as readability with a wider set of tools.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.UniversalStorageExtension">
            <summary>
            For writing storage files in any of the supported formats, if we're not fixing its format but suppose autodetection.
            Use this rather than OPC, ITS, DOC etc.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.CreateMemoryStream(System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage},System.Nullable{JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format})">
            <summary>
            Creates a new structured storage, writes it into a memory stream, and returns that stream.
            The format specification is optional. If omitted, uses <see cref="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.DefaultStorageFormat"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.CreateOnStream(System.IO.Stream,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage},System.Nullable{JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format})">
            <summary>
            Creates a new structured storage, writes it into the given stream.
            The format specification is optional. If omitted, uses <see cref="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.DefaultStorageFormat"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.OpenStream``1(System.IO.Stream,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,``0},System.Nullable{JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format})">
            <summary>
            Opens a structured storage on an existing stream.
            The format specification is optional. If omitted, autodetects format by the stream header.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.OpenStream(System.IO.Stream,System.Action{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage},System.Nullable{JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format})">
            <summary>
            Opens a structured storage on an existing stream.
            The format specification is optional. If omitted, autodetects format by the stream header.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.OpenStream(JetBrains.DataFlow.Lifetime,System.IO.Stream,JetBrains.Util.OnError,System.Nullable{JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format})">
            <summary>
            Opens a structured storage on an existing stream.
            </summary>
            <param name="lifetime">Lifetime for using the storage object.</param>
            <param name="stream"></param>
            <param name="onerror"></param>
            <param name="formatIfKnown">Supports autodetection of the format by the storage header, but also allows to specify it manually.</param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format.OpenPackagingConventions">
            <summary>
            ECMA-376 OpenXML, 1st Edition, Part 2: Open Packaging Conventions (OPC). Based on ZIP.
            The format of the new docx, xlsx, xps, vsix, nuget, etc files. A successor for COM Compound Files.
            Uses the managed implementation from <see cref="T:System.IO.Packaging.ZipPackage"/>, which has some impact due to the intermediate data storages in .NET Isolated Storage. A native implementation is available, but it requires newer Windows systems and is thus not used.
            Viewer: any ZIP viewer.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format.ComCompoundFiles">
            <summary>
            The classical implementation of the COM Structured Storage, the COM Compound Files binary format, aka DocFile format.
            The format of the doc, xls, msi, etc. Uses the Windows built-in COM implementation over <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IStorage"/>. Technically, does not support paths longer than 31 char in utf16, so external long names support has been layered over it.
            Viewer: FAR, or any other docfile viewer.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format.InfoTechStorageSystem">
            <summary>
            The InfoTech Storage System, as introduced with IE4 and used for CHM (compiled HTML help) and ITS file formats.
            Exposes the same COM Structured Storage <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IStorage"/> interface, supports long names internally and has decent compression.
            Viewer: FAR, or any other CHM file viewer like HelpwareFAR.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.StructuredStorage.StructuredStorages.Format.Zip">
            <summary>
            Plain zip file
            </summary>
        </member>
        <member name="T:JetBrains.Util.Storage.SubplatformPackageLayoutConstants">
            <summary>
            Defines some of the constants related to handling Nuget packages for subplatforms.
            Even though all of this functionality is NetFX4-specific and lives in higher assemblies, some of the constants must reside here to be shared.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetBrainsContentFilesFolder">
            <summary>
            Name of the folder within Nuget package files which we're to use for storing our generic content files by convention.
            This is not immediately visible to Nuget Core itself and prevents it from adding references to our DLLs from VS projects automatically. Instead, we'd add a custom .Targets file to manage what gets added and how.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetMetadataInApplicationPackageExt">
            <summary>
            Package part extension for the jet package metadata objects embedded into a subplatform package.
            The part contains a structured storage with a <c>SerializedValuesResolver</c> holding the components.
            The other half of the part local name is the package ID (no version included, for easier cleanup when extracting), and the folder is the main content folder.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.NugetLibFolder">
            <summary>
            The standard Nuget Lib folder name.
            <c>Constants::Lib</c> if we got a reference to Nuget.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.PackageEmptyFileName">
            <summary>
            Starting from nuget 2.0, use a file with the special name '_._' to represent an empty folder.
            <c>Constants::PackageEmptyFileName</c> if we got a reference to Nuget.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.SubplatformPlatformCoreShellPackageId">
            <summary>
            Name of the Nuget package which is the central/core package of the system, and is basically referenced by nearly every other package.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.IsPackageFileEffectivePathSuitableForManagedReference(JetBrains.Util.RelativePath)">
            <summary>
              <para>After content files are listed for the package (this means looking in the set folders, and stripping off their paths to make an effective path), checks whether this effective path look like this file could be used as a managed assembly or a managed assembly reference after it's installed.</para>
              <para>This allows to seamlessly skip content files shipped in subfolders if they're actually managed assemblies, for being inspected for cataloging etc.</para>
              <para>Also checks the file extension.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.TryGetJetEffectivePath(JetBrains.Util.RelativePath)">
            <summary>
            Gets the effective path of the embedded file in the package, by our convention, only from the <c>Lib</c> or <c>DotFiles</c> folders.
            If the package follows the DotFiles folder convention, cuts this folder name. Otherwise, takes what Nuget thinks to be the effective path of the file in the <c>Lib</c> folder.
            </summary>
            <returns>The effective path, and whether the file were within the Lib folder in our or Nuget-standard convention.</returns>
        </member>
        <member name="T:JetBrains.Text.IdentifierMatcher">
            <summary>
            Matches text by pattern using so called CamelHump. Not immutable, has internal state.
            !!! MUST BE used in singlethreaded fashion, because every processing method changes internal state.
            </summary>
        </member>
        <member name="P:JetBrains.Text.IdentifierMatcher.SharedMatchingIndices">
            <summary>
            Caution!!! Use it onsly for stream processing to reduce memory traffic or with defensive copying.
            This is shared stated and it will be changed after next <see cref="M:JetBrains.Text.IdentifierMatcher.Matches(System.String)"/> invocation. 
            </summary>
        </member>
        <member name="T:JetBrains.Text.IEditableBuffer">
            <summary>
            Interface for a buffer supporting efficient editing of content in arbitrary positions
            </summary>
        </member>
        <member name="T:JetBrains.Text.IBuffer">
            <summary>
            Buffer that allows retrieval of contents by position
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.ThinArrayBuffer.AssertOffsetAndLength(System.Int32,System.Int32)">
            <summary>
            Assertion method to avoid creating closure objects when no exceptions are thrown
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:JetBrains.Util.ThreadSafeAttribute">
            <summary>
            Indicates that this class/method is safe for multithreaded usage. If class marked with <see cref="T:JetBrains.Util.ImmutableAttribute"/> thread-safety is implicit. 
            If certain methods of class are thread-unsafe (e.g. iterators in synchronized dictionaries), you can annotate this methods with <see cref="T:JetBrains.Util.ThreadUnsafeAttribute"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.CacheStatistics">
            <summary>
            Internal helper class for cache statistics gathering. To collect statictics, compile with JET_MODE_STATISTICS #define.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateWeakCachedValue``2(System.Func{``0},JetBrains.Util.Caches.IWeakRefRetainerCache{``1},``0,System.Int32)">
            <summary>
            Creates wrapper that contains weak object inside. To prevent fast weakref eviction, newly created objects are placed into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>. Cache 
            is touched after each invocation of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>.
            If weak reference is evicted (that means object is evicted from cache too) and one invokes <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>, producer function is used 
            to create object.
            </summary>
            <typeparam name="T">object's type</typeparam>
            <typeparam name="TCacheItem">type of objects in cache, can be more general than <see cref="!:T"/></typeparam>
            <param name="producer">function that creates object</param>
            <param name="cache">cache that enlarges weakref lifetime</param>
            <param name="initialValue">Optional. If present, object is set to this value. Otherwise, object is set to null and will be initialized by producer after first use of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/></param>
            <param name="cacheTouchFrequency"></param>
            <returns>Newly created wrapper with weak reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateWeakParametrizedCachedValue``3(System.Func{``1,``0},JetBrains.Util.Caches.IWeakRefRetainerCache{``2},``0,System.Int32)">
            <summary>
            Creates wrapper that contains weak object inside. To prevent fast weakref eviction, newly created objects are placed into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>. Cache 
            is touched after each invocation of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>.
            If weak reference is evicted (that means object is evicted from cache too) and one invokes <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>, producer function is used 
            to create object.
            </summary>
            <typeparam name="T">object's type</typeparam>
            <typeparam name="TParam">producer parameter's type</typeparam>
            <typeparam name="TCacheItem">type of objects in cache, can be more general than <see cref="!:T"/></typeparam>
            <param name="producer">function that creates object</param>
            <param name="cache">cache that enlarges weakref lifetime</param>
            <param name="initialValue">Optional. If present, object is set to this value. Otherwise, object is set to null and will be initialized by producer after first use of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/></param>
            <param name="cacheTouchFrequency"></param>
            <returns>Newly created wrapper with weak reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateStrongCachedValue``1(``0)">
            <summary>
            Creates wrapper around object with hard reference.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="initialValue">Optional. Initial value of hard reference. Null by default.</param>
            <returns>Newly created wrapper with hard reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateStrongParametrizedCachedValue``2(``0)">
            <summary>
            Creates wrapper around object with hard reference.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TParam"></typeparam>
            <param name="initialValue">Optional. Initial value of hard reference. Null by default.</param>
            <returns>Newly created wrapper with hard reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.HasValue``1(JetBrains.Util.Caches.ICachedValueBase{``0})">
            <summary>
            Returns true if cached object has value "right now" (no need to invoke producer).
            </summary>
            <typeparam name="T">type of cached object</typeparam>
            <param name="cachedValue">object's wrapper</param>
            <returns>true if <see cref="M:JetBrains.Util.Caches.ICachedValueBase`1.TryGet"/> return true</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.SetIfNull``2(JetBrains.Util.Caches.ICachedValueBase{``0},System.Func{``1})">
            <summary>
            Sets value of object via functor only in case it's null (<see cref="M:JetBrains.Util.Caches.CachedValues.HasValue``1(JetBrains.Util.Caches.ICachedValueBase{``0})"/> returns false). This method is thread-safe.
            </summary>
            <typeparam name="T">type of cached object</typeparam>
            <typeparam name="TInheritor">type of functor - inheritor of object's type (to support functor's covariance) </typeparam>
            <param name="cachedValue">object's caching wrapper</param>
            <param name="functor">value producer, is invoked only when current value is null</param>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.SetIfNull``3(JetBrains.Util.Caches.ICachedValueBase{``0},System.Func{``1,``2},``1)">
            <summary>
            Sets value of object via functor only in case it's null (<see cref="M:JetBrains.Util.Caches.CachedValues.HasValue``1(JetBrains.Util.Caches.ICachedValueBase{``0})"/> returns false). This method is thread-safe.
            Functor is parametrized with additional parameter to avoid construction of closure (like it would have been with <see cref="M:JetBrains.Util.Caches.CachedValues.SetIfNull``2(JetBrains.Util.Caches.ICachedValueBase{``0},System.Func{``1})"/>)
            </summary>
            <typeparam name="T">type of cached object</typeparam>
            <typeparam name="TParam">functor's additional parameter type</typeparam>
            <typeparam name="TInheritor">type of functor - inheritor of object's type (to support functor's covariance) </typeparam>
            <param name="cachedValue">object's caching wrapper</param>
            <param name="functor">value producer, is invoked only when current value is null</param>
            <param name="param">functor's additional param</param>
        </member>
        <member name="T:JetBrains.Util.Caches.IExternalProviderCache`2">
            <summary> Usually cache gets provider (func : TKey - TValue) by constructor, but this interface contains methods that allow to specify arbitrary provider </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.ICachedBackend`2">
            <summary> Interface supports writing "through" cache (like CPU writes to RAM through its L1-L2-L3 cache) </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.ICacheBackendProvider`2">
            <summary> Usually the place from where provider takes values. Like RAM in CPU - Cache - RAM interop </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.DictionaryBasedCacheEx">
            
        </member>
        <member name="T:JetBrains.Util.ImmutableAttribute">
            <summary>
            Indicates that this class/property is immutable (you can't change its inner state with field assignments, setters, indexers, method calls an so on) an therefore safe for multithreaded usage.
            If certain methods of class are thread-unsafe (e.g. iterators in synchronized dictionaries), you can annotate this methods with <see cref="T:JetBrains.Util.ThreadUnsafeAttribute"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1">
            <summary>
            Cache that has sole purpose to increase the lifetime of weak reference. Used in pair with <see cref="T:JetBrains.Util.Caches.ICachedValue`1"/>.
            You MUST dispose it by lifetime or other way
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Touch(`0)">
            <summary>
            Notify this cache that item was accessed somehow. Cache can react to this event by relocating item is LRU queue, set last access time, increase use count, etc.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Remove(`0)">
            <summary>
            Remove item from cache
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Clear">
            <summary>
            Clear cache, remove all item.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Contains(`0)">
            <summary>
            Returns true if cache contains given item.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Evict">
            <summary>
            Manually starts eviction procedure. Cache could evict entities by its own rules, (e.g. evict all items with last access time more than 30 sec)
            </summary>
            <returns>Number of elements evicted</returns>
        </member>
        <member name="P:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Count">
            <summary>
            Returns current number of elements in cache
            </summary>
        </member>
        <member name="T:JetBrains.Util.ThreadUnsafeAttribute">
            <summary>
            Indicates that class/method requires additional external synchronization
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.CollectionUtilSafeOfTypeEnumerable`1">
            <summary>
            Implementation detail for <see cref="M:JetBrains.Util.CollectionUtil.SafeOfType``1(System.Collections.IEnumerable)"/>.
            Originally were known as a separate <c>SafeEnumerable</c> class, but then was turned into a LINQ-style method.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.CountingSet`1">
            <summary>
            Multiset, each element can be included into set multiple times. Internally implemented as Dictionary : [Element] -&gt; [Number of equal elements in this set]
            Each time we execute <see cref="M:JetBrains.Util.Collections.CountingSet`1.Add(`0)"/> counter for given element is increased. On <see cref="M:JetBrains.Util.Collections.CountingSet`1.Remove(`0)"/> counter is decreased (if it becomes zero, element is removed from set).
            You can check the number of element occurrences in this set by invoking <see cref="M:JetBrains.Util.Collections.CountingSet`1.GetCount(`0)"/>
            </summary>
            <typeparam name="T">Type of set's element</typeparam>
        </member>
        <member name="T:JetBrains.Util.Collections.EnumeratorExt">
            <summary>
            Class contains classic methods of <see cref="T:System.Collections.IEnumerable"/> for <see cref="T:System.Collections.IEnumerator"/>. One of purposes is to suport "struct enumerators" - all theese
            methods works with "struct enumerators" without allocating any object in the heap.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1">
            <summary>
            Fixed-size cache for clients which use <see cref="!:JetJetWeakReference&lt;T&gt;"/> to store values. Every time outer JetWeakReference accessed , client must invoke <see cref="M:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1.Touch(`0)"/> method.
            This promotes given value to the head of the LRU queue. If queue is full and promoting element is new (queue hasn't cointain it before), least recently used element
            is getting removed from the queue and number of hard links to this value is decreased by one. User can start timer thread that will evict entries with too old last 
            access time.
            WARNING!!! You MUST dispose this object, because it has reference on itself by Timer thread.
            </summary>
            <typeparam name="T">Object's type. <see cref="!:JetJetWeakReference&lt;T&gt;"/> lifetime is going to be increased by this cache</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1.#ctor(JetBrains.DataFlow.Lifetime,System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.Int64,System.Int32)">
            <summary>
            Creates new cache. Timer is started only when <see cref="!:invalidateTimeInMillis"/> is positive.
            </summary>
            <param name="lifetime">Lifetime of this cache</param>
            <param name="capacity">Maximum number of elements in cache</param>
            <param name="comparer">Optional.</param>
            <param name="invalidateTimeInMillis">Optional (default is zero). After given number of milliseconds, items in cache are concidered outdated and can be replaced
            either by timer thread or manual invocation of <see cref="M:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1.Evict"/> method</param>
            <param name="invalidationSurvivalThreshold"> Number of items that will survive eviction even if they are outdated</param>
        </member>
        <member name="T:JetBrains.Util.FrugalLocalHashSet`1">
            <summary>
            <para>A frugal version of a generic hash set.</para>
            <para>Properties:</para>
            <para>• Is a value type (non-POD though), thus merges into the memory of the owning type.</para>
            <para>• Stores first item within own memory.</para>
            <para>• Stores the remaining items, if any, in a hash set. If there aren't any more items, the hash set is not created.</para>  
            <typeparam name="T"></typeparam>
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.#ctor(JetBrains.Util.dataStructures.FrugalLocalList{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Frugal local list constructor.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.SetEquals(System.Collections.Generic.IJetSet{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.IsSupersetOf(System.Collections.Generic.ICollection{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.IsSupersetOf(System.Collections.Generic.IJetSet{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.JetHashSet`1.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:System.Collections.Generic.JetHashSet`1.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:System.Collections.Generic.JetHashSet`1.Entry.Element">
            <summary>
            Element of set
            </summary>
        </member>
        <member name="T:System.Collections.Generic.JetHashSetSorted`1">
            <summary>
            Makes sure you have quick hash-access to items and proper sorting order on items.
            This is fulfilled by maintaining an add-only regular hashset where all of the adds are in the correct order. This way the hashset operates right in the desired fashion.
            This wrapper only validates that there're no removes and all additions are properly sorted.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="F:System.Collections.Generic.JetHashSetSorted`1.myLastItem">
            <summary>
            Valid if <see cref="F:System.Collections.Generic.JetHashSetSorted`1.myHashSet"/> is nonempty.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.JetBinaryTree.NodeColor">
            <summary>
            A node in a red black tree can have one of the following two colors.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2">
            <summary>
            The JetBinaryTreeEnumerator class returns the keys or data objects of the treap in sorted order. 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.#ctor(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1},System.Boolean,JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
             Determine order, walk the tree and push the nodes onto the stack
            </summary>
             <param name="node"></param>
             <param name="ascending"></param>
             <param name="sentinelNode"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.InsertNewNode(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
            Use depth-first traversal to push nodes into stack the lowest node will be at the top of the stack.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.NextElement">
            <summary>
             Next element.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.HasMoreElements">
            <summary>
             Has more elements.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.MoveNext">
            <summary>
             Move next.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.Key">
            <summary>
             Key.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.Value">
            <summary>
             The data or value associated with the key.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeEnumerator`2.Node">
            <summary>
             The data or value associated with the key.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2">
            <summary>
            A single node that is encapsulated in a red black tree data structure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.#ctor">
            <summary>
            Creates an instance of this class.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.Color">
            <summary>
             Color - used to balance the tree.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.Left">
            <summary>
             Left node.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.Right">
            <summary>
             Right node.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.Parent">
            <summary>
            Parent node.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.Key">
            <summary>
             Key provided by the calling class.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode`2.Data">
            <summary>
             Data available in this node
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2">
            <summary>
             Red-black tree implementation. Not thread-safe
             Sorted map, can be used for imprecise search
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates an instance of this class.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Clear">
            <summary>
            Clears the tree.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.IsEmpty">
            <summary>
            Returns true if the tree is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.RemoveMin">
            <summary>
            Removes the node with the minimum key.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.RemoveMax">
            <summary>
            Removes the node with the maximum key.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetMinKey">
            <summary>
            Returns the minimum key value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetMaxKey">
            <summary>
            Returns the maximum key value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetMinValue">
            <summary>
            Returns the object having the minimum key value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetMaxValue">
            <summary>
            Returns the object having the maximum key.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetNode(`0)">
            <summary>
            Gets node for the specified key.
            WARNING: This is hackish. Use it only when you really need it and understand all side-effects.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetData(`0)">
            <summary>
            Gets the data object associated with the specified key.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.InplaceReplace(`0,`0,`1)">
            <summary>
             This method updates key and value for existing node.
             WARNING: It doesn't check that replaced key is in correct place! Use this method only if you are shifting keys and you're sure that this won't cause any corruption to the tree!
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Add(`0,`1)">
            <summary>
             Adds data to the tree.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.RotateLeft(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
             Rebalance the tree by rotating the nodes to the left.
            </summary>        
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.RotateRight(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
             Rebalance the tree by rotating the nodes to the right.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Remove(`0)">
            <summary>
            Removes the key and data object (delete).
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Nodes(System.Boolean)">
            <summary>
            Returns an enumerator that returns nodes in order.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Pairs(System.Boolean)">
            <summary>
            Returns an enumerator that returns the key-value pairs in order.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Keys(System.Boolean)">
            <summary>
            Returns keys in order as specified in parameter.
            </summary>
            <param name="ascending"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Values(System.Boolean)">
            <summary>
            Returns all the values in the tree in order as specifed in the parameter.
            </summary>
            <param name="ascending"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Elements(System.Boolean)">
            <summary>
            Returns an enumeration of the data objects in order as specifed in the parameter.
            </summary>
            <param name="ascending"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.RestoreAfterInsert(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
            RestoreAfterInsert
            Additions to red-black trees usually destroy the red-black 
            properties. Examine the tree and restore. Rotations are normally 
            required to restore it
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.RestoreAfterDelete(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
            Deletions from red-black trees may destroy the red-black 
            properties. Examine the tree and restore. Rotations are normally 
            required to restore it.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Delete(JetBrains.Util.Collections.JetBinaryTree.JetBinaryTreeNode{`0,`1})">
            <summary>
            Deletes a node from the tree and restores red black properties.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.System#ICloneable#Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.Collections.JetBinaryTree.JetBinaryTree`2.Size">
            <summary>
            The number of nodes contained in the tree.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.LocalLazy`1">
            <summary>
            <para>Provides support for several common patterns of lazy initialization, including the ability to initialize value types and to use null values.</para>
            <para>This is a frugal version of <see cref="T:System.Lazy`1"/> that does not create any objects until the lazy value is initialized to a reference type.</para>
            <para>Note that if you're passing a factory function and it's a closure, a new reference object is created for it per each instance. To avoid this, you can use <see cref="T:JetBrains.Util.Concurrency.LocalLazy`2"/>.</para>
            </summary>
            <typeparam name="TValue">Specifies the type of element being laziliy initialized.</typeparam>
        </member>
        <member name="F:JetBrains.Util.Concurrency.LocalLazy`1.myFlags">
            <summary>
            Mode and state data packed into a single int for less space.
            LazyExecutionMode values and Flag* fields.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.LocalLazy`2">
            <summary>
            <para>Provides support for several common patterns of lazy initialization, including the ability to initialize value types and to use null values.</para>
            <para>This is a frugal version of <see cref="T:System.Lazy`1"/> that does not create any objects until the lazy value is initialized to a reference type.</para>
            <para>The difference from <see cref="T:JetBrains.Util.Concurrency.LocalLazy`1"/> is that you don't have to create a new closure for the factory function with each call. Instead, you can pre-cache a function taking a parameter and pass the parameter into this struct separately. This way no reference types are created per instance until it's time to instantiate your object.</para>
            </summary>
            <typeparam name="TValue">Specifies the type of element being laziliy initialized.</typeparam>
            <typeparam name="TFactoryParameter">Type of the parameter passed to the factory function.</typeparam>
        </member>
        <member name="F:JetBrains.Util.Concurrency.LocalLazy`2.myFlags">
            <summary>
            Mode and state data packed into a single int for less space.
            LazyExecutionMode values and Flag* fields.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.CIELab">
            <summary>
            Represents L*a*b* color space
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.CIELab.Empty">
            <summary>
            Gets an empty CIELab structure.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.CIELab.L">
            <summary>
            Gets or sets L component (0..100).
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.CIELab.A">
            <summary>
            Gets or sets a component (-100..+100).
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.CIELab.B">
            <summary>
            Gets or sets a component  (-100..+100).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.CIEXYZ">
            <summary>
            Represents CIE XYZ color space
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.CIEXYZ.Empty">
            <summary>
            Gets an empty CIEXYZ structure.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.CIEXYZ.D65">
            <summary>
            Gets the CIE D65 (white) structure.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.CIEXYZ.X">
            <summary>
            Gets or sets X component.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.CIEXYZ.Y">
            <summary>
            Gets or sets Y component.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.CIEXYZ.Z">
            <summary>
            Gets or sets Z component.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.CMYK">
            <summary>
            Represents CMYK color space.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.CMYK.Empty">
            <summary>
            Gets an empty CMYK structure;
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.CMYK.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an instance of a CMYK structure.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.ColorSpace">
            <summary>
            Provides methods to convert from a color space to an other.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.GetColorDistance(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Gets the "distance" between two colors.
            RGB colors must be normalized (eg. values in [0.0, 1.0]).
            </summary>
            <param name="r1">First color red component.</param>
            <param name="g1">First color green component.</param>
            <param name="b1">First color blue component.</param>
            <param name="r2">Second color red component.</param>
            <param name="g2">Second color green component.</param>
            <param name="b2">Second color blue component.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.GetColorDistance(System.Double[],System.Double[])">
            <summary>
            Gets the "distance" between two colors.
            RGB colors must be normalized (eg. values in [0.0, 1.0]).
            </summary>
            <param name="color1">First color [r,g,b]</param>
            <param name="color2">Second color [r,g,b]</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.GetColorDistance(System.Windows.Media.Color,System.Windows.Media.Color)">
            <summary>
            Gets the "distance" between two colors.
            </summary>
            <param name="color1">First color.</param>
            <param name="color2">Second color.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.GetIntFromHex(System.String)">
            <summary>
            Gets the int equivalent for a hexadecimal value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HexToColor(System.String)">
            <summary>
            Converts a Hex color to a .net Color.
            </summary>
            <param name="hexColor">The desired hexadecimal color to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBToHex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts a RGB color format to an hexadecimal color.
            </summary>
            <param name="r">The Red value.</param>
            <param name="g">The Green value.</param>
            <param name="b">The Blue value.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBToHex(System.Windows.Media.Color)">
            <summary>
            Converts a RGB color format to an hexadecimal color.
            </summary>
            <param name="r">The color to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoRGB(JetBrains.Util.Colors.ColorSpaces.HSB)">
            <summary>
            Converts HSB to RGB.
            </summary>
            <param name="hsv">The HSB structure to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoRGB(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSB to RGB.
            </summary>
            <param name="H">Hue value.</param>
            <param name="S">Saturation value.</param>
            <param name="V">Brigthness value.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoColor(JetBrains.Util.Colors.ColorSpaces.HSB)">
            <summary>
            Converts HSB to Color.
            </summary>
            <param name="hsv">the HSB structure to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoColor(System.Double,System.Double,System.Double)">
            <summary> 
            Converts HSB to a .net Color.
            </summary>
            <param name="h">Hue value (must be between 0 and 360).</param>
            <param name="s">Saturation value (must be between 0 and 1).</param>
            <param name="b">Brightness value (must be between 0 and 1).</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoColor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts HSB to Color.
            </summary>
            <param name="h">Hue value.</param>
            <param name="s">Saturation value.</param>
            <param name="b">Brightness value.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoHSL(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSB to HSL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoCMYK(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSB to CMYK.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSBtoYUV(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSB to CMYK.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoRGB(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSL to RGB.
            </summary>
            <param name="h">Hue, must be in [0, 360].</param>
            <param name="s">Saturation, must be in [0, 1].</param>
            <param name="l">Luminance, must be in [0, 1].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoRGB(JetBrains.Util.Colors.ColorSpaces.HSL)">
            <summary>
            Converts HSL to RGB.
            </summary>
            <param name="hsl">The HSL structure to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoColor(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSL to .net Color.
            </summary>
            <param name="hsl">The HSL structure to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoColor(JetBrains.Util.Colors.ColorSpaces.HSL)">
            <summary>
            Converts HSL to .net Color.
            </summary>
            <param name="hsl">The HSL structure to convert.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoHSB(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSL to HSB.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoCMYK(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSL to CMYK.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.HSLtoYUV(System.Double,System.Double,System.Double)">
            <summary>
            Converts HSL to YUV.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoHSL(System.Int32,System.Int32,System.Int32)">
            <summary> 
            Converts RGB to HSL.
            </summary>
            <param name="red">Red value, must be in [0,255].</param>
            <param name="green">Green value, must be in [0,255].</param>
            <param name="blue">Blue value, must be in [0,255].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoHSL(JetBrains.Util.Colors.ColorSpaces.RGB)">
            <summary> 
            Converts RGB to HSL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoHSL(System.Windows.Media.Color)">
            <summary> 
            Converts Color to HSL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoHSB(System.Int32,System.Int32,System.Int32)">
            <summary> 
            Converts RGB to HSB.
            </summary> 
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoHSB(JetBrains.Util.Colors.ColorSpaces.RGB)">
            <summary> 
            Converts RGB to HSB.
            </summary> 
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoHSB(System.Windows.Media.Color)">
            <summary> 
            Converts RGB to HSB.
            </summary> 
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoCMYK(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts RGB to CMYK
            </summary>
            <param name="red">Red vaue must be in [0, 255].</param>
            <param name="green">Green vaue must be in [0, 255].</param>
            <param name="blue">Blue vaue must be in [0, 255].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoCMYK(System.Windows.Media.Color)">
            <summary>
            Converts RGB to CMYK
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoCMYK(JetBrains.Util.Colors.ColorSpaces.RGB)">
            <summary>
            Converts RGB to CMYK
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoYUV(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts RGB to YUV.
            </summary>
            <param name="red">red must be in [0, 255].</param>
            <param name="green">green must be in [0, 255].</param>
            <param name="blue">blue must be in [0, 255].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoYUV(System.Windows.Media.Color)">
            <summary>
            Converts RGB to YUV.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoYUV(JetBrains.Util.Colors.ColorSpaces.RGB)">
            <summary>
            Converts RGB to YUV.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoXYZ(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts RGB to CIE XYZ (CIE 1931 color space)
            </summary>
            <param name="red">Red must be in [0, 255].</param>
            <param name="green">Green must be in [0, 255].</param>
            <param name="blue">Blue must be in [0, 255].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoXYZ(JetBrains.Util.Colors.ColorSpaces.RGB)">
            <summary>
            Converts RGB to CIEXYZ.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoXYZ(System.Windows.Media.Color)">
            <summary>
            Converts RGB to CIEXYZ.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoLab(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts RGB to CIELab.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoLab(JetBrains.Util.Colors.ColorSpaces.RGB)">
            <summary>
            Converts RGB to CIELab.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.RGBtoLab(System.Windows.Media.Color)">
            <summary>
            Converts RGB to CIELab.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Converts CMYK to RGB.
            </summary>
            <param name="c">Cyan value (must be between 0 and 1).</param>
            <param name="m">Magenta value (must be between 0 and 1).</param>
            <param name="y">Yellow value (must be between 0 and 1).</param>
            <param name="k">Black value (must be between 0 and 1).</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoColor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Converts CMYK to RGB.
            </summary>
            <param name="c">Cyan value (must be between 0 and 1).</param>
            <param name="m">Magenta value (must be between 0 and 1).</param>
            <param name="y">Yellow value (must be between 0 and 1).</param>
            <param name="k">Black value (must be between 0 and 1).</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoColor(JetBrains.Util.Colors.ColorSpaces.CMYK)">
            <summary>
            Converts CMYK to RGB.
            </summary>
            <param name="cmyk"></param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoRGB(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Converts CMYK to RGB.
            </summary>
            <param name="c">Cyan value (must be between 0 and 1).</param>
            <param name="m">Magenta value (must be between 0 and 1).</param>
            <param name="y">Yellow value (must be between 0 and 1).</param>
            <param name="k">Black value (must be between 0 and 1).</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoRGB(JetBrains.Util.Colors.ColorSpaces.CMYK)">
            <summary>
            Converts CMYK to RGB.
            </summary>
            <param name="cmyk"></param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoHSL(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Converts CMYK to HSL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoHSB(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Converts CMYK to HSB.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.CMYKtoYUV(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Converts CMYK to YUV.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoRGB(System.Double,System.Double,System.Double)">
            <summary>
            Converts YUV to RGB.
            </summary>
            <param name="y">Y must be in [0, 1].</param>
            <param name="u">U must be in [-0.436, +0.436].</param>
            <param name="v">V must be in [-0.615, +0.615].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoRGB(JetBrains.Util.Colors.ColorSpaces.YUV)">
            <summary>
            Converts YUV to RGB.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoColor(System.Double,System.Double,System.Double)">
            <summary>
            Converts YUV to a .net Color.
            </summary>
            <param name="y">Y must be in [0, 1].</param>
            <param name="u">U must be in [-0.436, +0.436].</param>
            <param name="v">V must be in [-0.615, +0.615].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoColor(JetBrains.Util.Colors.ColorSpaces.YUV)">
            <summary>
            Converts YUV to a .net Color.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoHSL(System.Double,System.Double,System.Double)">
            <summary>
            Converts YUV to HSL.
            </summary>
            <param name="y">Y must be in [0, 1].</param>
            <param name="u">U must be in [-0.436, +0.436].</param>
            <param name="v">V must be in [-0.615, +0.615].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoHSB(System.Double,System.Double,System.Double)">
            <summary>
            Converts YUV to HSB.
            </summary>
            <param name="y">Y must be in [0, 1].</param>
            <param name="u">U must be in [-0.436, +0.436].</param>
            <param name="v">V must be in [-0.615, +0.615].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.YUVtoCMYK(System.Double,System.Double,System.Double)">
            <summary>
            Converts YUV to CMYK.
            </summary>
            <param name="y">Y must be in [0, 1].</param>
            <param name="u">U must be in [-0.436, +0.436].</param>
            <param name="v">V must be in [-0.615, +0.615].</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.XYZtoRGB(System.Double,System.Double,System.Double)">
            <summary>
            Converts CIEXYZ to RGB structure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.XYZtoRGB(JetBrains.Util.Colors.ColorSpaces.CIEXYZ)">
            <summary>
            Converts CIEXYZ to RGB structure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.Fxyz(System.Double)">
            <summary>
            XYZ to L*a*b* transformation function.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.XYZtoLab(System.Double,System.Double,System.Double)">
            <summary>
            Converts CIEXYZ to CIELab structure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.XYZtoLab(JetBrains.Util.Colors.ColorSpaces.CIEXYZ)">
            <summary>
            Converts CIEXYZ to CIELab structure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.LabtoXYZ(System.Double,System.Double,System.Double)">
            <summary>
            Converts CIELab to CIEXYZ.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.LabtoXYZ(JetBrains.Util.Colors.ColorSpaces.CIELab)">
            <summary>
            Converts CIELab to CIEXYZ.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.LabtoRGB(System.Double,System.Double,System.Double)">
            <summary>
            Converts CIELab to RGB.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.ColorSpace.LabtoRGB(JetBrains.Util.Colors.ColorSpaces.CIELab)">
            <summary>
            Converts CIELab to RGB.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.HSB">
            <summary>
            Structure to define HSB.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.HSB.Empty">
            <summary>
            Gets an empty HSB structure;
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.HSB.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates an instance of a HSB structure.
            </summary>
            <param name="h">Hue value.</param>
            <param name="s">Saturation value.</param>
            <param name="b">Brightness value.</param>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.HSB.Hue">
            <summary>
            Gets or sets the hue component.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.HSB.Saturation">
            <summary>
            Gets or sets saturation component.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.HSB.Brightness">
            <summary>
            Gets or sets the brightness component.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.HSL">
            <summary>
            Structure to define HSL.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.HSL.Empty">
            <summary>
            Gets an empty HSL structure;
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.HSL.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates an instance of a HSL structure.
            </summary>
            <param name="h">Hue value.</param>
            <param name="s">Saturation value.</param>
            <param name="l">Lightness value.</param>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.HSL.Hue">
            <summary>
            Gets or sets the hue component.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.HSL.Saturation">
            <summary>
            Gets or sets saturation component.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorSpaces.HSL.Luminance">
            <summary>
            Gets or sets the luminance component.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.RGB">
            <summary>
            Structure to define RGB.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.RGB.Empty">
            <summary>
            Gets an empty RGB structure;
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorSpaces.YUV">
            <summary>
            Structure to define YUV.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorSpaces.YUV.Empty">
            <summary>
            Gets an empty YUV structure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorSpaces.YUV.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates an instance of a YUV structure.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates">
            <summary>
            A signal-inheritor that exposes the signal's virtual methods as delegates.
            The signal has virtual methods instead of delegates because it's cheaper to call the virtual method, which is essential for the property case, for example. Less performance-critical scenarios (like collections) would use delegates instead of inheriting custom classes.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.SimpleSignal">
            <summary>
            A simple <see cref="T:JetBrains.DataFlow.ISignal`1"/> that has no payload.
            Stands for the simple <see cref="T:System.EventHandler"/>-based event, but encapsulates the firing method, can take part in data flow, can be fired by an external user.
            Suitable for use in MVC's codebehind, when the event should be fireable by the views.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ISimpleSignal">
            <summary>
            A simple <see cref="T:JetBrains.DataFlow.ISignal`1"/> that has no payload.
            Stands for the simple <see cref="T:System.EventHandler"/>-based event, but encapsulates the firing method, can take part in data flow, can be fired by an external user.
            Suitable for use in MVC's codebehind, when the event should be fireable by the views.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISimpleSignal.Fire">
            <summary>
            Fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(System.String)">
            <summary>Creates the signal.</summary>
            <param name="id">
            <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>Creates the signal.</summary>
            <param name="lifetime">
            <para>Defines the lifetime for the signal.</para>
            <para>When lifetime terminates, all of the handlers are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{System.Boolean},JetBrains.Util.ILogger)">
            <summary>Creates the signal.</summary>
            <param name="lifetime">
            <para>Defines the lifetime for the signal.</para>
            <para>When lifetime terminates, all of the handlers are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Optional logging engine override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.Fire">
            <summary>
            Fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.OnAfterAdvise(System.Action{System.Boolean})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.OnAfterUnadvise(System.Action{System.Boolean})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.OnBeforeAdvise(System.Action{System.Boolean})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.AfterAdviseHandler">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.AfterUnadviseHandler">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.BeforeAdviseHandler">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ConvertableEnumPattern`1">
            <summary>
            An EnumPattern implementation which supports convertion from a text string.
            </summary>
            <remarks>
            This implementation is intended to be used when you have to set EnumPattern attributes from XAML.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.EnumPattern">
            <summary>
            Base class for all enum patterns
            </summary>
        </member>
        <member name="T:JetBrains.Util.ConvertableEnumPatternConverter`1">
            <summary>
            A TypeConverter implementation for the ConvertableEnumPattern type.
            </summary>
            <remarks>
            Methods CanConvertTo and ConvertTo are not implemented, cause the base implementations do all we need.
            </remarks>
        </member>
        <member name="T:JetBrains.DataFlow.OuterLifetime">
            <summary>
              <para>A subset of the <see cref="T:JetBrains.DataFlow.Lifetime"/> interface with which you cannot “bind” actions to a lifetime.</para>
              <para>It's “outer” in the sense that it's not your lifetime, but of some parent object potentially more long-lived than yours. You cannot schedule anything to its termination because it will happen way after your object goes off scope.</para>
              <para>The only thing you can know is that it's an “outer”, it's limiting the life of your object, and if it's terminated — so are you. Checking for <see cref="P:JetBrains.DataFlow.OuterLifetime.IsTerminated"/> is one of the allowed option.</para>
              <para>Another option is to define a nested lifetime, in which case you MUST ensure it's terminated explicitly, without relying on the outer lifetime. The outer lifetime is only a safety catch to make sure it does not live too long.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.OuterLifetime.AttachNested(JetBrains.DataFlow.LifetimeDefinition,System.Boolean)">
            <summary>
            Exposes the <see cref="M:JetBrains.DataFlow.Lifetime.AttachNested(JetBrains.DataFlow.LifetimeDefinition,System.Boolean)"/> operation so that creation of nested lifetimes were possible on an outer lifetime.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.OuterLifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.StackFramesToString(System.Diagnostics.StackFrame[])">
            <summary>
            Formats the stack frames.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.CaptureAndFormatStackTrace(System.Boolean)">
            <summary>
            Captures the current stack trace, based on the <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces"/> setting.
            When the setting is <c>False</c>, a faster shortcut method with less info is used.
            If <param name="bObeyOptionCaptureStackTraces"/> is <c>False</c>, the stack trace is always fully-captured.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.CaptureAndFormatStackTrace">
            <summary>
            Captures the current stack trace, based on the <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces"/> setting.
            When the setting is <c>False</c>, a faster shortcut method with less info is used.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces">
            <summary>
            Whether to capture stack traces, or not.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.ConciseBitArray">
            <summary>
            Effective replace of <see cref="T:System.Collections.BitArray"/> for sparse and almost filled set. Effective for density of 1-s between 0 and 0.1, and beween 0.9 and 1.
            Inspired by http://ricerca.mat.uniroma3.it/users/colanton/docs/concise.pdf
            Non thread-safe
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.ConciseBitArray.Count">
            <summary>
            Slow implementation, no memoization    
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.DirectMappedCache`2">
            <summary>
            Fixed-size cache with only one element for bucket (hashcode % length) retained. http://en.wikipedia.org/wiki/CPU_cache  
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.DirectMappedCache`2.GetOrCreate``1(``0,System.Func{``0,`1})">
            <summary>
            Trying to get element from cache. If nothing found, creates from provider.    
            </summary>
            <typeparam name="TKeyInheritor">Any inheritor of <typeparamref name="TKey"/> or <typeparamref name="TKey"/> itself</typeparam>
            <param name="key">Key in cache</param>    
            <param name="provider">Function that generates value in case when key isn't in cache</param>
            <returns>Value either from cache or generater by <c>producer</c></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.DirectMappedCache`2.GetOrCreate``2(``0,``1,System.Func{``0,``1,`1})">
            <summary>
            Trying to get element from cache. If nothing found, creates from provider.
            This method is useful in case when you don't want to produce additional closure and lambda for functions with 2 parameters
            </summary>
            <typeparam name="TParam">Additional producer's parameter type</typeparam>
            <typeparam name="TKeyInheritor">Any inheritor of <typeparamref name="TKey"/> or <typeparamref name="TKey"/> itself</typeparam>
            <param name="key">Key in cache</param>
            <param name="param">Additional producer's parameter</param>
            <param name="provider">Function that generates value in case when key isn't in cache</param>
            <returns>Value either from cache or generater by <c>producer</c></returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.StringDotConcat">
            <summary>
            Represents string that consists from other strings. The way of avoiding string concatenation and high memory traffic.
            Works fast for small number of parts. Typical replace for: namespace + "." + typeName
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FibFinder">
            <summary>
            Utility for fibbonacci number 
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FibFinder.NextFib(System.Int32)">
            <summary>
            Find minimal fib number larger or equal to give
            </summary>
            <returns>lowest fibbonaci number greater or equal to given</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FibFinder.NextFibIndex(System.Int32)">
            <summary>
            Searches index <b>idx</b> in array <see cref="F:JetBrains.Util.dataStructures.FibFinder.FibSeq"/> such as <b>idx</b> - lowest possible number that satisfies <see cref="F:JetBrains.Util.dataStructures.FibFinder.FibSeq"/>[<b>idx</b>] &gt;= <b>x</b>.
            </summary>
            <param name="x">Input value</param>
            <returns>Index in  <see cref="F:JetBrains.Util.dataStructures.FibFinder.FibSeq"/> </returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.IntSet">
            <summary>
            Hash set for ints. Internally contains a single array so memory usage is low (but loadfactor is 0.75 to provide high speed for Add, Contains and Remove operations).
            The set is initialized with so-called marker element (0 by default) which is always contained in this set (you can't remove it). So set minimum size (<see cref="P:JetBrains.Util.dataStructures.IntSet.Count"/>) is 1.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.IntSet.NextBucketShift">
            <summary>
            Not equal to any number obtained by <see cref="M:JetBrains.Util.DataStructures.PrimeFinder.NextPrime(System.Int32)"/> 
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ValueRefEntry.SizeNBits">
            <summary>
            26 bits for size means we one key can hold from 0 to 67,108,864 values exclusively.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ValueRefEntry.CapacityNBits">
            <summary>
            Capacity for a given key is a log2 for #fibbonacci_number (0 is reserved for exact fit capacity). So maximum capacity is fib(64) which is 
            far larger than maximum count (as per <see cref="F:JetBrains.Util.dataStructures.ValueRefEntry.SizeNBits"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.MultimapStorage`1">
            <summary>
            Analogous to <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/> but correctly handles <see cref="M:JetBrains.Util.dataStructures.MultimapStorage`1.set_Item(System.Int32,`0)"/> with index bigger than current capacity. Also includes some additional
            facilities like <see cref="M:JetBrains.Util.dataStructures.MultimapStorage`1.CompactToNewCount(System.Int32)"/> which is used in enclosing map's compaction procedure.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:JetBrains.Util.dataStructures.MultimapValueCollectionEnumerator`1">
            <summary>
            Struct enumerator to reduce memory traffic
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:JetBrains.Util.dataStructures.KeyToEntryMap`1.NextBucketShift">
            <summary>
            Not equal to any number obtained by <see cref="M:JetBrains.Util.DataStructures.PrimeFinder.NextPrime(System.Int32)"/> 
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.IValueConsumer`2.Consume(`0,`1)">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.OneToListMultimap`2.Compact">
            <summary>
            Compacts and returns number of compacted entries.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.OneToListMultimap`2.CompactConditionally">
            <summary>
            Compacts if CompactionPolicy is met.
            </summary>
            <returns>Number of compacted entries or -1 if CompactionPolicy is not met</returns>
        </member>
        <member name="P:JetBrains.Util.dataStructures.OneToListMultimap`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>
            The element with the specified key.
            </returns>
            <param name="key">The key of the element to get or set.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.</exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1.ExtractOrBlock">
            <summary>
            Returns first element from queue or waits until it appears. In case of lifetime termination throws PCE.
            </summary>
            <returns>First element in queue</returns>
        </member>
        <member name="M:JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueues an item and returns the total number of items in the queue right after enqueueing, in a thread-safe-consistent manner.
            </summary>
        </member>
        <member name="M:JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1.ToArray">
            <summary>
            Copies data to an array, thread-safely.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.RawCircularBufferHeader">
            <summary>
              Implements a raw circular buffer which is attached to an existing memory pointer (e.g. to work on some shared memory).
            </summary>
            <remarks>
              Strategy: manages allocation of sequential memory chunks called messages.
              <see cref="F:JetBrains.Util.dataStructures.RawCircularBufferHeader.TotalSize"/> is the total available space of the buffer. <see cref="F:JetBrains.Util.dataStructures.RawCircularBufferHeader.BufferHeaderSize"/> bytes in the beginning are occupied by this header structure.
              The remaining memory is either empty, or occupied by a single contiguous used block of messages (
              <see cref="F:JetBrains.Util.dataStructures.RawCircularBufferHeader.BlockHead"/>
              ), or by two contiguous blocks after the content wraps over the buffer end.
              Possible layouts:
              [header] {head} -empty-                       // just started writing
              [header] -empty1- {head} -empty2-             // read some first messages of the written
              [header] {head} -empty1- {tail} -empty2-      // attempted writing new messafe after {head}, there were not enough space till the end of the buffer, so we wrapped head to the beginning (there's small -empty2- because we do not break messages when wrapping around the buffer, message memory is always contiguous)
              and then it goes all around
            </remarks>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RawCircularBufferHeader.TryReadMessage(JetBrains.Util.dataStructures.RawCircularBufferHeader*,System.Action{JetBrains.Util.dataStructures.ByteBuffer})">
            <summary>
              Reads the message, if any present, and invokes the callback. Returns whether there was any message to invoke the callback with.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RawCircularBufferHeader.TryReadMessage(JetBrains.Util.dataStructures.RawCircularBufferHeader*)">
            <summary>
              Reads the message, if any present. If not, yields <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RawCircularBufferHeader.TryWriteMessage(JetBrains.Util.dataStructures.RawCircularBufferHeader*,System.Byte[])">
            <summary>
              Tries to write message, returns <c>False</c> if there's no space left.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RawCircularBufferHeader.FreeSpace">
            <summary>
              The available free space at this moment.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RawCircularBufferHeader.MaxDataSize">
            <summary>
              Maximum payload size (that's max free space minus the message header).
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.SafeUnmanagedMemory">
            <summary>
            Unmanaged piece of memory that MUST be taken by <code>using (var mem = SafeUnmanagedMemory.Alloc(sizeInBytes) {...}</code> construct.
            Works faster then <see cref="T:JetBrains.Util.UnmanagedBlock"/> because doesn't use <see cref="T:System.Runtime.InteropServices.SafeHandle"/> utility inside.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.SimpleTrie`2">
            <summary>
            A trie which stores hierarchically nodes whose keys are lists of <typeparamref name="TKey"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.SimpleTrie`2.myRootNode">
            <summary>
            Synthetic root.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.SimpleTrie`2.RemoveAllKeyPrefixes(System.Collections.Generic.IList{`0})">
            <summary>
            Removes all nodes on any possible prefixes of <paramref name="keys"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.LimitedDictionary`2">
            <summary>
            Cache of most recently used items.
            No position update on access.
            </summary>
        </member>
        <member name="T:JetBrains.Util.CompoundException">
            <summary>
            Aggregates multiple exceptions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CompoundException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>
            A string representation of the current exception.
            </returns>
            <filterpriority>1</filterpriority>
             <PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*" /></PermissionSet>
        </member>
        <member name="P:JetBrains.Util.CompoundException.Message">
            <summary>
            Gets a message that describes the current exception.
            </summary>
            <returns>
            The error message that explains the reason for the exception, or an empty string("").
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.Concurrency.GroupingEventHostEx.QueueAtShort(JetBrains.Threading.GroupingEventHost,JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute once on the <paramref name="host"/>.<see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>.<see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread when the timeout elapses.</para>
            <para>Handles intervals smaller than <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/> only.</para>
            <para>Returns a token that cancels the action execution. The token disposal is optional.</para>
            <para>The execution will be either guarded or not, depending on the presence of <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/> property value.</para>
            </summary>
            <param name="host"><c>this</c></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="T:JetBrains.Util.Concurrency.LockObject">
            <summary>
            When you need to create an instance of some object to <c>lock</c> against it (<see cref="M:System.Threading.Monitor.Enter(System.Object)"/>), use this class.
            It has an additional method for entering the lock with a timeout (throwing an exception if failed).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LockObject.UsingLock(System.TimeSpan)">
            <summary>
            Takes a lock. If the timeout expires before the lock can be acquired, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the writer lock. If the time limit expires, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the writer lock. If the time limit expires, throws an exception.
            Exits the writer lock when you dispose of the return value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            For high performance code. No lambda and heap allocation.
            </summary>    
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock. If the time limit expires, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterReadLock(System.Threading.ReaderWriterLockSlim,System.Int32)">
            <summary>
            Enters the reader lock. If the time limit expires, throws an exception.
            NOTE: this overload takes milliseconds for perf because it's what the library method uses internally.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock. If the time limit expires, throws an exception.
            Exits the reader lock when you dispose of the return value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            For high performance code. No lambda and heap allocation.
            </summary>    
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock upgradeable to writer lock (by a nested <see cref="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)"/> request). If the time limit expires, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock upgradeable to writer lock (by a nested <see cref="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)"/> request). If the time limit expires, throws an exception.
            Exits the reader lock when you dispose of the return value.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Reclaims the queueing and cancels the action from executing when the lifetime ends.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueueEx(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueueEx(JetBrains.Threading.ReentrancyGuard,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="T:JetBrains.DataFlow.AddRemove">
            <summary>
            Defines whether the action is <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> or <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.AddRemove.Add">
            <summary>
            Adding.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.AddRemove.Remove">
            <summary>
            Removing.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.AddRemoveEventArgs`1">
            <summary>
            Notifies that the item is being added to or removed from an event-equipped collection.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="T:JetBrains.DataFlow.EventArgs`1">
            <summary>
            An event arguments class with one typed value.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.EventArgs`1.#ctor(`0)">
            <summary>
            Constructs the universal event args.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.EventArgs`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.AddRemoveEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.DataFlow.AddRemove,System.Object,System.Action{`0}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Action">
            <summary>
            Gets the action (either <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> or <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/>).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Collection">
            <summary>
            Gets the owning event-equipped collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Cookie">
            <summary>
            An optional cookie specified with the operation.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging">
            <summary>
            Gets whether the handler is being called in the Acknowledgement mode, that is, the items appear/disappear in the handler's view not because they're being put/removed into the collection, but because the collection itself comes/goes into view of the handler, with all of its items. This happens when you sink/unsink the signal.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding">
            <summary>
            Gets whether <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Action"/> is actually <see cref="F:JetBrains.DataFlow.AddRemove.Add"/>.
            Exactly one of <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> and <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is guaranteed to be <c>True</c>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving">
            <summary>
            Gets whether <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Action"/> is actually <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/>.
            Exactly one of <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> and <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is guaranteed to be <c>True</c>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.AddRemoveIndexEventArgs`1">
            <summary>
            Notifies that the item is being added to or removed from an event-equipped list.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.AddRemoveIndexEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.DataFlow.AddRemove,System.Object,System.Action{`0,System.Int32}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveIndexEventArgs`1.Index">
            <summary>
            Gets the index at which the change is happening.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1">
            <summary>
            Notifies that the item will be added to or removed from an event-equipped collection, and allows to cancel this action.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.DataFlow.AddRemove,System.Object,System.Action{`0}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel">
            <summary>
            Gets or sets whether the change will be cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1">
            <summary>
            Notifies that the item will be added to or removed from an event-equipped list, and allows to cancel this action.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.DataFlow.AddRemove,System.Object,System.Action{`0,System.Int32}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1.Index">
            <summary>
            Gets the index at which the change is happening.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1">
            <summary>
            Notifies of the intended property change.
            Comes before the <see cref="T:JetBrains.DataFlow.PropertyChangedEventArgs`1"/> and the actual property change, and allows to cancel the change.
            Acknowledges the fact that the property change can be either from “no value” to something, or from something to “no value”.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyChangedEventArgs`1">
            <summary>
            Notifies of the property change.
            Acknowledges the fact that the property change can be either from “no value” to something, or from something to “no value”.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangedEventArgs`1.CreateBoth(JetBrains.DataFlow.Property{`0},`0,`0,System.Object)">
            <summary>
            Creates an instance that has both values defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangedEventArgs`1.CreateNew(JetBrains.DataFlow.Property{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the new value defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangedEventArgs`1.CreateOld(JetBrains.DataFlow.Property{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the old value defined.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Cookie">
            <summary>
            Gets the property modification cookie (a freehand parameter).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew">
            <summary>
            Gets whether the property will have a new value, ie <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New"/> is defined.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld">
            <summary>
            Gets whether the property had an old value, ie <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old"/> is defined.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging">
            <summary>
            Gets whether the handler is being called in the acknowledgement mode, that is, because the property is coming into view
            or going off the view, and its value effectively changes either from “not known yet” to some value, or the other way.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">
            <summary>
            Gets the new value of the property.
            It's an error to request the value if not <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old">
            <summary>
            Gets the old value of the property.
            It's an error to request the value if not <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Property">
            <summary>
            Gets the property that has changed.
            You should use the <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old"/> and <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New"/> properties on this object instead of quering values from the property directly.
            You should not set new values to the property, unless you're sure you know what you're doing.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.CreateBoth(JetBrains.DataFlow.Property{`0},`0,`0,System.Object)">
            <summary>
            Creates an instance that has both values defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.CreateNew(JetBrains.DataFlow.Property{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the new value defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.CreateOld(JetBrains.DataFlow.Property{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the old value defined.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel">
            <summary>
            Gets or sets whether the change will be cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CancelEventArgs`1">
            <summary>
            An event arguments class with one typed value and the Cancel functionality.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.CancelEventArgs`1.Cancel">
            <summary>
            Gets or sets whether the change will be cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionBridge`2">
            <summary>
            Bridges two unordered collection of items.
            The items flow from the first collection to the second one. Conversion and filtering is supported on the items.
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge`2.myMapBothWays">
            <summary>
            Two-way map, non-Null only in two-way mode.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge`2.myMapSourceToTarget">
            <summary>
            One-way map, non-Null only in one-way mode.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionBridge`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.CollectionBridge.MappingInfo,JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.DataFlow.ICollectionEvents{`1},System.Func{`0,`1},System.Object)">
            <summary>
            Wires up the bridge.
            </summary>
            <param name="lifetime">Lifetime for the bridge.</param>
            <param name="mappinginfo">Specifies which mapping information is maintained by the bridge — source-to-target only, or both ways. one-way is cheaper.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="funcConverter">The conversion operator.</param>
            <param name="oTaregtModificationCookie">An otpional cookie to be passed to the <paramref name="target"/> collection when performing modification operations on it.</param>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.AllowForeignTargetRemovals">
            <summary>
            <para>Whether the bridged items could be removed from the target collection by a foreign actor, and the bridge should ignore such occurrences.</para>
            <para>When <c>True</c>, <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> does nothing when the target item is already not there.</para>
            <para>When <c>False</c>, <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> throws when about to remove a nonexistent item. This is the default.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.MappingInfo">
            <summary>
            Gets which mapping information is maintained by the bridge — source-to-target only, or both ways.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.MapSourceToTarget">
            <summary>
            Gets the read-only source-to-target mapping info. This one is always available.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.MapTargetToSource">
            <summary>
            Gets the read-only target-to-source mapping. Available only if <see cref="P:JetBrains.DataFlow.CollectionBridge`2.MappingInfo"/> is set to <see cref="F:JetBrains.DataFlow.CollectionBridge.MappingInfo.BothWays"/>; in other cases, throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.Source">
            <summary>
            Gets the source collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.Target">
            <summary>
            Gets the target collection.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionBridge">
            <summary>
            Supplementary class for the <see cref="T:JetBrains.DataFlow.CollectionBridge`2"/> utility.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionBridge.BridgeInto``2(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``1},System.Func{``0,``1},System.Object)">
            <summary>
            Mirrors one collection into another thru a converter.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionBridge.MappingInfo">
            <summary>
            Kind of info about collections mapping to be maintained by the bridge.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge.MappingInfo.SourceToTarget">
            <summary>
            There's only data for translating from the source collection to the target one.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge.MappingInfo.BothWays">
            <summary>
            There's data for translating both from source to target and from target to source collection items.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionEvents`1">
            <summary>
            A collection that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="T:JetBrains.DataFlow.ICollectionEvents`1">
            <summary>
            A collection that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="T:JetBrains.DataFlow.IViewable`1">
            <summary>
            A viewable collection of items 
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Add(`0,System.Object)">
            <summary>
            Attempts to add the item to the collection.
            </summary>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was added to the collection. An addition can be cancelled by the duplicates merger or the before-added handlers.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Executes the <see cref="M:JetBrains.DataFlow.ICollectionEvents`1.Add(`0,System.Object)"/> operation for all the elements in the given collection.
            </summary>
            <param name="items">The collection whose elements should be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Modify(JetBrains.DataFlow.AddRemove,`0,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Remove(`0,System.Object)">
            <summary>
            Attempts to remove a value from the collection.
            </summary>
            <param name="value">The value to be removed.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was removed from the collection. A removal may fail either if the item is missing from the collection, or the before-removed handlers have cancelled the operation.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Clear(System.Object)">
            <summary>
            Removes all items from the collection.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.ToArray">
            <summary>
            <para>A thread-save version of the LINQ call.</para>
            </summary>
            <remarks>
            <para>The regular version for collections takes the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.Count"/> and then calls <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>, which is race condition prone.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.ToList">
            <summary>
            <para>A thread-save version of the LINQ call.</para>
            </summary>
            <remarks>
            <para>The regular version for collections takes the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.Count"/> and then calls <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>, which is race condition prone.</para>
            </remarks>
        </member>
        <member name="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove">
            <summary>
            Fires when an item is added or removed to your view on the collection.
            Throwing an exception does not prevent the item from being added or other handlers from being called.
            The event supports acknowledgment, which means that when you sink the event, all of the items currently in collection come into your view on the collection, so the add is fired for each. Similarly, remove is fired when you unsink and all of the elements go away from your view on the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added or removed.
            To prevent the add/remove operation, set <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> (decline the operation silently) or throw an exception (the exception is let out to the caller). 
            After the first handler to cancel the operation, the remaining handlers may not be called.
            No <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> are guaranteed to be executed if the operation is cancelled.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ICollectionEvents`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ICollectionEvents`1.Id">
            <summary>
            Gets the identification for this list.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionEvents`1.myStorage">
            <summary>
            Sync thru <see cref="F:JetBrains.DataFlow.CollectionEvents`1.myLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{`0},System.Collections.Generic.ICollection{`0},System.Boolean,JetBrains.Util.ILogger)">
            <summary>
            <para>The universal constructor.</para>
            <para>Initializes the collection by giving the underlying storage that also implements the collection interface.</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">Whether the <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)"/> method should abort silently if the collection already <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)"/> the item being added.</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(System.String,System.Collections.Generic.ICollection{`0},System.Boolean)">
            <summary>
            Initializes the collection by giving the underlying storage that also implements the collection interface.
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">Whether the <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)"/> method should abort silently if the collection already <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)"/> the item being added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.DataFlow.Lifetime,System.String,System.Collections.Generic.ICollection{`0},System.Boolean)">
            <summary>
            Initializes the collection by giving the underlying storage that also implements the collection interface.
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">Whether the <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)"/> method should abort silently if the collection already <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)"/> the item being added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(System.String)">
            <summary>
            Creates a collection that is based on a <see cref="T:System.Collections.Generic.List`1"/> and merges duplicate items.
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Creates a collection that is based on a <see cref="T:System.Collections.Generic.List`1"/> and merges duplicate items.
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.ThrowReadonlyFail(JetBrains.DataFlow.BeforeAddRemoveEventArgs{`0},System.Object)">
            <summary>
            Helper to throw an annotated exception whenever a collection fails the readonly lock precondition.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.ThrowThreadAffinityFail(JetBrains.DataFlow.BeforeAddRemoveEventArgs{`0},System.Threading.Thread)">
            <summary>
            Helper to throw an annotated exception whenever a collection fails the threading affinity precondition.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireAddRemove(JetBrains.DataFlow.AddRemove,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.AddRemove"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireBeforeAddRemove(JetBrains.DataFlow.AddRemove,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove"/> event.
            Returns whether the operation has been cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireCollectionChanged(`0,JetBrains.DataFlow.AddRemove)">
            <summary>
            Fires the <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> event in case the index is not known.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireCollectionChanged(`0,System.Int32,JetBrains.DataFlow.AddRemove)">
            <summary>
            Fires the <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> event in case the index is known.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FirePropertyChanged(System.String)">
            <summary>
            Fires the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.InternalAdd(`0,System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.InternalRemove(`0,System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.InternalClear(System.Object)">
            <summary>
            Removes all items from the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.OnAcknowledgeSinkAddRemove(System.Action{JetBrains.DataFlow.AddRemoveEventArgs{`0}},JetBrains.DataFlow.AddRemove)">
            <summary>
            Ackhowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.OnAcknowledgeSinkBeforeAddRemove(System.Action{JetBrains.DataFlow.BeforeAddRemoveEventArgs{`0}})">
            <summary>
            Called when someone attempts to sink the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove"/> signal. Acknowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0,System.Object)">
            <summary>
            Attempts to add the item to the collection.
            </summary>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was added to the collection. An addition can be cancelled by the duplicates merger or the before-added handlers.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Executes the <see cref="M:JetBrains.DataFlow.ICollectionEvents`1.Add(`0,System.Object)"/> operation for all the elements in the given collection.
            </summary>
            <param name="items">The collection whose elements should be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only. </exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Clear(System.Object)">
            <summary>
            Removes all items from the collection.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific value.
            </summary>
            
            <returns>s
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or-arrayIndex is equal to or greater than the length of array.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from arrayIndex to the end of the destination array.-or-Type T cannot be cast automatically to the type of the destination array.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Modify(JetBrains.DataFlow.AddRemove,`0,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Remove(`0,System.Object)">
            <summary>
            Attempts to remove a value from the collection.
            </summary>
            <param name="value">The value to be removed.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was removed from the collection. A removal may fail either if the item is missing from the collection, or the before-removed handlers have cancelled the operation.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if item is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing. </param>
            <param name="index">The zero-based index in array at which copying begins. </param>
            <exception cref="T:System.ArgumentNullException">array is null. </exception>
            <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.IsNullValuesAllowed">
            <summary>
            Gets whether the <c>Null</c> values are allowed to be added to the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.IsUniqueItems">
            <summary>
            Gets whether all of the items in the collection should be unique.
            Behavior of the collection in case of duplicates found depends on the
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors">
            <summary>
            Gets whether the errors when adding/removing items should be suppressed, and just <c>false</c> returned, when appropriate.
            The errors include “item already added” (when <see cref="P:JetBrains.DataFlow.CollectionEvents`1.IsUniqueItems"/>) or “cannot remove nonexistent item”.
            </summary>
        </member>
        <member name="E:JetBrains.DataFlow.CollectionEvents`1.CollectionChanged">
            <summary>
            Occurs when the collection changes.
            </summary>
            
        </member>
        <member name="E:JetBrains.DataFlow.CollectionEvents`1.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
            
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.AddRemove">
            <summary>
            Fires when an item is added (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> is defined) or removed (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is defined).
            Throwing an exception does not prevent the item from being added, and other handlers from being called.
            The event supports acquaintance, which means that when you sink it, all the items currently in collection are “added”, and when you unsink, they are “removed” for the particular eventhandler you're adding or removing.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> is defined) or removed (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is defined).
            Setting <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> or throwing an exception prevents the item from being added.
            Note that even though the number of before-handlers called is undefined in such a case, no <see cref="P:JetBrains.DataFlow.CollectionEvents`1.AddRemove"/> handlers are guaranteed to execute if you cancel the operation on the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove"/> event.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.Id">
            <summary>
            Gets the identification for this list.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.
            </returns>
            
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
            
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            
            <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.DataFlowDirection">
            <summary>
            Defines the direction of the data flow between two properties.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.None">
            <summary>
            No synchronization is performed automatically.
            Both bindings can still be invoked manually.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.FromSource">
            <summary>
            A one-way forward data flow from the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/> to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Target"/>.
            The back-way binding can still be invoked manually.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.FromTarget">
            <summary>
            A one-way backward data flow from the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Target"/> to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/>.
            The forward-way binding can still be invoked manually.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.BothWays">
            <summary>
            A two-way data flow from the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/> to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Target"/>, and then back to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DictionaryEvents`2">
            <summary>
            A dictionary that fires events when items are added or removed.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IDictionaryEvents`2">
            <summary>
            A dictionary that fires events when items are added or removed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IDictionaryEvents`2.TryGetValue(`0,System.Func{`1})">
            <summary>
            Attempts to look up a value by its <paramref name="key"/> in the dictionary.
            In case there is no such key-value pair present, uses the <paramref name="funcCreateIfMissing"/> function to create a new value, and then places it into the dictionary under the <paramref name="key"/>.
            </summary>
            <param name="key">Key to the value we're trying to look up.</param>
            <param name="funcCreateIfMissing">In case there is no <paramref name="key"/> in the dictionary, produces a new value to be stored in the dictionary and returned to the caller.</param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.DataFlow.DictionaryEvents`2.myStorage">
            <summary>
            Stores the dictionary entries.
            Sync thru <see cref="F:JetBrains.DataFlow.CollectionEvents`1.myLock"/>.
            </summary>
            <remarks>
            The storage must be passed to the base class in ctor, for the collection operations to work on the same data.
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IDictionary{`0,`1},System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>
            <para>This is the universal constructor.</para>
            <para>Specifies whether <c>Null</c> keys or values are allowed or not.</para>
            <para>Take caution with value types, for them the <c>default</c> value is used.</para>
            <para>Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bNullKeysAllowed">Whether <c>Null</c> values are allowed for keys (take caution with value types).</param>
            <param name="bNullValuesAllowed">Whether <c>Null</c> values are allowed for values (take caution with value types).</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(System.String,JetBrains.Util.ILogger)">
            <summary>
            Creates a dictionary that allows storing <c>Null</c> values.
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Util.ILogger)">
            <summary>
            Creates a dictionary that allows storing <c>Null</c> values.
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(System.String,System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>
            <para>Specifies whether <c>Null</c> keys or values are allowed or not.</para>
            <para>Take caution with value types, for them the <c>default</c> value is used.</para>
            <para>Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.</para>
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="bNullKeysAllowed">Whether <c>Null</c> values are allowed for keys (take caution with value types).</param>
            <param name="bNullValuesAllowed">Whether <c>Null</c> values are allowed for values (take caution with value types).</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.DataFlow.Lifetime,System.String,System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>
            <para>Specifies whether <c>Null</c> keys or values are allowed or not.</para>
            <para>Take caution with value types, for them the <c>default</c> value is used.</para>
            <para>Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="bNullKeysAllowed">Whether <c>Null</c> values are allowed for keys (take caution with value types).</param>
            <param name="bNullValuesAllowed">Whether <c>Null</c> values are allowed for values (take caution with value types).</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.InternalAdd(System.Collections.Generic.KeyValuePair{`0,`1},System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.InternalRemove(System.Collections.Generic.KeyValuePair{`0,`1},System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <param name="value">The object to use as the value of the element to add.</param>
            <param name="key">The object to use as the key of the element to add.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an element with the specified key.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an element with the key; otherwise, false.
            </returns>
            
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if key was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.TryGetValue(`0,System.Func{`1})">
            <summary>
            Attempts to look up a value by its <paramref name="key"/> in the dictionary.
            In case there is no such key-value pair present, uses the <paramref name="funcCreateIfMissing"/> function to create a new value, and then places it into the dictionary under the <paramref name="key"/>.
            </summary>
            <param name="key">Key to the value we're trying to look up.</param>
            <param name="funcCreateIfMissing">In case there is no <paramref name="key"/> in the dictionary, produces a new value to be stored in the dictionary and returned to the caller.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.set_Item(`0,System.Object,`1)">
            <summary>
            Sets the element with the specified key.
            An overload of the <see cref="M:JetBrains.DataFlow.DictionaryEvents`2.set_Item(`0,`1)"/> method which allows to specify the modification cookie for both removal and addition operation events which might be fired as a result of this assignment.
            </summary>
            <param name="key"></param>
            <param name="cookie"></param>
            <param name="value"></param>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.NullPairKeysAllowed">
            <summary>
            Gets whether <c>Null</c> keys are allowed or not.
            Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.NullPairValuesAllowed">
            <summary>
            Gets whether <c>Null</c> values are allowed or not.
            Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            
            <returns>
            The element with the specified key.
            </returns>
            
            <param name="key">The key of the element to get or set.</param>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and key is not found.</exception>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            
        </member>
        <member name="T:JetBrains.DataFlow.CollectionValidator">
            <summary>
            Validates collections by preventing certain values from being added or removed.
            Note that for the validator to attach, the original values must all pass the validation.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.CreateReadonlyValidator``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.CreateThreadAffinityValidator``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Threading.Thread)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the given <paramref name="thread"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.ListEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.ListEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.CollectionEvents{``0})">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.ICollectionEvents{``0})">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.ListEvents{``0})">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.ListEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.IListEvents{``0})">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.DictionaryEvents{``0,``1})">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1})">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DataFlowEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DataFlowEx.OnSignal``1(JetBrains.DataFlow.IPropertyBinding,JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.DataFlowDirection)">
            <summary>
            Sets up the binding to update when the <paramref name="signal"/> fires.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DataFlowEx.AddLifetime(System.ComponentModel.IContainer,JetBrains.DataFlow.LifetimeDefinition)">
            <summary>
            Allows to bind the lifetime to a Windows Form.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DataFlowEx.DefineWinFormsLifetime(System.Windows.Forms.Control)">
            <summary>
            Defines a lifetime that terminates when the control or form is disposed of.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ICollectionEventsEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.BeginAdd``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            Asynchronously adds a new item to the collection.
            </summary>
            <typeparam name="TValue">Item type.</typeparam>
            <param name="thіs">Collection.</param>
            <param name="lifetimeAsyncOperation">The lifetime for the async operation of adding the item, NOT for the item's presence in the collection! If the lifetime expires while the deferred operation is still pending, the operation will be dropped.</param>
            <param name="dispatcher">Identifies the thread the modification should happen on.</param>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.CreateCount``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a property that tells the numer of items in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.CreateIsEmpty``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a property that tells whether the collection is empty.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.CreateIsNotEmpty``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a property that tells whether the collection has some items in it.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.LogChanges``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Logs the collection modifications.
            </summary>
            <param name="thіs">The collection.</param>
            <param name="lifetime">ILifetime for the logging set-up.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.LogChanges``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.Util.ILogger)">
            <summary>
            Logs the collection modifications.
            </summary>
            <param name="thіs">The collection.</param>
            <param name="lifetime">ILifetime for the logging set-up.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.LogChanges``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Object)">
            <summary>
            Logs the collection modifications.
            </summary>
            <param name="thіs">The collection.</param>
            <param name="lifetime">ILifetime for the logging set-up.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix, ie prepended in square brackets to each log message, or a <see cref="T:System.Type"/> whose short name will be used.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each item in the collection.</para>
            <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.DataFlow.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes — before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0,System.Object})">
            <summary>
            <para>Binds a lifetime to each item in the collection.</para>
            <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.DataFlow.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes — before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself, the third param is the cookie with which the item has been added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemCore``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0},System.Action{JetBrains.DataFlow.Lifetime,``0,System.Object})">
            <summary>
            Core impl for both ForEachItem functions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemFreeThreaded``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
              <para>Binds a lifetime to each item in the collection.</para>
              <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.DataFlow.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
              <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes — before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
              <para>This version allows free-threaded add/removes on the collection and lifetime termination. To be completely thread-safe, the lifetime passed to this function MUST be synchronized with collection adds/removes, see <see cref="T:JetBrains.Util.Threading.SynchronizedLifetime"/>.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemFreeThreaded``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0,System.Object})">
            <summary>
              <para>Binds a lifetime to each item in the collection.</para>
              <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.DataFlow.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
              <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes — before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
              <para>This version allows free-threaded add/removes on the collection and lifetime termination. To be completely thread-safe, the lifetime passed to this function MUST be synchronized with collection adds/removes, see <see cref="T:JetBrains.Util.Threading.SynchronizedLifetime"/>.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself, the third param is the cookie with which the item has been added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemFreeThreadedCore``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0},System.Action{JetBrains.DataFlow.Lifetime,``0,System.Object})">
            <summary>
            Core impl for ForEachItemFreeThreadedCore family functions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.Add``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,``0,System.Object)">
            <summary>
            Attempts to add the item to the collection.
            </summary>
            <param name="lifetime">ILifetime for the item to be present in the collection. Upon termination, the item is removed.</param>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <param name="thіs">Collection.</param>
            <returns>If the item was added to the collection (not cancelled by the duplicates merger or the before-added handlers), returns an object that removes the item from the collection on <see cref="M:System.IDisposable.Dispose"/>. Otherwise, returns a dummy <see cref="T:System.IDisposable"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.Insert``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime,System.Int32,``0,System.Object)">
            <summary>
            Attempts to insert the item to the list
            </summary>
            <param name="lifetime">ILifetime for the item to be present in the collection. Upon termination, the item is removed.</param>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <param name="index">The zero-based index at which <paramref name="value"/> should be inserted.</param>
            <param name="thіs">Collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``1},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Object)">
            <summary>
            Mirrors one collection into another.
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the collection flow.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that for the <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> operation to be mirrored successfully, the converter product must return <see cref="M:System.Object.Equals(System.Object,System.Object)"/> for to projections of the same source item. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="FFilter">Allows to exclude certain items from being converted and added to the target collection.</param>
            <param name="cookie">An optional cookie for the modification operation on the <paramref name="target"/> collection.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``1},System.Func{JetBrains.DataFlow.Lifetime,``0,``1},System.Func{``0,System.Boolean},System.Object)">
            <summary>
                <para>Mirrors one collection into another.</para>
                <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">
                If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the
                <see cref="F:JetBrains.DataFlow.AddRemove.Add"/>
                operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.
            </param>
            <param name="FFilter">Allows to exclude certain items from being converted and added to the target collection.</param>
            <param name="cookie">
                An optional cookie for the modifiction operation on the <paramref name="target"/> collection.
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoCollectionCore``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.ICollectionEvents{``1},System.Func{``0,``1},System.Func{JetBrains.DataFlow.Lifetime,``0,``1},System.Func{``0,System.Boolean},System.Object)">
            <summary>
                <para>Mirrors one collection into another.</para>
                <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">
                If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the
                <see cref="F:JetBrains.DataFlow.AddRemove.Add"/>
                operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.
            </param>
            <param name="FLifeConvert">
                Same as <see cref="!:FConvert"/>, but with a lifetime. It's an error to specify both at the same time.
            </param>
            <param name="FFilter">Allows to exclude certain items from being converted and added to the target collection.</param>
            <param name="cookie">
                An optional cookie for the modifiction operation on the <paramref name="target"/> collection.
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Func{``0,``1},System.Object)">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="cookie">An optional cookie for the modifiction operation on the <paramref name="target"/> collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Func{JetBrains.DataFlow.Lifetime,``0,``1},System.Object)">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="cookie">An optional cookie for the modifiction operation on the <paramref name="target"/> collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{``1})">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="target">The target collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoListCore``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.IListEvents{``1},System.Func{``0,``1},System.Func{JetBrains.DataFlow.Lifetime,``0,``1},System.Object)">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="FLifeConvert">Same as <see cref="!:FConvert"/>, but with a lifetime. It's an error to specify both at the same time.</param>
            <param name="cookie">An optional cookie for the modifiction operation on the <paramref name="target"/> collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.DisposeEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Makes sure each item of the collection is disposed of when it exits the collection view (just after the item is removed from the collection).
            When the <paramref name="lifetime"/> terminates, all of the items currently in the collection are also disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoGuarded_NoReplay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.ReentrancyGuard,System.Boolean,System.Object)">
            <summary>
            Updates the second collection as the first one is modified, but in a guarded context.
            After the guarded context gets acquired, does not replay all additions and removals, but instead replicates the current collection state (hence "no replay"). Can be thus slow on large collections, so hashsets are recommended as backing store.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoGrouped_NoReplay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.GroupingEventHost,System.TimeSpan,System.Boolean,System.Object)">
            <summary>
            Updates the second collection as the first one is modified, but at a rarer intervals, as limited by the grouping event (could be guarded or guard-invariant).
            After the timeout expires, does not replay all additions and removals, but instead replicates the current collection state (hence "no replay"). Can be thus slow on large collections, so hashsets are recommended as backing store.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoGrouped_NoReplay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},System.Action,System.Action{System.Action},System.Boolean,System.Object)">
            <summary>
            Updates the second collection as the first one is modified, but at a rarer intervals, as defined by the grouping function (eg <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> or <see cref="M:JetBrains.Util.Concurrency.GroupingEventHostEx.QueueAtShort(JetBrains.Threading.GroupingEventHost,JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)"/>).
            When the grouping function manages to execute, does not replay all additions and removals, but instead replicates the current collection state (hence "no replay"). Can be thus slow on large collections, so hashsets are recommended as backing store.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoSorted``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{``0},System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEqualityComparer{``0},System.Func{``0,System.Boolean},System.Object)">
            <summary>
            For a collection of arbitrary items, maintains a list (= collection with linear order on the items) of the same items sorted in the order as defined by the <paramref name="comparerForSorting"/>.
            </summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="source">Collection of items without any order implied.</param>
            <param name="lifetime">Time to work.</param>
            <param name="target">Target collection of ordered items.</param>
            <param name="comparerForSorting">Comparer setting up the order. Might be partial order, in which case items are added in order of appearance (stable sorting), and removed by equality (<see cref="!:comparerForDeleting"/>). If <c>NULL</c>, uses default comparer, e.g. <see cref="T:System.IComparable`1"/> on the type.</param>
            <param name="comparerForDeleting">Optional. If <see cref="!:comparerForSorting"/> does not impose linear order, upon deletion we might get a set of items all of the same sort order. To remove the correct one of them, we have to check equality now, and here's the comparer. If <c>NULL</c>, uses default comparer.</param>
            <param name="FFilter">Optional filtering function.</param>
            <param name="cookie">Target collection modification token.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.OrderByLive``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns an ordered representation of the collection, the order defined by the <paramref name="comparer"/>.
            </summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="thіs">Collection of items without any order implied.</param>
            <param name="lifetime">Time to work.</param>
            <param name="comparer">Comparer setting up the order.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.GetLifetimeOfItem``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,``0)">
            <summary>
            For an item in the collection, creates a lifetime that will be terminated when the item leaves the collection (or the passed-in lifetime terminates, or the collection lifetime terminates).
            </summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="thіs">Collection.</param>
            <param name="lifetime">The limiting lifetime. The returned lifetime will be nested within this lifetime (as well as within the collection's).</param>
            <param name="item">The item whose lifetime should be created. It's an error if the item is currently not present within the collection.</param>
            <returns>The lifetime of the item's presence in the collection.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.AddItemUnderLifetime``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.Lifetime,System.Func{JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.LifetimeDefinition,``0})">
            <summary>
              <para>Creates a new item to be added to the collection.</para>
              <para>The item lifetime terminates when either the input lifetime is terminated, or when the item is removed from the collection by some other collection client.</para>
              <para>If you terminate the item's definition, it will be removed from the collection.</para>
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemData.OpenLifetimes">
            <summary>
            Holds one lifetime for each item that was added, but not yet removed. This supports reordering which might happen with free-threaded access.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemData.RemoveRequests">
            <summary>
            Holds one per each item remove event which has not been yet completed. E.g. with free-threaded operations a Remove event might come before its Add.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.BeginAdd``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            Asynchronously adds a new item to the collection.
            </summary>
            <typeparam name="TValue">Item type.</typeparam>
            <param name="coll">Collection.</param>
            <param name="dispatcher">Identifies the thread the modification should happen on.</param>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.BridgeInto_Guarded_Slow``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.ReentrancyGuard,System.Object)">
            <summary>
            Bridges first collection modifications into the second collection, in the guarded context.
            Slow. Not suitable for large collections. Better use hashsets (both).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.PushForEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},System.Func{``0,System.IDisposable})">
            <summary>
            Executes a pair of actions for each of the items in the collection.
            When a new items comes into view, executes the <paramref name="handler"/> for it. The return value of the <paramref name="handler"/> is the closing bracket and will be executed when the collection item goes off the view.
            </summary>
            <typeparam name="TValue">Type of the collection items.</typeparam>
            <param name="coll">The collection.</param>
            <param name="handler">The handler that executes the opening bracket and returns an <see cref="T:System.IDisposable"/> that executes the closing bracket when disposed of.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.PushForEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},System.Func{JetBrains.DataFlow.AddRemoveEventArgs{``0},System.IDisposable})">
            <summary>
            Executes a pair of actions for each of the items in the collection.
            When a new items comes into view, executes the <paramref name="handler"/> for it. The return value of the <paramref name="handler"/> is the closing bracket and will be executed when the collection item goes off the view.
            </summary>
            <typeparam name="TValue">Type of the collection items.</typeparam>
            <param name="coll">The collection.</param>
            <param name="handler">The handler that executes the opening bracket and returns an <see cref="T:System.IDisposable"/> that executes the closing bracket when disposed of.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Add``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Add``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving the collection view).</para>
            <para>During an acknowledgement change, <see cref="!:BeforeAddRemoveEventArgs&lt;TValue&gt;.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving the collection view).</para>
            <para>During an acknowledgement change, <see cref="!:BeforeAddRemoveEventArgs&lt;TValue&gt;.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_Add``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Sinks the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Sinks the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Sinks the collection's <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},System.Action{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBagEx.LogChanges(JetBrains.DataFlow.IPropertyBag,JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Logs the changes to the bag property set and the bag property values.
            </summary>
            <param name="thіs">The property.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertyEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.BeginSetValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher,``0,System.Object)">
            <summary>
            Asynhronously assigns a new value to the property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Cast``1(JetBrains.DataFlow.IUntypedProperty,JetBrains.DataFlow.Lifetime)">
            <summary>
            Casts the property value to the given type by creating a new property of that type.
            If the type of the value in the source property is wrong, an exception will be reported, and <c>Null</c> will be assigned to the target property for that period.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source property of the source type.</param>
            <param name="lifetime">Lifetime of the newly-created property.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0})">
             <summary>
             Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment goes on the same thread with the change.
             </summary>
             <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
             <param name="target">The target property.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
             <summary>
             Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment goes on the same thread with the change.
             </summary>
             <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
             <param name="target">The target property.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher,JetBrains.DataFlow.IProperty{``0})">
             <summary>
             Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment occurs on the <paramref name="dispatcher"/> thread.
             </summary>
             <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
             <param name="dispatcher">The dispatcher on which the assignment should occur.</param>
             <param name="target">The target property.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Establishes a data flow between two properties.
            Creates a <see cref="T:JetBrains.DataFlow.PropertyBinding"/> of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Establishes a data flow between two properties of different types, thru a converter.
            Creates a <see cref="T:JetBrains.DataFlow.PropertyBinding"/> of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowChangesInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Establishes a data flow of changes made to the source property between two properties.
            Does not flow a value when it is acknowledged.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowChangesInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Establishes a data flow of changed made to the source property between two properties of different types, thru a converter.
            Does not flow a value when it is acknowledged.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowIntoReadonly``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes a data flow between two properties of different types, thru a converter.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowIntoReadonly``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes a data flow between two properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowIntoViaGroupingEvent``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.GroupingEvent,System.Boolean,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes one-way frequency-limited data flow between two properties.
            The target update occurs no more often than allowed by the grouping event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowInto_Grouped``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.GroupingEvent,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes one-way frequency-limited data flow between two properties.
            The target update occurs no more often than allowed by the grouping event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Invert(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a boolean property with an inverter value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChangesAndStacktraces``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Logs the changes to the property value and appends change stacktrace
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Object)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix,
            ie prepended in square brackets to each log message, or a <see cref="T:System.Type"/> whose short name will be used.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.Util.ILogger)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.Property{``0},JetBrains.Util.ILogger)">
            <summary>
            Logs the changes to the property value. Forever. Fluent, can be applied to .ctor.
            </summary>
            <param name="property">The property.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.MakeFlag``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Func{``0,System.Boolean},System.String)">
            <summary>
            Creates a flag property out of an arbitrary property which is either <c>True</c> or <c>False</c>,
            based on the <paramref name="FCondition"/> evaluated on the live value of the <paramref name="prop"/>.
            </summary>
            <typeparam name="TValue">Type of the source property.</typeparam>
            <param name="prop">The source property.</param>
            <param name="lifetime">Lifetime for the created property and its binding to the original property.</param>
            <param name="FCondition">The condition to be evaluated on each new value of the property.</param>
            <param name="sConditionName">The name of the condition. This name is appended to the <paramref name="prop"/>'s <see cref="P:JetBrains.DataFlow.IProperty`1.Id"/> to form the new <see cref="T:JetBrains.DataFlow.PropertyId`1"/> for the resulting flag.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.MakeFlag_NotNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a flag property that indicates whether the <paramref name="prop"/> currently has a non-<c>Null</c> value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.OfType``1(JetBrains.DataFlow.IUntypedProperty,JetBrains.DataFlow.Lifetime)">
            <summary>
            Softly casts the property value to the given type by creating a new property of that type.
            If the type of the value in the source property is wrong, a <c>Null</c> will be assigned to the target property for that period.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source property of the source type.</param>
            <param name="lifetime">Lifetime synchronization policy for the two properties.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes — before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0,System.Object})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes — before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Func{``0,System.Boolean},System.Action{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property (if it passes <paramref name="FCondition">the filter</paramref>) and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes — before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Func{``0,System.Boolean},System.Action{JetBrains.DataFlow.Lifetime,``0,System.Object})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property (if it passes <paramref name="FCondition">the filter</paramref>) and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes — before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.DisposeEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Makes sure each value of the property is disposed of when it exits the property (just after the property is set to some other value).
            When the <paramref name="lifetime"/> terminates, the current value of the property is also disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue_NotNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new non-<c>Null</c> value of the property and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes — before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.SetValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,``0,System.Object)">
            <summary>
            Temporarily sets the value to the property, for the duration of the <paramref name="lifetime"/>.
            When the <paramref name="lifetime"/> ends, the original value (by the moment of the method call) is restored.
            Prevents all writes to the property while this method holds.
            </summary>
            <param name="property">The property to process.</param>
            <param name="lifetime">Defines the value duration.</param>
            <param name="value">The property value to set.</param>
            <param name="cookie">An optional readonly cookie.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.When``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,``0,System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value gets equal to <paramref name="value"/>.
            Closes the lifetime when the property value changes from <paramref name="value"/> to anything else, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="value">Value to compare <paramref name="property"/> value with.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenTrue(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value gets <c>True</c>.
            Closes the lifetime when the property value changes to <c>False</c>, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenTrueOnce(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            Execute activity once when property becomes true
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenFalseOnce(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            Execute activity once when property becomes true
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenFalse(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value gets <c>False</c>.
            Closes the lifetime when the property value changes to <c>True</c>, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Select``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.String,System.Func{``0,``1})">
            <summary>
            Creates a new property whose value is produced from the source property value.
            Analogous to the LINQ <c>Select</c> functionality.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source value.</param>
            <param name="comment">Adds a comment suffix to the Property ID.</param>
            <param name="FSelect">Selector.</param>
            <param name="lifetime">Lifetime control.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Select``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.String,System.Func{JetBrains.DataFlow.Lifetime,``0,``1})">
            <summary>
            Creates a new property whose value is produced from the source property value (allows to create lifetimed values).
            Analogous to the LINQ <c>Select</c> functionality.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source value.</param>
            <param name="comment">Adds a comment suffix to the Property ID.</param>
            <param name="FSelect">Selector.</param>
            <param name="lifetime">Lifetime control.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.TryGetPropertyType(System.Type)">
            <summary>
            When given a <see cref="T:System.Type"/> of a CLR field or property that has the <see cref="T:JetBrains.DataFlow.IProperty`1"/> type wrapping some other type, unwraps and returns the underlying type of the property (generic argument, the same as its <see cref="P:JetBrains.DataFlow.IUntypedProperty.PropertyType"/>). If the <paramref name="type"/> is not a property type, returns <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredIntoCore``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Func{JetBrains.Threading.JetDispatcher},JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
             <summary>
             Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The thread to run the assignment on is determined by the function <paramref name="FGetDispatcher"/>.
             </summary>
            <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
            <param name="FGetDispatcher">Determines the thread to use.</param>
            <param name="target">The target property.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.CreateUntypedProperty(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId,System.Object,System.Nullable{System.Boolean},JetBrains.Util.ILogger)">
            <summary>
            <para>Creates an instance of the <see cref="T:JetBrains.DataFlow.Property`1"/> class in a context where you cannot have generic specialization to its type and have to operate the <see cref="T:JetBrains.DataFlow.IUntypedProperty"/> interface.</para>
            <para>For help on parameters, see the <see cref="T:JetBrains.DataFlow.Property`1"/> ctor parameters.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.SetValueUnderLifetime``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Func{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
                <para>Sets a value to the property. The value has a lifetime until it's removed from the property.</para>
                <para>You're called a function with the prospected value lifetime, to produce the value object.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.PushForEachValue``1(JetBrains.DataFlow.IProperty{``0},System.Func{``0,System.IDisposable})">
            <summary>
            Executes a pair of actions for each new value of the <paramref name="property"/>.
            For each new value of the property, the <paramref name="handler"/> is executed.
            Its return value is disposed of when the property looses the value for each it were executed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.PushValue``1(JetBrains.DataFlow.IProperty{``0},``0,System.Object)">
            <summary>
            Pushes the given value into the property when entering the try-finally brackets, pops (restores the former value) when exiting, which happens when the return value gets disposed of.
            The in-brackets writes are not handled.
            </summary>
            <param name="property">The property to process.</param>
            <param name="value">In-brackets property value.</param>
            <param name="cookie">An optional readonly cookie.</param>
            <returns>An instance to dispose of when leaving the brackets.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.PushValue``1(JetBrains.DataFlow.IProperty{``0},``0)">
            <summary>
            Pushes the given value into the property when entering the try-finally brackets, pops (restores the former value) when exiting, which happens when the return value gets disposed of.
            The in-brackets writes are not handled.
            </summary>
            <param name="property">The property to process.</param>
            <param name="value">In-brackets property value.</param>
            <returns>An instance to dispose of when leaving the brackets.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.FlowInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Establishes a data flow between two properties.
            Creates a <see cref="T:JetBrains.DataFlow.PropertyBinding"/> of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/> type.
            Returns a cookie for terminating the flow.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.FlowInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Establishes a data flow between two properties of different types, thru a converter.
            Creates a <see cref="T:JetBrains.DataFlow.PropertyBinding"/> of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/> type.
            Returns a cookie for terminating the flow.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.LogChanges``1(JetBrains.DataFlow.IProperty{``0},System.String)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.LogChanges``1(JetBrains.DataFlow.IProperty{``0},System.Object)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix, ie prepended in square brackets to each log message, or a <see cref="T:System.Type"/> whose short name will be used.</param>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertySignalEx">
            <summary>
            Extension methods to <see cref="T:JetBrains.DataFlow.ISignal`1"/> specific to the signals of the <see cref="T:JetBrains.DataFlow.IProperty`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_FallingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Executes the handler whenever the property value falls.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or “unknown” (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes to <c>Null</c>, or when the lifetime ends while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could deactivate something if an option is turned off or the lifetime of your component ends.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_FallingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Executes the handler whenever the property value falls.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or “unknown” (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes to <c>Null</c>, or when the lifetime ends while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could deactivate something if an option is turned off or the lifetime of your component ends.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_FallingFrontHasNew(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{System.Boolean}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Executes the handler whenever the property value falls (excluding the case when we're acknowleding the last value when unadvising the property change signal).</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or “unknown” (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes to <c>Null</c> (but not when the lifetime ends while a property value is non-<c>Null</c>).</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasOld``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has an <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old">old value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the beginning of the lifetime, when there's only the new value of the property, but no old one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasOld``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has an <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old">old value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the beginning of the lifetime, when there's only the new value of the property, but no old one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NewNotNull``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property, and it is non-<c>Null</c>.</para>
            <para>This filter skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one; plus any change whose new value is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NewNotNull``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property, and it is non-<c>Null</c>.</para>
            <para>This filter skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one; plus any change whose new value is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the value already in the property.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the value already in the property.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_OldNotNull``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="!:BeforePropertyChangedEventArgs&lt;x&gt;.Old">old value</see> for the property, and it is non-<c>Null</c>.</para>
            <para>This filter skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one; plus any change whose new value is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="!:BeforePropertyChangedEventArgs&lt;x&gt;.New">new value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            <para>Executes the handler whenever the property value raises.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or “unknown” (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes from <c>Null</c>, or when the lifetime starts while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could activate something if an option is turned on or the lifetime of your component begins.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Executes the handler whenever the property value raises.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or “unknown” (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes from <c>Null</c>, or when the lifetime starts while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could activate something if an option is turned on or the lifetime of your component begins.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_When``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,``0,System.Action)">
            <summary>
            Invokes the handler for specific property values only. Filters down the <see cref="!:Advise_HasNew&lt;TValue&gt;(JetBrains.DataFlow.ISignal&lt;JetBrains.DataFlow.PropertyChangedEventArgs&lt;TValue&gt;&gt;,ObsoleteLifetimeAndDefinitionAtTheSameTime,System.Action)"/> invocations to only those whose new-value is <paramref name="valueWhen"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_When``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Invokes the handler for specific property values only. Filters down the <see cref="!:Advise_HasNew&lt;TValue&gt;(JetBrains.DataFlow.ISignal&lt;JetBrains.DataFlow.PropertyChangedEventArgs&lt;TValue&gt;&gt;,ObsoleteLifetimeAndDefinitionAtTheSameTime,System.Action&lt;JetBrains.DataFlow.PropertyChangedEventArgs&lt;TValue&gt;&gt;)"/> invocations to only those whose new-value fits the <paramref name="FFilter"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action)">
            <summary>
            Invokes the handler on the raising front of the boolean property value, that is, when anything changes to <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            Invokes the handler on the raising front of the boolean property value, that is, when anything changes to <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_When``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Invokes the handler for specific property values only. Filters down the <see cref="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})"/> invocations to only those whose new-value passes the <paramref cref="!:filter"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ISignalEx">
            <summary>
            Extension method helpers for the data flow classes related to signals.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Advise``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            Advises the signal event for the duration of the <paramref name="lifetime"/> so that the <paramref name="handler"/> is called when the signal fires.
            This is an overload for a handler that does not need event arguments.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Advise_InOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},JetBrains.DataFlow.Lifetime,System.Func{``0,``1})">
            <summary>
            A helper for sinking IN-OUT events. Gets just the IN-argument for input, returns the OUT-argument.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Advise_Out``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.OutEventArgs{``0}},JetBrains.DataFlow.Lifetime,System.Func{``0})">
            <summary>
            A helper for sinking OUT events. Returns the OUT-argument.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0,``1)">
            <summary>
            For a signal that has an in-out value, fires the signal and collects the out-value.
            </summary>
            <remarks>Method name is not <c>Fire</c> because otherwise the <see cref="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0,``1)"/> overload conflicts with <see cref="M:JetBrains.DataFlow.IUntypedSignal.Fire(System.Object,System.Object)"/>.</remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.BeginFire(JetBrains.DataFlow.ISimpleSignal,JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher)">
            <summary>
            <para>Asynchronously fires the signal on the thread identified by the dispatcher.</para>
            <para>The deferred firing is canceled if the lifetime terminates before it is invoked.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            <para>Asynchronously fires the signal on the thread identified by the dispatcher.</para>
            <para>The deferred firing is canceled if the lifetime terminates before it is invoked.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher,``0,System.Object)">
            <summary>
            <para>Asynchronously fires the signal on the thread identified by the dispatcher.</para>
            <para>The deferred firing is canceled if the lifetime terminates before it is invoked.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Fire``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.OutEventArgs{``0}})">
            <summary>
            For a signal that has an out-value only, fires the signal and collects the out-value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0)">
            <summary>
            For a signal that has an in-out value, fires the signal and collects the out-value.
            </summary>
            <remarks>Method name is not <c>Fire</c> because otherwise the <see cref="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0,``1)"/> overload conflicts with <see cref="M:JetBrains.DataFlow.IUntypedSignal.Fire(System.Object,System.Object)"/>.</remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowDeferredInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a one-way binding between two signals, deferring the action until execution gets off stack and collecting all the signals that happen within that time span.
            </summary>
            <param name="source">The source signal.</param>
            <param name="lifetime">Lifetime for the flow set-up. If there are any pending firings to flow to the target when the lifetime terminates, such firings are dropped.</param>
            <param name="target">The target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISignal{``0})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto``2(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISignal{``1},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent signal.</param>
            <param name="FConvert">Function that converts the high value of the source signal to value for the target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto(JetBrains.DataFlow.ISimpleSignal,JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two simple signals.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Logs the event firings and the payload of the event.
            </summary>
            <param name="thіs">The event.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,System.Object)">
            <summary>
            Logs the event firings and the payload of the event.
            </summary>
            <param name="thіs">The event.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix, ie prepended in square brackets to each log message, or a <see cref="T:System.Type"/> whose short name will be used.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.Util.ILogger)">
            <summary>
            Logs the event firings and the payload of the event.
            </summary>
            <param name="thіs">The event.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="logger">The logger which serves as the logging context. Signal name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.Signal{``0},JetBrains.Util.ILogger)">
            <summary>
            Logs the event firings and the payload of the event. Forever. Fluent, can be used with the .ctor.
            </summary>
            <param name="thіs">The event.</param>
            <param name="logger">The logger which serves as the logging context. Signal name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings(JetBrains.DataFlow.SimpleSignal,JetBrains.Util.ILogger)">
            <summary>
            Logs the event firings and the payload of the event. Forever. Fluent, can be used with the .ctor.
            </summary>
            <param name="thіs">The event.</param>
            <param name="logger">The logger which serves as the logging context. Signal name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.Advise``1(JetBrains.DataFlow.ISignal{``0},System.Action)">
            <summary>
            Advises the signal event so that the <paramref name="handler"/> is called when the signal fires.
            Unadvises when the return value is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.Advise_InOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},System.Func{``0,``1})">
            <summary>
            A helper for sinking IN-OUT events. Gets just the IN-argument for input, returns the OUT-argument.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.Advise``1(JetBrains.DataFlow.ISignal{``0},System.Action{``0})">
            <summary>
            Advises the signal event so that the <paramref name="handler"/> is called when the signal fires.
            Unadvises when the return value is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.BeginFire(JetBrains.DataFlow.ISimpleSignal,JetBrains.Threading.JetDispatcher)">
            <summary>
            Asynhronously fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            Asynhronously fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Threading.JetDispatcher,``0,System.Object)">
            <summary>
            Asynhronously fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowDeferredInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a one-way binding between two signals, deferring the action until execution gets off stack and collecting all the signals that happen within that time span.
            </summary>
            <param name="source">The source signal.</param>
            <param name="target">The target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISignal{``0})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto``2(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISignal{``1},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent signal.</param>
            <param name="converter">Function that converts the high value of the source signal to value for the target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto(JetBrains.DataFlow.ISimpleSignal,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two simple signals.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyChangeEventArgsEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangeEventArgsEx.GetNewOrNull``1(JetBrains.DataFlow.PropertyChangedEventArgs{``0})">
            <summary>
            <para>If there's the new value in the change (<see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/>), returns it.</para>
            <para>Otherwise, returns <c>Null</c>.</para>
            <para>When the lifetime is terminated, an acknowledgement change is fired to acknowledge your event sink that it's being disconnected from the last value of the property. In this case there's no new value in the change.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangeEventArgsEx.GetOldOrNull``1(JetBrains.DataFlow.PropertyChangedEventArgs{``0})">
            <summary>
            <para>If there's the old value in the change (<see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/>), returns it.</para>
            <para>Otherwise, returns <c>Null</c>.</para>
            <para>When you start sinking the property change events, an acknowledgement change is fired to acknowledge your event sink with the current value of the property, as if it's just being set. In this case there's no old value in the change.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangeEventArgsEx.IsRaising(JetBrains.DataFlow.PropertyChangedEventArgs{System.Boolean})">
            <summary>
            Gets whether the boolean property value is raising (changing from <c>False</c> or “unknown” to <c>True</c>).
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyValidationException">
            <summary>
            Thrown when a suggested property value fails to pass the validation.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ValidationException">
            <summary>
            Thrown when a suggested value fails to pass the validation.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyValidationException.Property">
            <summary>
            The property that was attempted to be changed.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyValidationException.Value">
            <summary>
            The attempted new value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyValidator">
            <summary>
            Validates properties by preventing certain values from being assigned to the property.
            Note that for the validator to attach, the original value must pass validation.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateEnumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates the validtor. It's held by a reference from the property ever since.
            Attaches a validator to the property whose type is an <see cref="T:System.Enum"/>.
            Ensures that the value belongs to the enum values list.
            </summary>
            <param name="thіs">The proeprty to validate. Must be of an enum-based type.</param>
            <param name="lifetime">The lifetime for the validation constraint.</param>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateMaximumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,``0)">
            <summary>
            Compares the suggested property values with the maximum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateMinimumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,``0)">
            <summary>
            Compares the suggested property values with the minimum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateNotEmptyValidator(JetBrains.DataFlow.IProperty{System.String},JetBrains.DataFlow.Lifetime)">
            <summary>
            Enforces non-empty values for the string property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateReadonlyValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly property. All the legitimate setters must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateThreadAffinityValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Threading.Thread)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the given <paramref name="thread"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateThreadAffinityValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher)">
            <summary>
            Ensures the <paramref name="thіs"/> is modified only on the <paramref name="dispatcher"/>'s thread.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.Freeze``1(JetBrains.DataFlow.IProperty{``0},System.String)">
            <summary>
            Makes the property “Frozen”, which means its value cannot be changed from now on.
            Allows to specify a custom message.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.Freeze``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Makes the property “Frozen”, which means its value cannot be changed from now on.
            Allows to specify a custom message.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyValidatorFluent">
            <summary>
            Fluent-Api property validators from <see cref="T:JetBrains.DataFlow.PropertyValidator"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.CoerceToRange``1(JetBrains.DataFlow.Property{``0},``0,``0)">
            <summary>
            Coerces the property values so that they fall into the given range, inclusive. No exceptions are thrown. The soft version of <see cref="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotOutside``1(JetBrains.DataFlow.Property{``0},``0,``0)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureEnum``1(JetBrains.DataFlow.Property{``0})">
            <summary>
            <see cref="M:JetBrains.DataFlow.PropertyValidator.CreateEnumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureEnum``1(JetBrains.DataFlow.IProperty{``0})">
            <summary>
            <see cref="M:JetBrains.DataFlow.PropertyValidator.CreateEnumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureInitonly``1(JetBrains.DataFlow.Property{``0})">
            <summary>
            Ensures that only one assignment to the property is allowed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotAbove``1(JetBrains.DataFlow.Property{``0},``0)">
            <summary>
            Compares the suggested property values with the maximum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotBelow``1(JetBrains.DataFlow.Property{``0},``0)">
            <summary>
            Compares the suggested property values with the minimum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotOutside``1(JetBrains.DataFlow.Property{``0},``0,``0)">
            <summary>
            Ensures that property values fall into the given range, inclusive. Throws if values out of range. The hard version of <see cref="M:JetBrains.DataFlow.PropertyValidatorFluent.CoerceToRange``1(JetBrains.DataFlow.Property{``0},``0,``0)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureReadonly``1(JetBrains.DataFlow.Property{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly property. All the legitimate setters must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureReadonly``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly property. All the legitimate setters must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureThisThread``1(JetBrains.DataFlow.Property{``0})">
            <summary>
            Ensures the <paramref name="property"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureThisThread``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="property"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.RegistryValueProperty">
            <summary>
            Creates <see cref="T:JetBrains.DataFlow.IProperty`1"/> that passively reflect the Registry values. Note that currently they do not track Registry changes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.RegistryValueProperty.CreatePassive``1(JetBrains.DataFlow.Lifetime,Microsoft.Win32.RegistryKey,System.String,System.String,``0)">
            <summary>
            Creates a property that's passively mirrored into Registry (does not listen to Registry changes).
            Note that the Registry key is not kept open between the read/write sessions.
            </summary>
            <typeparam name="TValue">Value type.</typeparam>
            <param name="keyRoot">The root key, eg <see cref="F:Microsoft.Win32.Registry.ClassesRoot"/>.</param>
            <param name="sKeyPath">The relative path from the root key to the key that contains the data we're binding to.</param>
            <param name="sDataName">Name of the data. Null for the default value of the key.</param>
            <param name="defvalue">Default value for the data when reading it from Registry initially, in case it's missing.</param>
        </member>
        <member name="T:JetBrains.DataFlow.SignalValidator">
            <summary>
            Validations for signal firings.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureReadonly``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly signal. All the legitimate <see cref="M:JetBrains.DataFlow.ISignal`1.Fire(`0,System.Object)"/> calls must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureReadonly(JetBrains.DataFlow.SimpleSignal,JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly signal. All the legitimate <see cref="M:JetBrains.DataFlow.ISignal`1.Fire(`0,System.Object)"/> calls must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureThisThread``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="signal"/> is fired only on the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureThisThread(JetBrains.DataFlow.SimpleSignal,JetBrains.DataFlow.Lifetime)">
            <summary>
            Ensures the <paramref name="signal"/> is fired only on the thread this function was called on.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IHaveUntypedProperty">
            <summary>
            An interface for getting <see cref="T:JetBrains.DataFlow.IUntypedProperty"/> from a <see cref="T:JetBrains.DataFlow.IProperty`1"/> in an untyped manner.
            Allows to get the property value in a nongeneric method (e.g. in property value serializer).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IHaveUntypedProperty.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IListEvents`1">
            <summary>
            A list that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">List values type.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.IListEvents`1.Modify(JetBrains.DataFlow.AddRemove,`0,System.Int32,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="P:JetBrains.DataFlow.IListEvents`1.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove. When doing the remove operation, this parameter is ignored and the index is used instead.</param>
            <param name="index">The index at which the modification should occur.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IListEvents`1.Modify(JetBrains.DataFlow.AddRemove,System.Func{`0},System.Int32,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="P:JetBrains.DataFlow.IListEvents`1.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="funcGetItemIfAdding">A function that is called only when doing the <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation and produces the new item to be added to the list. This allows to create a new item when pumping from one collection to another with creating the wrappers simultaneousely.</param>
            <param name="index">The index at which the modification should occur.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="P:JetBrains.DataFlow.IListEvents`1.AddRemove">
            <summary>
            Fires when an item is added or removed to your view on the collection.
            Throwing an exception does not prevent the item from being added or other handlers from being called.
            The event supports acknowledgement, which means that when you advise the event, all of the items currently in collection come into your view on the collection, so the add is fired for each. Similarly, remove is fired when you unadvise and all of the elements go away from your view on the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IListEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added or removed.
            To prevent the add/remove operation, set <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> (decline the operation silently) or throw an exception (the exception is let out to the caller). 
            After the first handler to cancel the operation, the remaining handlers may not be called.
            No <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> are guaranteed to be executed if the operation is cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Infra.SignalWithDelegates`1">
            <summary>
            A signal-inheritor that exposes the signal's virtual methods as delegates.
            The signal has virtual methods instead of delegates because it's cheaper to call the virtual method, which is essential for the property case, for example. Less performance-critical scenarios (like collections) would use delegates instead of inheriting custom classes.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SignalWithDelegates`1.OnAfterAdvise(System.Action{`0})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SignalWithDelegates`1.OnAfterUnadvise(System.Action{`0})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SignalWithDelegates`1.OnBeforeAdvise(System.Action{`0})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SignalWithDelegates`1.AfterAdviseHandler">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SignalWithDelegates`1.AfterUnadviseHandler">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SignalWithDelegates`1.BeforeAdviseHandler">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.InOutEventArgs`2">
            <summary>
            An event arguments class with one typed constant value, plus one typed mutable value that can be changed by any consumer.
            </summary>
            <typeparam name="TIn">Type of the incoming value that is constant and cannot be changed.</typeparam>
            <typeparam name="TOut">Type of the outgoing value that is intended to be set by the event sink.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.InOutEventArgs`2.#ctor(`0,`1)">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.Out"/> parameter set to its predefined value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.InOutEventArgs`2.#ctor(`0)">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.Out"/> parameter set to <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.InOutEventArgs`2.In">
            <summary>
            Gets the event data specified by the event source.
            Generally, it specifies which/how the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.Out"/> data should be filled.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.InOutEventArgs`2.Out">
            <summary>
            Data to be provided by the event sink, based on the event semantics and the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.In"/> value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DependencyPropertyChangeSink`1">
            <summary>
            Allows to know when a dependency property value changes.
            This is required for a two-way bridge between the Data Flow Properties and Dependency Properties.
            We cannot easily get events for changes in dependency objects, but if we implement our own dependency object, we can bind it to the object of interest and get events when it changes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyChangeSink`1.CheckDependencyPropertyType(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Boolean)">
            <summary>
            Ensures that the property is of type <typeparamref name="TValue"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyChangeSink`1.CreatePropertyId(System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary>
            Creates a new Data Flow Property ID, based on the dependency property identity.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.DependencyPropertyChangeSink`1.Property">
            <summary>
            Gets the Data Flow Property that mirrors the outer dependency property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.DependencyPropertyChangeSink`1.Value">
            <summary>
            An infrastructure property that exposes the bridging dependency property.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DependencyPropertyWrapper">
            <summary>
            Wraps a <see cref="T:System.Windows.DependencyProperty"/> into an <see cref="T:JetBrains.DataFlow.IProperty`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.Create``1(JetBrains.DataFlow.Lifetime,System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Boolean)">
            <summary>
            Creates an <see cref="T:JetBrains.DataFlow.IProperty`1"/> that is synchronized to an Avalon property.
            </summary>
            <typeparam name="TValue">Type of the property value. Must coincide to the dependency property type.</typeparam>
            <param name="lifetime"></param>
            <param name="dependencyobject">The owning instance for the dependency property.</param>
            <param name="dependencyproperty">The property identifier.</param>
            <param name="bSinkEvents">Whether to sink the <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> events from the owning object about the updates of the requested property.</param>
            <returns>The wrapping property.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.Create``1(JetBrains.DataFlow.Lifetime,System.Windows.UIElement,System.Windows.DependencyProperty,System.Windows.RoutedEvent)">
            <summary>
            Creates an <see cref="T:JetBrains.DataFlow.IProperty`1"/> that is synchronized to an Avalon property.
            </summary>
            <typeparam name="TValue">Type of the property value. Must coincide to the dependency property type.</typeparam>
            <param name="lifetime"></param>
            <param name="owner">The owning instance for the dependency property.</param>
            <param name="dependencyproperty">The property identifier.</param>
            <param name="event">If not <c>Null</c>, the specified event will be sinked from the <paramref name="owner"/> object.</param>
            <returns>The wrapping property.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.FlowInto``1(JetBrains.DataFlow.IProperty{``0},System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary>
            Flows DataFlow property values into a dependency property.
            </summary>
            <param name="propSource">The source DataFlow property.</param>
            <param name="doTarget">The dependency object that owns the property container.</param>
            <param name="dpropTarget">The target property identifier for the property container.</param>
            <returns>Undo token for the binding.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.FlowInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary>
            Flows DataFlow property values into a dependency property.
            </summary>
            <param name="propSource">The source DataFlow property.</param>
            <param name="lifetime">Lifetime for the flow.</param>
            <param name="doTarget">The dependency object that owns the property container.</param>
            <param name="dpropTarget">The target property identifier for the property container.</param>
            <returns>Undo token for the binding.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.FlowInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Func{``0,``1})">
            <summary>
            Flows DataFlow property values into a dependency property.
            </summary>
            <param name="propSource">The source DataFlow property.</param>
            <param name="lifetime">Lifetime for the flow.</param>
            <param name="doTarget">The dependency object that owns the property container.</param>
            <param name="dpropTarget">The target property identifier for the property container.</param>
            <param name="FConvert">Applies conversion.</param>
            <returns>Undo token for the binding.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.BindDataFlowToDependency``1(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary>
            Binds two properties in the forward direction.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DependencyPropertyWrapper.BindDependencyToDataFlow_RoutedEvent``1(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Windows.UIElement,System.Windows.DependencyProperty,System.Windows.RoutedEvent)">
            <summary>
            Binds two properties in the backward direction.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IProperty`1">
            <summary>
            A property that tracks the changes, validates new values being assigned, and notifies of the change.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.GetValue">
            <summary>
            Gets the property value.
            </summary>
            <returns>The current property value, whose nullability depends on <see cref="T:System.Nullable"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="T:System.Nullable"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.SetValue(`0)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="T:System.Nullable"/>.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="T:System.Nullable"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.Value">
            <summary>
            Gets or sets the value by wrapping the <see cref="M:JetBrains.DataFlow.IProperty`1.GetValue"/> and <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0)"/> calls.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.IsNullValueAllowed">
            <summary>
            Gets whether the property can store NULL values of reference types and zero values of value types.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBag.GetOrCreateProperty``1(JetBrains.DataFlow.PropertyId{``0},``0,System.Nullable{System.Boolean})">
            <summary>
            Creates a property in the bag, or picks an existing one.
            </summary>
            <param name="id">An identifier for the property.</param>
            <param name="defaultvalue">Default value to assign to the property initially.</param>
            <param name="isNullValueAllowed">Whether <c>Null</c> values are accepted by the property.</param>
            <returns>The newly-created property, or an existing one, if available.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBag.Remove``1(JetBrains.DataFlow.PropertyId{``0})">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBag.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertyBinding`2">
            <summary>
            Binds together two <see cref="T:JetBrains.DataFlow.IProperty`1"/>s.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding`2.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding`2.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.Direction">
            <summary>
            Gets the binding direction.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertyBinding">
            <summary>
            A non-generic version of the <see cref="T:JetBrains.DataFlow.IPropertyBinding`2"/> interface for automated bulk processing.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding.Direction">
            <summary>
            Gets the binding direction.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding.Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding.Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IUntypedProperty">
            <summary>
            A non-generic version of the <see cref="T:JetBrains.DataFlow.IProperty`1"/> interface for automated bulk processing.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedProperty.GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedProperty.SetValue(System.Object,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed">
            <summary>
            Gets whether the property can store NULL values of reference types and zero values of value types.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.PropertyType">
            <summary>
            Gets the type of the generic property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.AsTyped">
            <summary>
            Gets the generic version of the API to this object (<see cref="T:JetBrains.DataFlow.IProperty`1"/> specialized with <see cref="P:JetBrains.DataFlow.IUntypedProperty.PropertyType"/>).
            </summary>
        </member>
        <member name="E:JetBrains.DataFlow.IUntypedProperty.Disposed">
            <summary>
            Fires when the property disposes.
            This event does not acknowlegde subscriptions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedPropertyBag.GetOrCreateProperty(JetBrains.DataFlow.PropertyId,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Creates a property in the bag, or picks an existing one.
            The type is inferred from the generic data constant type <see cref="T:JetBrains.DataFlow.PropertyId`1"/>.
            </summary>
            <param name="id">An identifier for the property.</param>
            <param name="defaultvalue">Default value to assign to the property initially.</param>
            <param name="isNullValueAllowed"></param>
            <returns>The newly-created property, or an existing one, if available.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedPropertyBag.Remove(JetBrains.DataFlow.PropertyId)">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable">
            <summary>
            Serves two things: converts an <see cref="T:System.Action"/> into an <see cref="T:System.IDisposable"/>, and allows to replace a <c>try…finally</c> construct with a <c>using</c>, which keeps the opening/closing actions together.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.Empty">
            <summary>
            A disposable class that does nothing on <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateBracket(System.Action,System.Action,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="opening"/> action is executed immediately, the <paramref name="closing"/> one is executed when the return value is disposed of.</para>
            <para>The disposal is optional, the <paramref name="closing"/> action will not be executed unless you explicitly call <see cref="M:System.IDisposable.Dispose"/>.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="opening">An action that opens the two-action bracket. Executes immediately on enter.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="trapExceptions">Whethe we must catch exceptions in <paramref name="opening"/> and <paramref name="closing"/> and log them or throw futher</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Disposal is optional.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateCompositeDisposable``1(System.Func{``0}[])">
            <summary>
            Emulates behavior of nested disposables with proper exception throwing, so 
            <code>
            using (CreateCompositeDisposable(() => Cookie1(), () => Cookie2()))
            {
               ...
            }
            </code>
            
            is analogous to 
            
            <code>
            using (Cookie1()) 
            {
              using (Cookie2()) 
              {
               ...
              }
            }
            </code>
            </summary>
            
            <typeparam name="T">inheritor of disposable for client code simplification</typeparam>
            <param name="disposables">functions that returns disposables</param>
            <returns>Disposable that is analogous to nesting disposables in arguments</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateAction(System.Action)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="closing"/> action is executed when the return value is disposed of.</para>
            <para>The disposal is optional, the <paramref name="closing"/> action will not be executed unless you explicitly call <see cref="M:System.IDisposable.Dispose"/>.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Disposal is optional.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateAction_FinalizableFreeThreaded(System.String,System.Action,System.String,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="closing"/> action is executed when the return value is disposed of.</para>
            <para>The disposal is mandatory, an exception is reported if the <paramref name="closing"/> action is executed by the finalizer.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="id">Identifies the activity or its owner in case it fails or gets into the finalizer.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="messageFinalization">Optional message to throw out as an exception in case of a missed dispose. If omitted, the default exception will be issued, including the object <paramref name="id"/> in its text. If you replace the message, it's up to you whether to include the identifier with the message text.</param>
            <param name="saveCtorCallStack">Save the creating call stack and include it into exception details in case of a missed dispose.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateBracket_FinalizableFreeThreaded(System.String,System.Action,System.Action,System.String,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="opening"/> action is executed immediately, the <paramref name="closing"/> one is executed when the return value is disposed of, or when the finalizer for the object is called.</para>
            <para>The disposal is mandatory, an exception is reported if the <paramref name="closing"/> action is executed by the finalizer.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="id">Identifies the activity or its owner in case it fails or gets into the finalizer.</param>
            <param name="opening">An action that opens the two-action bracket. Executes immediately on enter.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="messageFinalization">Optional message to throw out as an exception in case of a missed dispose. If omitted, the default exception will be issued, including the object <paramref name="id"/> in its text. If you replace the message, it's up to you whether to include the identifier with the message text.</param>
            <param name="saveCtorCallStack">Save the creating call stack and include it into exception details in case of a missed dispose.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateBracket_FinalizableSingleThreaded(System.String,System.Action,System.Action,System.String,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="opening"/> action is executed immediately, the <paramref name="closing"/> one is executed when the return value is disposed of, or when the finalizer for the object is called.</para>
            <para>The disposal is mandatory, an exception is reported if the <paramref name="closing"/> action is executed by the finalizer, on the same thread as the opening action, if possible.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="id">Identifies the activity or its owner in case it fails or gets into the finalizer.</param>
            <param name="opening">An action that opens the two-action bracket. Executes immediately on enter.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="messageFinalization">Optional message to throw out as an exception in case of a missed dispose. If omitted, the default exception will be issued, including the object <paramref name="id"/> in its text. If you replace the message, it's up to you whether to include the identifier with the message text.</param>
            <param name="saveCtorCallStack">Save the creating call stack and include it into exception details in case of a missed dispose.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Must be disposed of.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.EmptyDisposable">
            <summary>
            An <see cref="T:System.IDisposable"/> stub.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.FinalizableDisposable">
            <summary>
            An <see cref="T:System.IDisposable"/> adapter for an <see cref="T:System.Action"/> (or a pair of actions) that supports finalization.
            Must be disposed of, otherwise, the finalizer will report an error and invoke the closing action.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.NonFinalizableDisposable">
            <summary>
            An <see cref="T:System.IDisposable"/> adapter for an <see cref="T:System.Action"/> (or a pair of actions) that does not support finalization.
            Nothing happens if the object is not disposed of.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.myId">
            <summary>
            Identifies the owner of a finalizable object.
            For non-finalizables this is optional (reverts to the default name).
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.myOpeningStackTrace">
            <summary>
            Optionally, captures the originating stack trace for the debugging needs.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.#ctor(System.String,System.Action,System.Action,System.Boolean,System.Boolean)">
            <summary>
            Defines the opening and closing bracket actions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.Close">
            <summary>
            Exec the closing part.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.Open(System.Action)">
            <summary>
            Exec the opening part.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.FinalizableDisposable.myDispatcher">
            <summary>
            Non-Null if need to marshal from dtor.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinalizableDisposable.#ctor(System.String,System.Action,System.Action,System.Boolean,System.Boolean,System.String,System.Boolean)">
            <summary>
            Defines the opening and closing bracket actions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinalizableDisposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.FinallyException">
            <summary>
            An exception thrown from the <see cref="T:JetBrains.DataFlow.Disposable"/> class, or any other finalizer representing a missed <see cref="M:System.IDisposable.Dispose"/> or some other problem in dispose.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.FinallyException.Id">
            <summary>
            ID of the object that caused the exception.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinallyException.LogMissedDispose(System.String,System.String,System.String)">
            <summary>
            Logs the error of a missed or failed dispose into the <see cref="T:JetBrains.Util.Logging.Logger"/>
            with <see cref="M:JetBrains.Util.Logging.Logger.LogException(System.Exception)"/>.
            </summary>
            <param name="id">The failed object identity.</param>
            <param name="message">The failure explanation message.</param>
            <param name="sOriginatingStackTrace">The stack trace where the object were created, if available.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinallyException.LogMissedDispose(System.String)">
            <summary>
            Logs the error of a missed or failed dispose into the <see cref="T:JetBrains.Util.Logging.Logger"/> with <see cref="M:JetBrains.Util.Logging.Logger.LogException(System.Exception)"/>.
            </summary>
            <param name="id">The failed object identity.</param>
        </member>
        <member name="P:JetBrains.DataFlow.Disposable.FinallyException.StackTrace">
            <summary>
            Gets a string representation of the frames on the call stack at the time the current exception was thrown.
            </summary>
            
            <returns>
            A string that describes the contents of the call stack, with the most recent method call appearing first.
            </returns>
            <filterpriority>2</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*" /></PermissionSet>
        </member>
        <member name="T:JetBrains.DataFlow.EternalLifetime">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect.</para>
            <para>Do not call <see cref="M:JetBrains.DataFlow.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>
            <para>As <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> requires a parent lifetime, the lifetime that has no parent is rooted under <see cref="T:JetBrains.DataFlow.EternalLifetime"/>. Thus, this eternal lifetime is the parent of all the other lifetimes.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.EternalLifetime.Instance">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect. Its <see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> always yields <c>False</c>.</para>
            <para>Do not call <see cref="M:JetBrains.DataFlow.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>
            <para>As <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> requires a parent lifetime, the lifetime that has no parent is rooted under <see cref="T:JetBrains.DataFlow.EternalLifetime"/>. Thus, this eternal lifetime is the parent of all the other lifetimes.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.EternalLifetime.Definition">
            <summary>
            <para>The definition of the <see cref="P:JetBrains.DataFlow.EternalLifetime.Instance">eternal lifetime</see>.</para>
            <para>Calling <see cref="M:JetBrains.DataFlow.LifetimeDefinition.Terminate"/> on such a definition is allowed, but has no effect. Its <see cref="P:JetBrains.DataFlow.LifetimeDefinition.IsTerminated"/> always yields <c>False</c>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Lifetime">
            <summary>
            <para>Represents the lifetime of the objects which have an explicit span of life and have actions to be executed upon termination. In that, replaces the <see cref="T:System.IDisposable"/> pattern.</para>
            <para>Objects get their lifetime in constructor and schedule termination actions on it. Instead of calling <see cref="M:System.IDisposable.Dispose"/>, the owner of the object terminates the lifetime it has given to the object with <see cref="M:JetBrains.DataFlow.LifetimeDefinition.Terminate"/>.</para>
            <para> If a function gets lifetime in parameters, the lifetime defines the duration of the effect of the function. For instance, adding an item to the collection under a lifetime means the item should be reclaimed from the collection when the lifetime ends. It is highly recommended to introduce lifetimed functions to APIs instead of pairing <c>Register</c>-<c>Unregister</c> methods, because this has far better guarantees on proper pairing of the activities on part of API users.</para>
            <para>To create a lifetime, use <see cref="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.ILogger)"/> or its overloads. Usually you should have a parent lifetime (component lifetime, etc) to pass in. You get the <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> object which means that you own this lifetime and can terminate it at your discretion. Take the lifetime itself out of it and pass to owned objects so that they were bound to your lifetime, but could not end it prematurely. In the rare cases when the child object might have its own lifetime considerations (i. e. a user-closeable non-modal dialog), pass the lifetime definition and be ready to handle its termination by the child object.</para>
            <para>If you need a function-scoped lifetime, like the <c>using{}</c> construct for <see cref="T:System.IDisposable"/>, use the <see cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})"/> method.</para>
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.OptionThrowOnSchedullingInTerminated">
            <summary>
            Whether to throw if something it being scheduled on a terminated lifetime.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.OptionRevertSchedulledInTerminated">
            <summary>
            If the actions scheduled on a terminated lifetime should be executed immediately (for actions; brackets are just ignored; disposes are disposed; etc).
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.myItems">
            <summary>
            Stores the items to execute upon termination.
            Access must be synchronized thru <see cref="F:JetBrains.DataFlow.Lifetime.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.myLogger">
            <summary>
            Logging facility for issues reported by this lifetime.
            For example, exceptions in lifetime termination activities should not prevent the rest of activities from being executed; such exceptions are reported to the logging facility.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddDispose(System.IDisposable)">
            <summary>
             <para>Schedules an <see cref="T:System.IDisposable"/> object to be disposed of when the lifetime gets terminated.</para>
             <para>Upon termination, scheduled activities are executed in the reverse order (LIFO).</para>
             <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.ReportTerminatedLifetime(System.String)">
            <summary>
            Throws an exception reporting that we're attempting to schedule on an already-terminated lifetime.
            Adds lifetime ID if available.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddAction(System.Action)">
            <summary>
             <para>Schedules an <see cref="T:System.Action"/> to be executed of when the lifetime gets terminated.</para>
             <para>Upon termination, scheduled activities are executed in the reverse order (LIFO).</para>
             <para>Fluent.</para>
            </summary>
             <remarks>
             <para>Throws an exception if the lifetime has already been terminated.</para>
             <para>Thus, take care in free-threaded scenarios: the lifetime might get terminated between your check for <see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> and this method's execution.</para>
             <para>For free-threaded code, you should either use the <see cref="T:JetBrains.Util.Threading.SynchronizedLifetime"/> pattern (preferred), or try creating a nested lifetime with <see cref="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.ILogger)"/> instead, doing all the sensitive operations in its atomic function parameter. This way the atomic action will either be added to a lifetime in a safe way, or executed immediately if it's been terminated already.</para>
             </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddBracket(System.Action,System.Action)">
            <summary>
             <para>Opens a bracket of actions on the lifetime. The opening one is executed immediately, and the closing one executes when the lifetime gets terminated.</para>
             <para>All of the brackets added on the same lifetime are properly nested, as if on a stack (LIFO).</para>
             <para>Fluent.</para>
            </summary>
             <remarks>
             <para>This method is roughly equivalent to writing an opening action contents in the code and doing <see cref="M:JetBrains.DataFlow.Lifetime.AddAction(System.Action)"/> for the closing one.</para>
             <para>Its use is to visually highlight two groups of statements, one being an “undo sequence” for another, which helps with treating them as a solid group when reading or refactoring the code.</para>
             </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddRef(System.Object)">
            <summary>
             <para>Keeps the <paramref name="object"/> alive and prevents it from being garbage collected for the duration of the lifetime.</para>
             <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AttachNested(JetBrains.DataFlow.LifetimeDefinition,System.Boolean)">
            <summary>
            Nests one lifetime within another.
            The difference with just adding an action for terminating the nested lifetime to the parent lifetime is that with repeated use of short-lived nested lifetimes such actions will grow limitlessly within the parent lifetime.
            This method cleans up the parent lifetime's schedule for terminating the nested lifetime whenever the nested lifetime terminates prematurely.
            Internal: use methods like <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> to define lifetimes nested in other ones.
            </summary>
            <param name="defNested">The nested lifetime to be attached to this lifetime.</param>
            <param name="isPossiblyAlreadyTerminated">Whether the nested lifetime could be expected to be terminated by smb. Possible cases: <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> in whose atomic action the nested lifetime is scheduled for termination on another thread. In such a case the caller check if the nested has been terminated doesn't help because the termination occurs async. Without this flag, it's an error to pass in a terminated lifetime. With this flag, it's silently ignored. Anyway, the behavior is thread-safe.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.Terminate">
            <summary>
             Terminates this lifetime. For calling by <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> only.
             Only an owner of <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> is allowed to terminate a lifetime.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.Eternal">
            <summary>
            The instance of the eternal lifetime object. Get thru <see cref="T:JetBrains.DataFlow.EternalLifetime"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Lifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.LifetimeDefinition">
            <summary>
            <para>An interface to the lifetime that only lifetime owner has. Allows to terminate the lifetime.</para>
            <para>Take the <see cref="P:JetBrains.DataFlow.LifetimeDefinition.Lifetime"/> property value to pass to methods or child objects that need the lifetime, or schedule any actions on it.</para>
            </summary>
            <remarks>
            <para>The <see cref="T:JetBrains.DataFlow.Lifetime"/> interface itself allows to schedule actions on the lifetime, but does not allow to terminate it, because it has been defined by the owner and only owner knows when to end the lifetime.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeDefinition.Terminate">
            <summary>
            Terminates the lifetime. All of the actions and disposes scheduled on this lifetime are executed,
            and all nested lifetimes are terminated. These activities are performed in the reverse scheduled order,
            so that the last entry scheduled is executed first (LIFO).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.LifetimeDefinition.IsTerminated">
            <summary>
            Gets whether this lifetime has already been terminated.
            It's an error to continue scheduling on a terminated lifetime.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.LifetimeDefinition.Lifetime">
            <summary>
            Gets the lifetime defined by this instance.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.Add(JetBrains.DataFlow.Lifetime,System.IDisposable)">
            <summary>
             Adds an object that will be disposed of when the enclosing object is disposed of.
             Returns self to allow queueing the additions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.Add(JetBrains.DataFlow.Lifetime,System.IDisposable[])">
            <summary>
             Adds an object that will be disposed of when the enclosing object is disposed of.
             Returns self to allow queueing the additions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AddDispose(JetBrains.DataFlow.Lifetime,System.IDisposable[])">
            <summary>
             <para>Adds a series of objects to be schedulled for disposal upon termination of the lifetime.</para>
             <para>It is preferrable to pass the lifetime object in the constructor of the object to be terminated rather than to dispose the object explicitly. If this is your own object, it should usually be refactored to take a lifetime instead of exposing an <see cref="T:System.IDisposable"/> interface.</para>
             <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertEverTerminated(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger.</para>
            <para>The lifetime will not be terminated automatically, because this is not a lifetime definition. See Remarks for options.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>
            <para>As this method operates on a <see cref="T:JetBrains.DataFlow.Lifetime"/> object you do not own, it cannot terminate the lifetime automatically when a missed termination is detected.</para>
            <para>If you need to ensure the lifetime is terminated, get a <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> and call <see cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)"/> or <see cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)"/> on it.</para>
            <para>If you only have a lifetime and no definition, for example you have been given a lifetime in the component constructor, define a new lifetime (within the lifetime you got, with <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/>). Now you have a definitions to call the <c>Ensure…</c> methods on. Schedulle all of the termination-critical actions on this newly-defined lifetime.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger and terminates the lifetime on the same thread this method was called.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>
            <para>The calling thread must have a <see cref="T:JetBrains.Threading.JetDispatcher"/> for which async operations are not prohibited (see <see cref="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited"/>).</para>
            <para>Also, if the shutdown is already in progress, the thread might not have a chance to process the request.</para>
            <para>These limitations result from schedulling the request with <see cref="!:JetDispatcher.BeginInvoke(JetBrains.DataFlow.Lifetime,string,System.Action)"/>.</para>
            <para>Use this method if it's critical for you to terminate on the same thread (e.g. with COM Interop). Otherwise, prefer <see cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)"/>.</para>
            </remarks>
            <seealso cref="M:JetBrains.DataFlow.LifetimeEx.AssertEverTerminated(JetBrains.DataFlow.Lifetime,System.String)"/>
            <seealso cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)"/>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger and terminates the lifetime on the finalizer thread.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>This method might not be suitable if you're guarding COM Interop termination or similar things because of their thread affinity. Consider using <see cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)"/> if this is the case.</remarks>
            <seealso cref="M:JetBrains.DataFlow.LifetimeEx.AssertEverTerminated(JetBrains.DataFlow.Lifetime,System.String)"/>
            <seealso cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.DataFlow.LifetimeDefinition,System.String,System.Boolean)"/>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertIsAlive(JetBrains.DataFlow.OuterLifetime)">
            <summary>
            Throws an exception if the lifetime has already been terminated (<see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> is <c>True</c>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.LogAssertIsAlive(JetBrains.DataFlow.OuterLifetime)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertIsAlive(JetBrains.DataFlow.Lifetime)">
            <summary>
            Throws an exception if the lifetime has already been terminated (<see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> is <c>True</c>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.LogAssertIsAlive(JetBrains.DataFlow.Lifetime)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertIsAlive(JetBrains.DataFlow.LifetimeDefinition)">
            <summary>
            Throws an exception if the lifetime has already been terminated (<see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> is <c>True</c>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.LogAssertIsAlive(JetBrains.DataFlow.LifetimeDefinition)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeEx.OpenNested(JetBrains.DataFlow.Lifetime)">
            <summary>
            <para>Opens the nested lifetime. It will be terminated whenever this lifetime is terminated.</para>
            <para>Note: unlike adding a new lifetime to this one, the nested lifetime will be forgotten upon termination. This allows to open short-lived nested lifetimes repeatedly without overpolluting the parent lifetime.</para>
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Lifetimes">
            <summary>
            <see cref="T:JetBrains.DataFlow.Lifetime"/>s factory.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Create(System.Boolean)">
            <summary>
            Creates a disposable container that either requires that it is disposed at some moment (<paramref name="finalize" /> = <c>True</c>) or just functions as a one-time composite without any obligations (<paramref name="finalize" /> = <c>False</c>).
            </summary>
            <param name="finalize"><c>False</c>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Create(System.String)">
            <summary>
            Creates a disposable container that must be disposed of.
            If the <see cref="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.Dispose"/> method is never called, an exception is reported from the finalizer.
            </summary>
            <param name="id">An arbitrary string tag that helps to identify the origin of a particular disposables container that never gotten disposed of.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Create">
            <summary>
            Creates a simple lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Create(System.String,System.Boolean)">
            <summary>
            Creates a disposable container that either requires that it is disposed at some moment (<paramref name="finalize" /> = <c>True</c>) or just functions as a one-time composite without any obligations (<paramref name="finalize" /> = <c>False</c>).
            </summary>
            <param name="id">An arbitrary string tag that helps to identify the origin of a particular disposables container that never gotten disposed of.</param>
            <param name="finalize">Whether the disposal is mandatory for the container. If yes, a finalizer is created that will report an exception. If no, the object does not add a strain to the finalization queue and does not do any implicit dispose on finalization.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateAtomic(System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
            Executes the <paramref name="FAtomic"/> in the transactional manner: if an exception is thrown, all of the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime"/> added during the execution are rolled back, and the exception is let out; in case of no exception, the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime"/> produced by the <paramref name="FAtomic"/> are returned.
            The <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime"/> created for the <paramref name="FAtomic"/> are of the optional sort.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection(JetBrains.DataFlow.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection(JetBrains.Util.ILogger,JetBrains.DataFlow.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection2(JetBrains.DataFlow.Lifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection2(JetBrains.Util.ILogger,JetBrains.DataFlow.Lifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.ILogger)">
            <summary>
              <para>Defines a new lifetime nested within the <paramref name="lifetime"/> you pass in.</para>
            </summary>
            <remarks>
              <para>In most cases, you should have some lifetime to use as a parent, such as the lifetime of your component. If this is not the case, and you just need a function-scoped lifetime, call <see cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})"/> instead. It is terminated automatically when your action ends and thus does not need a parent.</para>
              <para>If the lifetime you're created is really not parented by any other lifetime, use the <see cref="T:JetBrains.DataFlow.EternalLifetime"/> as a parent.</para>
            </remarks>
            <param name="lifetime">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="id">
              <para>Optional. The ID of the lifetime.</para>
              <para>Used for tracking and debugging. If the call stack annotations feature is ON, this ID will appear on the call stack when the lifetime object starts executing schedulled actions upon termination.</para>
              <para>In case of nested lifetimes and if schedulled actions are anonimous in their nature, it might be hard to tell what's happening from exception stack traces without this annotation. You're encouraged to specify IDs wherever such situations are suspected, but the IDs should better be statically defined (to avoid memory leaks on part of the call stacks annotation engine).</para>
              <para>If omitted, the default <see cref="F:JetBrains.DataFlow.Lifetimes.AnonymousLifetimeId"/> or the <see cref="T:JetBrains.DataFlow.Lifetime"/> should type name is used, depending on the context.</para>
            </param>
            <param name="FAtomic">
              <para>Optional. The code to be executed atomically on the newly-created lifetime.</para>
              <para>If this code succeeds (or is not specified), the definition of the new lifetime is returned from the method.</para>
              <para>If this code fails with an exception, the newly-created lifetime is terminated, all of the schedulled actions are executed (rolling back any activities already bound to the lifetime), the nested lifetime is not registered no the parent, and the exception is let out of this method.</para>
            </param>
            <param name="logger">
              <para>Optional logging facility override for the new lifetime.</para>
              <para>For example, exceptions in lifetime termination activities should not prevent the rest of activities from being executed; such exceptions are reported to the logging facility.</para>
            </param>
            <returns>
              <para>The definition to the new lifetime.</para>
              <para>As you own the lifetime, you can terminate it through this defintion at any time.</para>
              <para>To pass the lifetime to objects&amp;functions or schedulle termination actions on it, get it from the <see cref="P:JetBrains.DataFlow.LifetimeDefinition.Lifetime"/> property. Do not pass the definition itself to child objects, unless this is the intended scenario to allow them to terminate the lifetime upon their discretion (e. g. a user-cancelable non-modal dialog).</para>
            </returns>
            <seealso cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})"/>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.OuterLifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.ILogger)">
            <summary>
              <para>See documentation on an overload which takes a <see cref="T:JetBrains.DataFlow.Lifetime"/>.</para>
            </summary>
            <seealso cref="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.ILogger)"/>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Synchronize(JetBrains.DataFlow.LifetimeDefinition[])">
            <summary>
            Synchronizes termination of two lifetime definitions.
            Whenever any one is terminated, the other will be terminated also.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="λ" />with a new lifetime nested within a the <paramref name="parent" /> lifetime you pass in.</para>
              <para>Created lifetime is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
            </summary>
            <param name="parent">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using``1(System.Func{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using``1(JetBrains.DataFlow.Lifetime,System.Func{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.UsingAsync(System.Func{JetBrains.DataFlow.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.UsingAsync``1(System.Func{JetBrains.DataFlow.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddDispose(System.IDisposable)">
            <summary>
             Adds an object that will be disposed of when the enclosing object is disposed of.
             Returns self to allow queueing the additions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddAction(System.Action)">
            <summary>
            Adds an action to be executed when the container is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddBracket(System.Action,System.Action)">
            <summary>
            Adds a bracket of actions. The opening one is executed immediately, and the closing one — when the enclosing object is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddRef(System.Object)">
            <summary>
            Holds a reference to the given object <paramref name="object"/> until the container is disposed of.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.IsEmpty">
            <summary>
            Gets whether the container is empty of any disposable items.
            This means that the object is in either non-initialized or already-disposed state.
            The container is not eligible for finalization in this state.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Viewable.ToLiveHashSet``2(JetBrains.DataFlow.IViewable{``0},JetBrains.DataFlow.Lifetime,System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            TODO: implement live hashset with multiple occurrenceos of elements.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Viewable.SelectMany``2(JetBrains.DataFlow.IViewable{``0},JetBrains.DataFlow.Lifetime,System.Func{``0,JetBrains.DataFlow.IViewable{``1}})">
            <summary>
            Similar to <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/> on <see cref="T:System.Collections.Generic.IEnumerable`1"/>, but live: as you have a live collection of providers each giving a live collection of items, builds a live flat collection of items from all the providers.
            </summary>
            <typeparam name="TItemsProvider">Provider type (has a collection of items inside).</typeparam>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="thіs">Live collection of providers.</param>
            <param name="lifetime"></param>
            <param name="FGetItemsFromProvider">How to get the live collection of items out of each provider.</param>
            <returns>The live flat collection of items from all the providers.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.ListBridge`2">
            <summary>
            Bridges two ordered lists of items.
            The items flow from the first collection to the second one. Conversion and filtering is supported on the items.
            The order of projected items in the target list is kept in sync with the original items order.
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge`2.myIndexMapping">
            <summary>
            Stores the mapping from indices in the <see cref="P:JetBrains.DataFlow.ListBridge`2.Source"/> list to those in the <see cref="P:JetBrains.DataFlow.ListBridge`2.Target"/> list.
            Indices in <see cref="F:JetBrains.DataFlow.ListBridge`2.myIndexMapping"/> correspond to those in <see cref="P:JetBrains.DataFlow.ListBridge`2.Source"/>, values — to those in <see cref="P:JetBrains.DataFlow.ListBridge`2.Target"/>.
            A value <c>-1</c> means that the source item is missing from the target list (has been filtered out).
            Items of the target collection missing from the source one (like those manually added) are just missing from the map.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge`2.myMapItems">
            <summary>
            An optional map, can be <c>Null</c> if item-mapping is not needed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListBridge`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{`0},JetBrains.DataFlow.IListEvents{`1},System.Func{`0,`1},System.Func{`0,System.Boolean},JetBrains.DataFlow.ListBridge.MappingInfo,System.Object)">
            <summary>
            Wires up the bridge.
            </summary>
            <param name="lifetime">Lifetime for the bridge.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="funcConverter">The conversion operator.</param>
            <param name="funcFilter">The mapping filter to exclude selected items from the target collection.</param>
            <param name="mappinginfo">Specifies whether the projection mapping information is maintained by the bridge.</param>
            <param name="oTaregtModificationCookie">An otpional cookie to be passed to the <paramref name="target"/> collection when performing modification operations on it.</param>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.HaveMappingInfo">
            <summary>
            Gets whether the projection mapping information is maintained by the bridge.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.MapSourceToTarget">
            <summary>
            Gets the read-only source-to-target mapping.
            Available only if <see cref="P:JetBrains.DataFlow.ListBridge`2.HaveMappingInfo"/>. Otherwise, throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.MapTargetToSource">
            <summary>
            Gets the read-only target-to-source mapping.
            Available only if <see cref="P:JetBrains.DataFlow.ListBridge`2.HaveMappingInfo"/>. Otherwise, throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.Source">
            <summary>
            Gets the source list.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.Target">
            <summary>
            Gets the target list.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ListBridge">
            <summary>
            Supplementary class for the <see cref="T:JetBrains.DataFlow.ListBridge`2"/> utility.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListBridge.BridgeInto``2(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Func{``0,``1},System.Func{``0,System.Boolean},JetBrains.DataFlow.ListBridge.MappingInfo,System.Object)">
            <summary>
            Mirrors one list into another thru a converter.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ListBridge.MappingInfo">
            <summary>
            Specifies which mapping info should be collected by the bridge.
            The mapping allows to translate source items into target ones and vice versa.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge.MappingInfo.None">
            <summary>
            No mapping information collected. No translation possible.
            Wastes less memory.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge.MappingInfo.TwoWay">
            <summary>
            Full mapping information collected.
            Self-checks for consistency are also made on the mapping.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ListEvents`1">
            <summary>
            A list that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">List values type.</typeparam>
            <remarks><see cref="T:System.Collections.IList"/> (yes, nongeneric) was added to support WPF scenarios eg XAML [de]serialization. <see cref="T:System.Windows.Markup.IAddChild"/> is also here for WPF support.</remarks>
        </member>
        <member name="F:JetBrains.DataFlow.ListEvents`1.myStorage">
            <summary>
            Sync thru <see cref="F:JetBrains.DataFlow.CollectionEvents`1.myLock"/>.
            </summary>
            <remarks>
            The storage must be passed to the base class in ctor, for the collection operations to work on the same data.
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{`0},System.Collections.Generic.IList{`0},System.Boolean,JetBrains.Util.ILogger)">
            <summary>
            <para>The universal constructor.</para>
            <para>Constructs the list over some list-like backing storage.</para>
            <para>Specifies whether items in the list must be unique (note: this option is performance-costly).</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(JetBrains.DataFlow.PropertyId{`0},System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>
            <para>Constructs the list over some list-like backing storage.</para>
            <para>Specifies whether items in the list must be unique (note: this option is performance-costly).</para>
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(System.String,System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>
            <para>Constructs the list over some list-like backing storage.</para>
            <para>Specifies whether items in the list must be unique (note: this option is performance-costly).</para>
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(JetBrains.DataFlow.Lifetime,System.String,System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>
            <para>Constructs the list over some list-like backing storage.</para>
            <para>Specifies whether items in the list must be unique (note: this option is performance-costly).</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(System.String)">
            <summary>
            Creates a new list that does not allow duplicate items, with a simple list storage inside.
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            Creates a new list that does not allow duplicate items, with a simple list storage inside.
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new list with a simple list storage inside.
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(JetBrains.DataFlow.PropertyId{`0},System.Boolean)">
            <summary>
            Creates a new list with a simple list storage inside.
            </summary>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.#ctor(JetBrains.DataFlow.Lifetime,System.String,System.Boolean)">
            <summary>
            Creates a new list with a simple list storage inside.
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the collection.</para>
            <para>When lifetime terminates, all of the handlers of the collection events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
            <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="bUniqueItems">If <c>True</c>, adding an item that is already present in the list is not allowed (unless <see cref="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors"/>, an exception is thrown). If <c>False</c>, the duplicate item is just added to the list.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.FireAddRemove(JetBrains.DataFlow.AddRemove,`0,System.Int32,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.ListEvents`1.AddRemove"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.FireBeforeAddRemove(JetBrains.DataFlow.AddRemove,`0,System.Int32,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.ListEvents`1.BeforeAddRemove"/> event.
            Returns whether the operation has been cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.InternalAdd(`0,System.Int32,System.Object)">
            <summary>
            One of the core methods that implement the actual List functionality.
            </summary>
            <param name="value"></param>
            <param name="nIndexOrEnd">Either a real index (which is not thread-safe unless it's <c>0</c>), or <c>-1</c> which means “add to end” and is a special case for the thread-safe <see cref="M:System.Collections.IList.Add(System.Object)"/> method.</param>
            <param name="cookie"></param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.InternalRemove(System.Int32,System.Object)">
            <summary>
            One of the core methods that implement the actual List functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.OnAcknowledgeSinkAddRemove_Add(System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{`0}})">
            <summary>
            Ackhowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.OnAcknowledgeSinkAddRemove_Remove(System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{`0}})">
            <summary>
            Ackhowledges the handler.
            Cannot be merged with <see cref="M:JetBrains.DataFlow.ListEvents`1.OnAcknowledgeSinkAddRemove_Add(System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{`0}})"/> because the iteration should go in the reverse order.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.OnAcknowledgeSinkBeforeAddRemove(System.Action{JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs{`0}})">
            <summary>
            Called when someone attempts to sink the <see cref="P:JetBrains.DataFlow.ListEvents`1.BeforeAddRemove"/> signal. Acknowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.InternalAdd(`0,System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.InternalRemove(`0,System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"></see>.
            </summary>
            
            <returns>
            The index of item if found in the list; otherwise, -1.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"></see>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"></see> at the specified index.
            </summary>
            
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"></see>.</param>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"></see>.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.Modify(JetBrains.DataFlow.AddRemove,`0,System.Int32,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove.</param>
            <param name="index">The index at which the modification should occur.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.Modify(JetBrains.DataFlow.AddRemove,System.Func{`0},System.Int32,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="P:JetBrains.DataFlow.ListEvents`1.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="funcGetItemIfAdding">A function that is called only when doing the <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> operation and produces the new item to be added to the list. This allows to create a new item when pumping from one collection to another with creating the wrappers simultaneousely.</param>
            <param name="index">The index at which the modification should occur.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ListEvents`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"></see> item at the specified index.
            </summary>
            
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"></see>.</exception>
        </member>
        <member name="P:JetBrains.DataFlow.ListEvents`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            
            <returns>
            The element at the specified index.
            </returns>
            
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"></see>.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1"></see> is read-only.</exception>
        </member>
        <member name="P:JetBrains.DataFlow.ListEvents`1.AddRemove">
            <summary>
            Fires when an item is added or removed to your view on the collection.
            Throwing an exception does not prevent the item from being added or other handlers from being called.
            The event supports acknowledgement, which means that when you sink the event, all of the items currently in collection come into your view on the collection, so the add is fired for each. Similarly, remove is fired when you unsink and all of the elements go away from your view on the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added or removed.
            To prevent the add/remove operation, set <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> (decline the operation silently) or throw an exception (the exception is let out to the caller).
            After the first handler to cancel the operation, the remaining handlers may not be called.
            No <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.AddRemove"/> are guaranteed to be executed if the operation is cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ManualProperty">
            <summary>
            Creates properties bound to simple .NET properties or other manual data sources.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(System.String,System.Action{``0})">
            <summary>
            Creates a set-only property manually-bound to some external source via delegates.
            A set-only property is useful for placing at the end of the data flow.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(JetBrains.DataFlow.Lifetime,System.String,System.Action{``0})">
            <summary>
            Creates a set-only property manually-bound to some external source via delegates.
            A set-only property is useful for placing at the end of the data flow.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="lifetime">Lifetime for the property.</param>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(System.String,``0,System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="initialvalue">The initial value for the property.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(JetBrains.DataFlow.Lifetime,System.String,``0,System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="lifetime">Lifetime for the property.</param>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="initialvalue">The initial value for the property.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="getter">External value getter.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(JetBrains.DataFlow.Lifetime,System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="lifetime">Lifetime for the property.</param>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="getter">External value getter.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="T:JetBrains.DataFlow.MarshallingBehaviors">
            <summary>
            Defines how the data flow is marshalled to another thread.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.MarshallingBehaviors.QueueAlways">
            <summary>
            Any data flow occurs asynchronously, even within a single thread.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.MarshallingBehaviors.QueueIfNeeded">
            <summary>
            Only cross-thread data flow is async, within a single thread it works just like a simple <see cref="T:JetBrains.DataFlow.PropertyBinding"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.MarshallingPropertyBinding`2">
            <summary>
            A property binding that marshals all of the updates to the primary thread.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBinding`2">
            <summary>
            Binds together two <see cref="T:JetBrains.DataFlow.IProperty`1"/>s.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myConverterSourceToTarget">
            <summary>
            The convertor implementation.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myConverterTargetToSource">
            <summary>
            The convertor implementation.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myDirection">
            <summary>
            Data flow direction, set to None initially to allow for initialization of the properties from their <c>Null</c> values.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.mySource">
            <summary>
            Stores the source property in yet another property, to allow for changing it later.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myTarget">
            <summary>
            Stores the target property in yet another property, to allow for changing it later.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myFreeze">
            <summary>
            Prevents recursion.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},System.Func{`0,`1})">
            <summary>
            Creates a one-way binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Creates a two-way binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection)">
            <summary>
            Creates a binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection,System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Creates a binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection,System.Func{`0,`1},System.Func{`1,`0},System.Object,System.Object)">
            <summary>
            The ultimate ctor.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.OnConvertSourceToTargetDefault(`0)">
            <summary>
            The default converter.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.OnConvertTargetToSourceDefault(`1)">
            <summary>
            The default converter.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.SourceCookie">
            <summary>
            An optional readonly cookie for reading and writing the source property values.
            <c>Null</c> by default.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Tag">
            <summary>
            A freehand tag for marking the instance, mostly for the debugging needs.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.TargetCookie">
            <summary>
            An optional readonly cookie for reading and writing the target property values.
            <c>Null</c> by default.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Direction">
            <summary>
            Gets or sets the binding direction.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Source">
            <summary>
            Gets or sets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Target">
            <summary>
            Gets or sets the binding target.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.JetBrains#DataFlow#IPropertyBinding#Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.JetBrains#DataFlow#IPropertyBinding#Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBinding`2.UsingNoneDirection">
            <summary>
            Make sure the bindings (and who's the value source) execute in their normal order, when the value is popped.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.MarshallingPropertyBinding`2.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Threading.JetDispatcher,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection,System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            The ultimate ctor.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.MarshallingPropertyBinding`2.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.MarshallingPropertyBinding`2.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.MarshallingPropertyBinding`2.Dispatcher">
            <summary>
            Gets the dispatcher that defines the thread into which the operations are marshalled.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.MarshallingPropertyBinding`2.MarshallingBehavior">
            <summary>
            Gets or sets how the marshaller should behave, see <see cref="T:JetBrains.DataFlow.MarshallingBehaviors"/> for details.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.NullProperty`1">
            <summary>
            The single instance of a <see cref="T:JetBrains.DataFlow.IProperty`1">Property</see> whose value is always <c>Null</c>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.NullProperty`1.Instance">
            <summary>
            The single instance of a <see cref="T:JetBrains.DataFlow.IProperty`1">Property</see> whose value is always <c>Null</c>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CompositeProperty`3">
            <summary>
            Creates a new composite property that composes the values of two source ones.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CompositeProperty`3.Create(JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.CompositeProperty{`0,`1,`2}.ComposerDelegate)">
            <summary>
            Creates a new composite property that composes the values of two source ones.
            </summary>
            <param name="propertySourceOne">The source property.</param>
            <param name="propertySourceTwo">The source property.</param>
            <param name="composer">The composer that produces the target from the sources.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.DataFlow.CompositeProperty`3.Create(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.CompositeProperty{`0,`1,`2}.ComposerDelegate)">
            <summary>
            Creates a new composite property that composes the values of two source ones.
            </summary>
            <param name="lifetime"></param>
            <param name="propertySourceOne">The source property.</param>
            <param name="propertySourceTwo">The source property.</param>
            <param name="composer">The composer that produces the target from the sources.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.DataFlow.CompositeProperty`3.ComposerDelegate">
            <summary>
            Composes a target value from two source ones.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyChangedEventArgs`2">
            <summary>
            When something changes, presents the details about the change.
            </summary>
            <typeparam name="TIdentity">The identity of the item that changes.</typeparam>
            <typeparam name="TValue">The old and new values for the item.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`2.Identity">
            <summary>
            Gets the name of the entity that has changed, eg property name.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`2.New">
            <summary>
            Gets the new value.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`2.Old">
            <summary>
            Gets the old value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.OutEventArgs`1">
            <summary>
            An event arguments class with one typed mutable value that can be changed by any consumer.
            </summary>
            <typeparam name="TOut">Type of the outgoing value that is intended to be set by the event sink.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.OutEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.OutEventArgs`1.Out"/> parameter set to its predefined value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.OutEventArgs`1.#ctor">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.OutEventArgs`1.Out"/> parameter set to <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.OutEventArgs`1.Out">
            <summary>
            Data to be provided by the event sink, based on the event semantics.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Property`1">
            <summary>
            A property that tracks the changes, validates new values being assigned, and notifies of the change.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myHandlersDisposed">
            <summary>
            Stores the <see cref="E:JetBrains.DataFlow.Property`1.Disposed"/> handlers.
            Synth thru <see cref="F:JetBrains.DataFlow.Property`1.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myId">
            <summary>
            ID.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myIsNullValueAllowed">
            <summary>
            Determines whether the property can store NULL values.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.mySignalBeforeChange">
            <summary>
            The signal for the BeforeChange on the property.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.mySignalChange">
            <summary>
            The signal for the Change on the property.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myValue">
            <summary>
            Stores the value of the property.
            Sync thru <see cref="F:JetBrains.DataFlow.Property`1.myLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(System.String)">
            <summary>
            <para>Initializes the roperty with the default initial value for its type.</para> 
            <para>The property will <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">have <c>Null</c> values allowed</see>, because it's required by the initial value of the property.</para>
            </summary>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            <para>Initializes the roperty with the default initial value for its type.</para> 
            <para>The property will <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">have <c>Null</c> values allowed</see>, because it's required by the initial value of the property.</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the property.</para>
            <para>When lifetime terminates, all of the handlers of the property events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.DataFlow.PropertyId{`0},`0)">
            <summary>
            <para>Initializes the roperty with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">
            <para>The initial value of the property.</para>
            <para>If set to a non-<c>Null</c> value (of a reference type), the property will not allow setting <c>Null</c> values at runtime (<see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed"/> = <c>False</c>).</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(System.String,`0)">
            <summary>
            <para>Initializes the roperty with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">
            <para>The initial value of the property.</para>
            <para>If set to a non-<c>Null</c> value (of a reference type), the property will not allow setting <c>Null</c> values at runtime (<see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed"/> = <c>False</c>).</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.DataFlow.Lifetime,System.String,`0)">
            <summary>
            <para>Initializes the roperty with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the property.</para>
            <para>When lifetime terminates, all of the handlers of the property events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">
            <para>The initial value of the property.</para>
            <para>If set to a non-<c>Null</c> value (of a reference type), the property will not allow setting <c>Null</c> values at runtime (<see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed"/> = <c>False</c>).</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.PropertyId{`0},`0,System.Nullable{System.Boolean},JetBrains.Util.ILogger)">
            <summary>
            <para>The ultimate ctor.</para>
            <para>Initializes the roperty with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
            <param name="lifetime">
            <para>Defines the lifetime for the property.</para>
            <para>When lifetime terminates, all of the handlers of the property events are forcibly detached, which helps with preventing memory leaks.</para>
            </param>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">Initial value for the property. Must agree to <paramref name="isNullValueAllowed"/>.</param>
            <param name="isNullValueAllowed">
            <para>Specifies whether <c>Null</c> values can be assigned to the property. Note that this applies to value types also; a <c>Null</c>-disallowing <see cref="T:System.Int32"/> property will not allow assigning values of <c>0</c>.</para>
            <para>Overloads without this parameter use the Null value which means the default strategy: value types are allowed any values, and reference types are allowed <c>Null</c> values only if the initial <paramref name="value"/> is <c>Null</c>.</para>
            <para>This fits nearly all the cases, and you're encouraged to use overloads which do not set this parameter explicitly.</para>
            </param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.ThrowReadonlyFail(JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0},System.Object)">
            <summary>
            Helper to throw an annotated exception whenever a property fails the readonly lock precondition.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.ThrowThreadAffinityFail(JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0},System.Threading.Thread)">
            <summary>
            Helper to throw an annotated exception whenever a property fails the threading affinity precondition.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FireBeforeChange(`0,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.Property`1.BeforeChange"/> event, in course of assigning a new value to the property.
            If <c>False</c>, the transaction has been cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FireChange(`0,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.Property`1.Change"/> event, in course of assigning a new value to the property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FireDisposed">
            <summary>
            Fires the <see cref="E:JetBrains.DataFlow.Property`1.Disposed"/> event to the pre-stored list of handlers.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FirePropertyChanged">
            <summary>
            Fires the <see cref="E:JetBrains.DataFlow.Property`1.PropertyChanged"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FirePropertyChanging">
            <summary>
            Fires the <see cref="E:JetBrains.DataFlow.Property`1.PropertyChanging"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.GetValue">
            <summary>
            Gets the property value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.SetValue(`0)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.SetValue(`0,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#SetValue(System.Object,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="E:JetBrains.DataFlow.Property`1.Disposed">
            <summary>
            Fires when the property disposes.
            </summary>
        </member>
        <member name="E:JetBrains.DataFlow.Property`1.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">
            <summary>
            Gets whether the property can store NULL values of reference types and zero values of value types.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.Value">
            <summary>
            Gets or sets the value by wrapping the <see cref="M:JetBrains.DataFlow.Property`1.GetValue"/> and <see cref="M:JetBrains.DataFlow.Property`1.SetValue(`0)"/> calls.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#PropertyType">
            <summary>
            Gets the type of the generic property.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Property`1.PropertyBeforeChangeSignal">
            <summary>
            Handles the signals on the property events.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyBeforeChangeSignal.Acknowledge(System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0}},JetBrains.DataFlow.AddRemove)">
            <summary>
            Acknowledges the <see cref="P:JetBrains.DataFlow.Property`1.BeforeChange"/> sinks.
            Returns whether the change is allowed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyBeforeChangeSignal.OnBeforeAdvise(System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0}})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Property`1.PropertyChangeSignal">
            <summary>
            Handles the signals on the property events.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyChangeSignal.Acknowledge(System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}},JetBrains.DataFlow.AddRemove)">
            <summary>
            Acknowledges the given handler with the property value, either on add or remove of the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyChangeSignal.OnAfterAdvise(System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyChangeSignal.OnAfterUnadvise(System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBag.Remove``1(JetBrains.DataFlow.PropertyId{``0})">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBag.JetBrains#DataFlow#IUntypedPropertyBag#Remove(JetBrains.DataFlow.PropertyId)">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBag.JetBrains#DataFlow#IUntypedPropertyBag#GetOrCreateProperty(JetBrains.DataFlow.PropertyId,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Creates a property in the bag, or picks an existing one.
            The type is inferred from the generic data constant type <see cref="T:JetBrains.DataFlow.PropertyId`1"/>.
            </summary>
            <param name="id">An identifier for the property.</param>
            <param name="defaultvalue">Default value to assign to the property initially.</param>
            <param name="isNullValueAllowed">Whether <c>Null</c> values are accepted by the property.</param>
            <returns>The newly-created property, or an existing one, if available.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBinding">
            <summary>
            A non-generic static class that helps creating specific property bindings.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding.False">
            <summary>
            Gets a cached instance of a property that always has the same value.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding.True">
            <summary>
            Gets a cached instance of a property that always has the same value.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding.Zero">
            <summary>
            Gets a cached instance of a property that always has the same value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1},System.Func{``1,``0})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="target"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="target"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="target"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``1(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Boolean)">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="targetproperty"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Func{``0,``1},System.Func{``1,``0})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="targetproperty"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOneWayToSource``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.Func{``1,``0})">
            <summary>
            Creates a one-way property binding to source
            Initially, <paramref name="source"/> will be assighned the value of <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOneWayToSource``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Creates a one-way property binding to source
            Initially, <paramref name="source"/> will be assighned the value of <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOneWayToSource``2(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Func{``1,``0})">
            <summary>
            Creates a one-way property binding to source (IProperty)
            Initially, <paramref name="targetproperty"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOneWayToSource``1(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Windows.DependencyObject,System.Windows.DependencyProperty)">
            <summary>
            Creates a one-way property binding to source (IProperty)
            Initially, <paramref name="targetproperty"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Create2``3(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},System.Func{``0,``1,``2},System.Object)">
            <summary>
            Creates a simple many-to-one binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Create3``4(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},JetBrains.DataFlow.IProperty{``3},System.Func{``0,``1,``2,``3},System.Object)">
            <summary>
            Creates a simple many-to-one binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Create4``5(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},JetBrains.DataFlow.IProperty{``3},JetBrains.DataFlow.IProperty{``4},System.Func{``0,``1,``2,``3,``4},System.Object)">
            <summary>
            Creates a simple many-to-one binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateAnd(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            ANDs two boolean properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateAnd(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean},System.String)">
            <summary>
            ANDs two boolean properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateAndMultibinding(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            Binds two <see cref="T:System.Boolean"/> properties to a third by ANDing their values.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateCascading``3(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Func{``0,JetBrains.DataFlow.IProperty{``1}},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},JetBrains.DataFlow.DataFlowDirection)">
            <summary>
            Creates a cascading binding, Owner.Source ↔ Target, where Source is a property inside the Owner. Owner may change, and each time the Source is taken from the new Owner, and its changes are tracked.
            </summary>
            <param name="lifetime">Lifetime for the binding.</param>
            <param name="sourceowner">The owner object that may change with time, from which the Source for the binding is extracted by the means of the <paramref name="FGetSourceFromOwner"/> converter. Its value may become <c>Null</c>.</param>
            <param name="FGetSourceFromOwner">A function that knows how to find a source for the binding in each new <paramref name="sourceowner"/>. The owner object passed to it is always non-<c>Null</c>, because the <paramref name="propSourceWhenNoOwner"/> value is used automatically when <paramref name="sourceowner"/>'s value gets <c>Null</c>.</param>
            <param name="propSourceWhenNoOwner">When the <paramref name="sourceowner"/>'s <see cref="P:JetBrains.DataFlow.IProperty`1.Value"/> gets <c>Null</c>, this property is used for the binding source instead.</param>
            <param name="target">The target property for the binding.</param>
            <param name="direction">Binding direction.</param>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateIsNotNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a bool property that is bound to whether <paramref name="source"/> is not <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateIsNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a bool property that is bound to whether <paramref name="source"/> is <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateNot(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates a binding that negates a value of the boolean property.
            The negated property is created inplace, and returned as a result.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOr(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            ORs two boolean properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOrMultibinding(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            Binds two <see cref="T:System.Boolean"/> properties to a third by ORing their values.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Null``1">
            <summary>
            Gets the single instance of a <see cref="T:JetBrains.DataFlow.IProperty`1">Property</see> whose value is always <c>Null</c>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBindingDeferred`1">
            <summary>
            Establishes a one-way property binding that defers application of the changes for some grace period.
            If a new change occurs within the grace period, the period is prolongated.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBindingDeferred`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`0},System.TimeSpan,System.Object)">
            <summary>
            The ultimate ctor.
            Wires up the binding.
            </summary>
            <param name="lifetime">Lifetime of the binding. Recommended, but not 100% necessary, as the timer is held on weak ref.</param>
            <param name="source">The source property.</param>
            <param name="target">The target property.</param>
            <param name="graceperiod">The grace period for the changes to be withheld and accumulated.</param>
            <param name="targetcookie">An optional cookie for the <paramref name="target"/>'s write access.</param>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBindingDeferred`1.GracePeriod">
            <summary>
            Gets or sets the grace period in which the changes to the <see cref="P:JetBrains.DataFlow.PropertyBindingDeferred`1.Source"/> are accumulated.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBindingDeferred`1.IncomingCommit">
            <summary>
            Immediately applies the pending changes, if there are any. Otherwise, does nothing.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBindingDeferred`1.IsPending">
            <summary>
            Gets whether there currently are any pending changes.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBindingDeferred`1.Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBindingDeferred`1.Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyId`1">
            <summary>
            A typed identifier for a <see cref="T:JetBrains.DataFlow.Property`1"/> that specifies the property name and sets its type.
            Works as a typesafe <see cref="T:JetBrains.DataFlow.PropertyBag"/> accessor.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyId">
            <summary>
            The untyped base class for a <see cref="T:JetBrains.DataFlow.PropertyId`1">property identifier</see>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyId.Create``1(System.String)">
            <summary>
            Creates a new strongly-typed property ID.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyId.Id">
            <summary>
            Gets the non-empty identifier text.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyId`1.#ctor(System.String)">
            <summary>
            Creates the identifier.
            </summary>
            <param name="id">A non-empty string identifier.</param>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyId`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyId`1.Id">
            <summary>
            Gets the non-empty identifier text.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.SequentialLifetimes">
            <summary>
            Maintains a sequence of lifetimes, so that the previous lifetime is closed before the new one is opened.
            Good for implementing a sequence of non-simultaneous activities when it's nice to guarantee only one is active at a time.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.#ctor(JetBrains.DataFlow.Lifetime)">
            <summary>Creates and binds to the lifetime.</summary>
            <param name="lifetime">When this lifetime is closed, the last of the sequential lifetimes is closed too.</param>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.Next(System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.DefineNext(System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime})">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            The lifetime definition allows to terminate it as desired.
            Also, the lifetime will be terminated when either parent lifetime is terminated,
            or <see cref="M:JetBrains.DataFlow.SequentialLifetimes.TerminateCurrent"/> is called, or <see cref="M:JetBrains.DataFlow.SequentialLifetimes.DefineNext(System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime})"/>/<see cref="M:JetBrains.DataFlow.SequentialLifetimes.Next"/> is called.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.TerminateCurrent">
            <summary>
            Terminates the current lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.SetCurrentLifetime(JetBrains.DataFlow.LifetimeDefinition)">
            <summary>
            Atomically, assigns the new lifetime and terminates the old one.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.SignalStatics.SequentialLifetimesFactory">
            <summary>
            Pulled out to avoid swarming separate instances for different generic params.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.SingleDisposable">
            <summary>
            Holds one disposable at most. When a new one is assigned, the old one goes away.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.SingleDisposable.myContainee">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Clear">
            <summary>
            <para>Disposes of the current contained value, if any.</para>
            <para>If you'd like to make sure the old value is disposed of BEFORE you evaluate the new one, either use <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})"/> or pipe a <see cref="M:JetBrains.DataFlow.SingleDisposable.Clear"/> call before the <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)"/> call. This might be necessary for sequencing the disposables brackets, to close the previous bracked before opening the new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)">
            <summary>
            <para>Disposes of the old contained value, and places a new one instead.</para>
            <para>If you'd like to make sure the old value is disposed of BEFORE you evaluate the new one, either use <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})"/> or pipe a <see cref="M:JetBrains.DataFlow.SingleDisposable.Clear"/> call before the <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)"/> call. This might be necessary for sequencing the disposables brackets, to close the previous bracked before opening the new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})">
            <summary>
            <para>Disposes of the old contained value, and places a new one instead.
            Guarantees that the old value is disposed of BEFORE the new value is evaluated by <paramref name="funcNew"/>.</para>
            <para>If you'd like to make sure the old value is disposed of BEFORE you evaluate the new one, either use <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})"/> or pipe a <see cref="M:JetBrains.DataFlow.SingleDisposable.Clear"/> call before the <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)"/> call. This might be necessary for sequencing the disposables brackets, to close the previous bracked before opening the new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.PutBracket(System.Action,System.Action)">
            <summary>
            Disposes of the old contained value first. Then executes the <paramref name="FEnter"/> action and schedulles <paramref name="FLeave"/> for execution when the contained value is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.ReadonlyToken">
            <summary>
            <para>A special object that locks property writes to the authorized owner, one who can provide the correct token.</para>
            <para>Even though the token has a comment string, it's used for failure diagnostic only and does not affect tokens equality. Each new token instance is unique, regardless of the comment string.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StandardPreconditions.ReadonlyToken.#ctor(System.String)">
            <summary>
            Creates a special object that locks property writes to the authorized owner, one who can provide the correct token.
            </summary>
            <param name="info">Provides information about the readonly lock: who the owner of the lock is (usually, the owner of the locked object), and why the object is locked.</param>
            <remarks>Even though the token has a comment string, it's used for failure diagnostic only and does not affect tokens equality. Each new token instance is unique, regardless of the comment string.</remarks>
        </member>
        <member name="F:JetBrains.DataFlow.StandardPreconditions.ReadonlyToken.Info">
            <summary>
            Provides information about the readonly lock: who the owner of the lock is (usually, the owner of the locked object), and why the object is locked.
            </summary>
            <remarks>Even though the token has a comment string, it's used for failure diagnostic only and does not affect tokens equality. Each new token instance is unique, regardless of the comment string.</remarks>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.StandardPreconditionOptions">
            <summary>
            Some options related to <see cref="T:JetBrains.DataFlow.StandardPreconditions.IStandardPrecondition"/> entities, mostly for tests/debug.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.StandardPreconditions.StandardPreconditionOptions.UseStandardPreconditionsInHelperMethods">
            <summary>
            <para>Whether helper extension methods should use standard preconditions whenever possible.</para>
            <para><c>True</c>: production setting. Hard-coded standard preconditions are used wherever possible for speed.</para>
            <para><c>False</c>: test environment settings. Slower, but allows to test the code paths not available with standard preconditions.</para>
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.WinFormsProperty">
            <summary>
            Wraps a property with an event into an <see cref="T:JetBrains.DataFlow.IProperty`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.WinFormsProperty.Create``2(JetBrains.DataFlow.Lifetime,``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean)">
            <summary>
            Returns a data flow property bound to a WinForms standard property (one usually coupled with an event).
            </summary>
            <typeparam name="TSource">Source object type.</typeparam>
            <typeparam name="TValue">Property value type.</typeparam>
            <param name="lifetime"></param>
            <param name="source">The source winforms property owner.</param>
            <param name="propertyExpression">Expression to retrieve property</param>
            <param name="sinkEvents">Whether to sink the events from the WinForms property about its updates. Looks for an event with the {PropertyName}+“Changed” name.</param>
        </member>
        <member name="M:JetBrains.DataFlow.WinFormsProperty.Create``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean)">
            <summary>
            Returns a data flow property bound to a WinForms standard property (one usually coupled with an event).
            </summary>
            <typeparam name="TSource">Source object type.</typeparam>
            <typeparam name="TValue">Property value type.</typeparam>
            <param name="source">The source winforms property owner.</param>
            <param name="propertyExpression">Expression to retrieve property</param>
            <param name="sinkEvents">Whether to sink the events from the WinForms property about its updates. Looks for an event with the {PropertyName}+“Changed” name.</param>
        </member>
        <member name="M:JetBrains.DataFlow.WinFormsProperty.Create``1(System.Object,System.String,System.Boolean)">
            <summary>
            Returns a data flow property bound to a WinForms standard property (one usually coupled with an event).
            </summary>
            <typeparam name="TValue">Property value type.</typeparam>
            <param name="source">The source winforms property owner.</param>
            <param name="propertyName">The source winforms property name.</param>
            <param name="sinkEvents">Whether to sink the events from the WinForms property about its updates. Looks for an event with the {PropertyName}+“Changed” name.</param>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Boxed`1">
            <summary>
            Turns a value type into a reference type — similarly to <see cref="T:System.Nullable`1"/>,
            but the resulting type is a reference type not a value type.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Boxed">
            <summary>
            Supports <see cref="T:JetBrains.Util.dataStructures.Boxed`1"/>, mostly taken from <see cref="T:System.Nullable"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.ChunkedMemoryStream">
            <summary>
            A stream that resides in memory and allocates more chunks of data instead of reallocating the large continuous chunk.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myBuffers">
            <summary>
            Chunk buffers (non-zero-length only — required for index two-way translation).
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCachedCurrentBuffer_Index">
            <summary>
            With multiple small calls to Read or Write, caches the last-used current buffer and avoids costly calls into a chunk list.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCachedCurrentBuffer_Value">
            <summary>
            With multiple small calls to Read or Write, caches the last-used current buffer and avoids costly calls into a chunk list.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCurrentBufferIndex">
            <summary>
            The buffer from <see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myBuffers"/> the <see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myPositionIncludingStartOffset"/> is currently in. "Before first byte" is preferred to "After last byte" (even if at end of stream). Could be equal to number of buffers (eg pointing beyond the end of list of buffers) — when exactly at the end of the stream.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCurrentBufferOffset">
            <summary>
            Offset of the <see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myPositionIncludingStartOffset"/> from the beginning of its current buffer (<see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCurrentBufferIndex"/>).
            Shouldn't be equal to current buffer length (should be zero in the next buffer instead).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.#ctor">
            <summary>
              <para>Allocates the new stream which will grow as you write.</para>
              <para>When done writing, you can <see cref="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.Freeze"/> the stream to prevent subsequent modification by consumers.</para>
              <para>If you want multiple consumers to read the frozen stream without interrupting one another, give them individual lightweight instances produced with <see cref="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ShallowClone"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.#ctor(JetBrains.Util.DataStructures.ChunkList{System.Byte[]},System.Int64,System.Int64,JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags,System.UInt64)">
            <summary>
            Clone ctor.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffers(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Int32)">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>No guarantees are provided for innutability of the buffers' contents, so the stream is neither <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen"/> nor can it ever be frozen.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffers(System.Byte[][])">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>No guarantees are provided for innutability of the buffers' contents, so the stream is neither <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen"/> nor can it ever be frozen.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffersGuaranteedImmutable(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Int32)">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>Caller claims the buffers to be ever immutable, so the stream is assumed <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffersGuaranteedImmutable(System.Byte[][])">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>Caller claims the buffers to be ever immutable, so the stream is assumed <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.Freeze">
            <summary>
            Fluent version of <see cref="M:JetBrains.Util.Collections.IFreezable.Freeze"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ReadByte">
            <summary>
            An optimized func for reading just one byte; without it, base impl might go into allocations on every read.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ShallowClone">
            <summary>
              <para>Freezes the current instance and makes a lightweight clone which only creates a copy of the wrapper class, but reuses the whole same buffers.</para>
              <para>This way you can have multiple readers over the same data without their interfering with each other's position and yet without wasting memory.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ToArray">
            <summary>
            Returns the array contents, trimming any excess storage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.TrimExcess">
            <summary>
            Works similarly to <see cref="M:System.Collections.Generic.List`1.TrimExcess"/>.
            Frees the unused buffers, but does not free the unused leftovers of the last buffer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.GetBufferAndOffsetOfPosition(System.Int64,System.Int32@,System.Int32@)">
            <summary>
            Gets the buffer and offset in it where the <paramref name="lPositionIncludingStartOffset" /> falls.
            Offset can be zero and never can be equal to the length of the buffer. At the very end, the buffer index is equal to the number of buffers.
            Throws when the length is outside the buffers span.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.TryGetBufferAndOffsetOfPosition(System.Int64,System.Int32@,System.Int32@)">
            <summary>
            Gets the buffer and offset in it where the <paramref name="lPositionIncludingStartOffset" /> falls.
            Offset can be zero and never can be equal to the length of the buffer. At the very end, the buffer index is equal to the number of buffers.
            Returns <c>-1</c> of OK and the total max length of the buffers-allocated space (including start offset) if the position does not fall within the allocated space.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.ChunkedMemoryStream.Guid">
            <summary>
            The unique identifier of this breed of cloned streams.
            New for each new stream. Same in all cloned instances.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags.IsOnUserBuffers">
            <summary>
            Whether we're running on user buffers (as passed to ctor) and should not be modifying them.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags.IsFrozen">
            <summary>
            <see cref="M:JetBrains.Util.Collections.IFreezable.Freeze"/> has been called.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags.IsCloned">
            <summary>
            Tracking flag for clones.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkSparseArray`1.#ctor(System.Int32)">
            <summary>
            Create chunk array with pre-allocated given size
            </summary>
            <param name="initialSize"></param>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalList`1">
            <summary>
              <para>A frugal version of a generic variable-size list.</para>
              <para>Properties:</para>
              <para>• Is a value type (non-POD though), thus merges into the memory of the owning type.</para>
              <para>• Stores first <see cref="F:JetBrains.Util.dataStructures.FrugalLocalList`1.LocalItemsCount"/> items within own memory.</para>
              <para>• Stores the remaining items, if any, in a dynamic list. If there aren't any more items, the dynamic list is not created.</para>
              <para>• Does not create any new objects when there are just <c>0</c>,<c>1</c>...<see cref="F:JetBrains.Util.dataStructures.FrugalLocalList`1.LocalItemsCount"/> items in the list.</para>
              <para>Memory: <see cref="F:JetBrains.Util.dataStructures.FrugalLocalList`1.LocalItemsCount"/> pointers for first items, plus one pointer for the lazily-created list of remaining items items.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.AsEnumerable">
            <summary>
              <para>Boxes this value type and returns the custom box object which implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</para>
              <para>The box PARTIALLY reflects modifications in the original structure. To create a full copy, use <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToList"/> or <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToArray"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.AsList">
            <summary>
              <para>Boxes this value type and returns the custom box object which implements a readonly <see cref="T:System.Collections.Generic.IList`1"/>.</para>
              <para>The box PARTIALLY reflects modifications in the original structure. To create a full copy, use <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToList"/> or <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToArray"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ClearKeepingTail">
            <summary>
            Like <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.Clear"/>, but does not release the tail list if it were already allocated.
            Use this method if you're looping clear list / fill list, to avoid re-allocating the tail on each turn.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.Clone">
            <summary>
              <para>Clones the list.</para>
              <para>We're a value type, but not a POD. Unlike assignment, cloning also clones the tail list correctly.</para>
              <para>Does NOT clone the items (unless they're PODs of course).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.GetEnumerator">
            <summary>
            Allows to enumerate the list in language constructs like C# <c>foreach</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.Init(`0)">
            <summary>
            Wraps an item with a list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToList">
            <summary>
              <para>Creates a new <see cref="T:System.Collections.Generic.List`1"/> with the items.</para>
              <para>Calling the <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.AsList"/> ext method would just box the existing <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1"/> instance with a readonly interface.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.HybridCollection`1">
            <summary>
            Collection which optimized to store single item without allocating array.
            The collection cannot contain <c>null</c> elements!
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.StringConcat">
            <summary>
            Represents string that consists from other strings. The way of avoiding string concatenation and high memory traffic.
            Works fast for small number of parts. Typical replace for: namespace + "." + typeName
            </summary>
        </member>
        <member name="T:JetBrains.ActivityCollector.ActivityCollector">
            <summary>
            Logs disposable activities to a temporary file (%TEMP%\ReSharper_ActivityCollector-[time-and-random-stuff].txt)
            Activity is <see cref="T:System.IDisposable"/> with name. Basic usage pattern:
            <code>
            var activity = ActivityCollector.GetEndpoint().StartActivity(new Key("activity name"))
            [do some stuff]
            activity.Dispose()
            </code>
            After dispose call thread id, activity name, start time and end time will be written to log.
            
            
            </summary>
        </member>
        <member name="T:JetBrains.UI.Anchoring">
            <summary>
            Linear anchoring constants.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring.NearWithout">
            <summary>
            Left or top, anchored outside the area.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring.NearWithin">
            <summary>
            Left or top, anchored inside the area.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring.MiddleWithin">
            <summary>
            Center or middle, anchored inside the area. Preferrably, in the center.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring.FarWithin">
            <summary>
            Right or bottom, anchored inside the area.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring.FarWithout">
            <summary>
            Right or bottom, anchored outside the area.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Anchoring2D">
            <summary>
            Describes the anchoring in two dimensions.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring2D.myAnchorAside">
            <summary>Backup for <see cref="P:JetBrains.UI.Anchoring2D.AnchorAside"/>.</summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring2D.myAnchorBottomOrTop">
            <summary>Backup for <see cref="P:JetBrains.UI.Anchoring2D.AnchorBottomOrTop"/>.</summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring2D.myAnchorLeftOrRightOnly">
            <summary>Backup for <see cref="P:JetBrains.UI.Anchoring2D.AnchorLeftOrRightOnly"/>.</summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring2D.myAnchorTop">
            <summary>Backup for <see cref="P:JetBrains.UI.Anchoring2D.AnchorTop"/>.</summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring2D.myAnchorTopOrBottom">
            <summary>Backup for <see cref="P:JetBrains.UI.Anchoring2D.AnchorTopOrBottom"/>.</summary>
        </member>
        <member name="F:JetBrains.UI.Anchoring2D.Value">
            <summary>The raw value combining both vertical and horizontal anchoring.</summary>
        </member>
        <member name="M:JetBrains.UI.Anchoring2D.#ctor(System.Int32)">
            <summary>
            Initializes from a raw value.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Anchoring2D.#ctor(JetBrains.UI.Anchoring,JetBrains.UI.Anchoring)">
            <summary>
            Initializes the instance.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Anchoring2D.IsFar(JetBrains.UI.Anchoring)">
            <summary>
            Checks whether the given <paramref name="anchoring"/> is one of the Far— anchorings,
            namely, <see cref="F:JetBrains.UI.Anchoring.FarWithin"/> or <see cref="F:JetBrains.UI.Anchoring.FarWithout"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Anchoring2D.IsNear(JetBrains.UI.Anchoring)">
            <summary>
            Checks whether the given <paramref name="anchoring"/> is one of the Near— anchorings,
            namely, <see cref="F:JetBrains.UI.Anchoring.NearWithin"/> or <see cref="F:JetBrains.UI.Anchoring.NearWithout"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Anchoring2D.ToArray">
            <summary>
            Creates an array consisting of just one item.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Anchoring2D.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.AnchorAside">
            <summary>
            Gets the list of anchoring to place the entity aside the anchor, preferrably, left, right, then bottom and top.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.AnchorBottomOrTop">
            <summary>
            Gets the list of side-anchoring dispositions in descending order of preferrability.
            The preferred side is bottom, then top, then right and left.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.AnchorLeftOrRightOnly">
            <summary>
            Gets the list of side-anchoring dispositions in descending order of preferrability.
            The preferred side is right, then left. That's all.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.AnchorTop">
            <summary>
            Gets the list of side-anchoring dispositions in descending order of preferrability.
            The preferred side is top, sides top to bottom, then bottom.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.AnchorTopOrBottom">
            <summary>
            Gets the list of side-anchoring dispositions in descending order of preferrability.
            The preferred side is top, then bottom, then left and right.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.Horizontal">
            <summary>
            Gets or sets the hotizontal component of the anchoring.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.IsInside">
            <summary>
            Gets whether the anchoring is inside the rect against both dimensions.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Anchoring2D.Vertical">
            <summary>
            Gets or sets the hotizontal component of the anchoring.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.MurmurHash3(System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Murmur Hash v3, which is a public domain algorithm.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.BinarySearch(JetBrains.Util.PersistentMap.UnsafeIntArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return leftmost index of found item or binary complement (~) of insertion index
            </summary>
            <param name="array">non-decreasing  sorted array, can't be null</param>
            <param name="lo">lower index of search (inclusive)</param>
            <param name="hi">high index of search (inclusive)</param>
            <param name="val">value to search</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.DistinctSorted(JetBrains.Util.PersistentMap.UnsafeIntArray)">
            <summary>
            Remove duplicates if array is sorted and returns length of new array
            </summary>
            <returns>new length</returns>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.IsSorted(JetBrains.Util.PersistentMap.UnsafeIntArray,System.Boolean)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.EnumerableCollection`1">
            <summary>
            This class adapts <see cref="T:System.Collections.Generic.IEnumerable`1"/> to read-only <see cref="T:System.Collections.Generic.ICollection`1"/> involving count of items. Methods <see cref="M:JetBrains.Util.Collections.EnumerableCollection`1.Contains(`0)"/>
            and <see cref="M:JetBrains.Util.Collections.EnumerableCollection`1.CopyTo(`0[],System.Int32)"/> are not supported.
            Used to optimize getting count of items only. Count is specified in constructor - it IS NOT counted automatically by enumerable. 
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="T:System.Linq.EnumerableExJet">
            <summary>
            Extension methods that mimic or extend the standard <see cref="T:System.Linq.Enumerable"/> methods, sharing the same names.
            Thus, this class MUST be in the same namespace, so that there were no problems when importing one of them at random.
            </summary>
        </member>
        <member name="M:System.Linq.EnumerableExJet.First``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns the first element of a sequence. 
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return the first element of. </param>
            <param name="sExceptionMessageEmpty">The message for an exception to be thrown if the <paramref name="source"/> is empty.</param>
            <returns>The first element in the specified sequence. </returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition.
            If there're no such elements, throws an exception  (hence difference with <see cref="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)"/>).
            If there're multiple such elements, logs an exception and uses the first one.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return a single element from. </param>
            <param name="sContextSentence">The context for the exception message. Must be a complete sentence. Will be added to the message which says there're no/multiple items.</param>
            <param name="arg4"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition.
            If there're no such elements, returns NULL (hence difference with <see cref="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)"/>).
            If there're multiple such elements, logs an exception and uses the first one.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return a single element from. </param>
            <param name="sContextSentence">The context for the exception message. Must be a complete sentence. Will be added to the message which says there're no/multiple items.</param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.Single``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <seealso cref="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)"/>
            <seealso cref="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)"/>
            <summary>
            Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return a single element from. </param>
            <param name="sExceptionMessageEmpty">The message for an exception to be thrown if the <paramref name="source"/> is empty.</param>
            <param name="sExceptionMessageAmbiguous">The message for an exception to be thrown if the <paramref name="source"/> contains more than one element.</param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="T:JetBrains.Util.Collections.HashMap`2">
            <summary>
            Reimplementation of Dictionary.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:JetBrains.Util.Collections.HashMap`2.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.Collections.HashMap`2.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:JetBrains.Util.Collections.HashMap`2.Entry.PrevEntryIndex">
            <summary>
            Index of previous entry in the chain of keys with the same hashcodes (modulo size), -1 means first
            </summary>
        </member>
        <member name="T:JetBrains.Util.DictionaryWrapper`2">
            <summary>
            Dictionary with <see cref="F:JetBrains.Util.DictionaryWrapper`2.Statistics"/> for each operation. Can be serialized/deserialized seamlessly.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ReadOnlyException">
            <summary>Represents the exception that is thrown when you try to change the value of a read-only entity.</summary>
        </member>
        <member name="F:JetBrains.Util.StrongToWeakDictionary`2.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.StrongToWeakDictionary`2.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:JetBrains.Util.StrongToWeakDictionary`2.Entry.PrevEntryIndex">
            <summary>
            Index of previous entry in the chain of keys with the same hashcodes (modulo size), -1 means first
            </summary>
        </member>
        <member name="T:JetBrains.Util.TypeOf">
            <summary>
            Caches <see cref="F:JetBrains.Util.TypeOf.Type"/> instances for popular types.
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.Fiber">
            <summary>
            Implements the fibers (non-preemptive multitasking).
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.IFiber">
            <summary>
            Common interface for various fiber incarnations.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.IFiber.YieldTo">
            <summary>
            Yields execution to this fiber.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.IFiber.IsCompleted">
            <summary>
            Whether the fiber coroutine has started running and completed its run successfully.
            A primary fiber is never considered completed, as its code has no specific end.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.IFiber.IsPrimary">
            <summary>
            Whether this is the primary fiber, a wrapper over the thread's main execution flow, rather than a specifically created coroutine.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.#ctor(System.Action)">
            <summary>
            Creates a new secondary fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.#ctor">
            <summary>
            Wraps the primary fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.CreateSecondaryFiber(System.Action)">
            <summary>
            Creates a new fiber to execute the <paramref name="action"/> in.
            To start execution, <see cref="M:JetBrains.Concurrency.Fiber.YieldTo"/> this fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.GetPrimaryFiber">
            <summary>
            Gets the primary fiber for this thread. It represents the main execution path of the thread.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.YieldTo">
            <summary>
            Yields execution to this fiber.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.Fiber.IsCompleted">
            <summary>
            Whether the fiber coroutine has started running and completed its run successfully.
            A primary fiber is never considered completed, as its code has no specific end.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.Fiber.IsPrimary">
            <summary>
            Whether this is the primary fiber, a wrapper over the thread's main execution flow (<see cref="M:JetBrains.Concurrency.Fiber.GetPrimaryFiber"/>), rather than a specifically created coroutine (<see cref="M:JetBrains.Concurrency.Fiber.CreateSecondaryFiber(System.Action)"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.Fiber.FiberProc">
            <summary>
            Fiber proc prototype. Cannot use a generic <see cref="T:System.Action`1"/> for marshalling.
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.FiberOverThread">
            <summary>
            Manages multiple threads of execution via fiber-like API.
            </summary>
        </member>
        <member name="F:JetBrains.Concurrency.FiberOverThread._current">
            <summary>
            The current fiber for this thread, or <c>Null</c> if no active one available.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.#ctor">
            <summary>
            Primary.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.#ctor(System.Action)">
            <summary>
            Secondary.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.CreateSecondaryFiber(System.Action)">
            <summary>
            Creates a new fiber to execute the <paramref name="action"/> in.
            To start execution, <see cref="M:JetBrains.Concurrency.FiberOverThread.YieldTo"/> this fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.GetPrimaryFiber">
            <summary>
            Gets the primary fiber for this thread. It represents the main execution path of the thread.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.YieldTo">
            <summary>
            Yields execution to this fiber.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.FiberOverThread.IsCompleted">
            <summary>
            Whether the fiber coroutine has started running and completed its run successfully.
            A primary fiber is never considered completed, as its code has no specific end.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.FiberOverThread.IsPrimary">
            <summary>
            Whether this is the primary fiber, a wrapper over the thread's main execution flow, rather than a specifically created coroutine.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.FrugalLocalLazy`1">
            <summary>
            <para>Provides support for several common patterns of lazy initialization, including the ability to initialize value types and to use null values.</para>
            <para>This is a frugal version of <see cref="T:System.Lazy`1"/> and <see cref="T:JetBrains.Util.Concurrency.LocalLazy`1"/> that does not create any objects until the lazy value is initialized to a reference type.</para>
            <para>This class only supports creating reference types with default constructors in a thread-unsafe manner, but its added memory usage is exactly zero (it takes as much space in the containing class as a field with a reference to the lazily-created value would do).</para>
            <para>For use in private fields only. Do not expose! Assigning this object to any variables breaks the pattern.</para>
            </summary>
            <typeparam name="T">Specifies the type of element being laziliy initialized.</typeparam>
        </member>
        <member name="T:JetBrains.Threading.GuardAttribute">
            <summary>
            Defines the guarded context affinity of the method: whether it expects to be always executed in a guarded context, or is considered an “outer world” method.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GuardAttribute.#ctor(JetBrains.Threading.Rgc)">
            <summary>
            Defines the guarded context affinity of the method: whether it expects to be always executed in a guarded context, or is considered an “outer world” method.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.Rgc">
            <summary>
            <c>ReentrancyGuardContext</c>
            Defines the guarded context affinity of the method: whether it expects to be always executed in a guarded context, or is considered an “outer world” method.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.NotSpecified">
            <summary>
            There is no information regarding guarded context affinity yet.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Guarded">
            <summary>
            Must be guarded from reentrancy. Make sure to either take a <see cref="T:JetBrains.Threading.ReentrancyGuard"/> or call it from the guarded context.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Unguarded">
            <summary>
            Assumed to be executed in the “outer world” and must tage a <see cref="T:JetBrains.Threading.ReentrancyGuard"/> before calling any <see cref="F:JetBrains.Threading.Rgc.Guarded"/> things.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Invariant">
            <summary>
            Does not deal with <see cref="F:JetBrains.Threading.Rgc.Guarded"/> entities and can thus be used both in guarded and unguarded contexts.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Special">
            <summary>
            Neither <see cref="F:JetBrains.Threading.Rgc.Guarded"/> nor <see cref="F:JetBrains.Threading.Rgc.Unguarded"/> nor <see cref="F:JetBrains.Threading.Rgc.Invariant"/>.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Application.LocalReentrancyGuard">
            <summary>
            In the local scope, prevents reentrancy with own methods only.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Application.LocalReentrancyGuard.TryExecute(System.Action)">
            <summary>
            Executes the action, if not yet executing another one.
            </summary>
            <param name="action">Action.</param>
            <returns>Whether the action were executed.</returns>
        </member>
        <member name="M:JetBrains.UI.Application.LocalReentrancyGuard.Execute(System.Action)">
            <summary>
            Executes the action, if not yet executing another one.
            </summary>
            <param name="action">Action.</param>
        </member>
        <member name="T:JetBrains.Util.Concurrency.UnguardedCallbackMerger">
            <summary>
            <para>Allows to join expected callbacks from unguarded context into the current guarded context.</para>
            <para>When running in the guarded context, nest the actions that might cause callbacks from unguarded context within a <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/> call. <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/> will come <c>True</c>.</para>
            <para>In the callback handler, use <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(System.String,System.Action)"/>. If <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/>, it will be merged into the current guarded context (this is considered a reentrant-safe activity). Otherwise, <see cref="!:Threading.ReentrancyGuard.ExecuteOrQueue"/> will be used.</para>
            <para>Can be reused.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Threading.ReentrancyGuard,JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags)">
            <summary>
            Init.
            </summary>
            <param name="lifetime"></param>
            <param name="guard">Identifies the thread.</param>
            <param name="flags">Behavior flags &amp; options.</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(System.String,System.Action)">
            <summary>
            <para>Executes the <paramref name="F"/> in the guarded context.</para>
            <para>If <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/> (ie running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>), merges the call into the current guarded context. Otherwise, does the regular <see cref="!:Threading.ReentrancyGuard.ExecuteOrQueue"/>.</para>
            <para>Executes sync or async. Must be run on the <see cref="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ReentrancyGuard"/> thread.</para>
            <para>Catches all exceptions.</para>
            <para>The lifetime of this schedulled request is limited by the lifetime of this unguarded callbacks merger.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes the <paramref name="F"/> in the guarded context.</para>
            <para>If <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/> (ie running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>), merges the call into the current guarded context. Otherwise, does the regular <see cref="!:Threading.ReentrancyGuard.ExecuteOrQueue"/>.</para>
            <para>Executes sync or async. Must be run on the <see cref="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ReentrancyGuard"/> thread.</para>
            <para>Catches all exceptions.</para>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="!:Threading.ReentrancyGuard.TryExecute"/>-compatible behavior).</returns>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)">
            <summary>
            <para>Says that we're expecting callbacks from the unguarded context, and they should be allowed into the current context if they use <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(System.String,System.Action)"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback">
            <summary>
            Whether we're inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags">
            <summary>
            <see cref="T:JetBrains.Util.Concurrency.UnguardedCallbackMerger"/> behavior aspects.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.ExecutePendingLeftovers">
            <summary>
            <para>Use the default <see cref="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ReentrancyGuard"/> behavior: if the callbacks were queued for execution with <see cref="!:ReentrancyGuard.Queue"/>, they're not reclaimed after the owning object is disposed of, and will still have a chance to execute.</para>
            <para>This is the default.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.DropPendingLeftovers">
            <summary>
            <para>If there're any pending callbacks queued for execution with <see cref="!:ReentrancyGuard.Queue"/> at the moment the owning object is disposed of, they're dropped.</para>
            <para>No code submitted through this object will execute after it is disposed of.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.ProhibitNestedExpectations">
            <summary>
            <para>When running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>, nested calls to <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/> are prohibited. An attempt to place such a call will result in an exception.</para>
            <para>This is the default.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.AllowNestedExpectations">
            <summary>
            <para>When running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>, nested calls to <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/> are allowed.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates array that can exceed 2Gb per object limit of .NET
            </summary>
            <param name="length">The length of the array</param>
            <param name="chunkLength">The length of the one chunk. Must be pow of 2</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.#ctor(System.Int32)">
            <summary>
            Creates array with guarantee that data will not be allocated in LOH
            </summary>
            <param name="length">The count of array elements</param>
        </member>
        <member name="T:JetBrains.DataStructures.CyclicBuffer">
            <summary>
            A cyclic buffer, like a queue for bytes, but optimized for byte block operations. For reading and writing, use the provided <see cref="T:System.IO.Stream"/> interface.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer._end">
            <summary>
            End of used data range in <see cref="F:JetBrains.DataStructures.CyclicBuffer._storage"/>, non-inclusive (points after the last used byte, might be equal to storage length). Might be below <see cref="F:JetBrains.DataStructures.CyclicBuffer._start"/>, in which case the data loops around the buffer end.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer._start">
            <summary>
            Starts of used data range in <see cref="F:JetBrains.DataStructures.CyclicBuffer._storage"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer._storage">
            <summary>
            The cyclic storage.
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.ReadCore(System.Byte[],System.Int32,System.Int32,JetBrains.DataStructures.CyclicBuffer.OutputStream.BehaviorFlags,System.Boolean)">
            <summary>
            Implements reading from the stream (and also peeking at the data without spending the stored bytes).
            </summary>
            <param name="arTarget">Target for reading (as in <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>).</param>
            <param name="nTargetOffset">Target for reading (as in <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>).</param>
            <param name="nTargetCount">Target for reading (as in <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>).</param>
            <param name="behavior">Behavior when running out of buffer.</param>
            <param name="bAdvanceReadPosition">Spend the read bytes and decrease the number of bytes available in the storage. If <c>False</c>, just peeks at the stored data without modifying the storage.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.WriteCore(System.Byte[],System.Int32,System.Int32,JetBrains.DataStructures.CyclicBuffer.InputStream.BehaviorFlags)">
            <summary>
            Implements writing to the stream.
            </summary>
            <param name="arSource">Source for writing (as in <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/>).</param>
            <param name="nSourceOffset">Source for writing (as in <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/>).</param>
            <param name="nSourceCount">Source for writing (as in <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/>).</param>
            <param name="behavior">Behavior when running out of buffer.</param>
            <returns>The number of bytes actually written.</returns>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.Add(System.Byte)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.Contains(System.Byte)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array" /> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="array" /> is multidimensional.-or-<paramref name="arrayIndex" /> is equal to or greater than the length of <paramref name="array" />.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.-or-Type <c>T</c> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.Remove(System.Byte)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.Capacity">
            <summary>
            Gets or sets the capacity of the buffer storage, which is the maximum <see cref="P:JetBrains.DataStructures.CyclicBuffer.Count"/> it can hold without growing, which growing could be prohibited by setting the <see cref="P:JetBrains.DataStructures.CyclicBuffer.Input"/> <see cref="P:JetBrains.DataStructures.CyclicBuffer.InputStream.Behavior"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.Input">
            <summary>
            Gets the stream for writing to the buffer.
            </summary>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.Output">
            <summary>
            Gets the stream for reading from the buffer.
            </summary>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="T:JetBrains.DataStructures.CyclicBuffer.InputStream">
            <summary>
            <see cref="T:System.IO.Stream"/> for the <see cref="P:JetBrains.DataStructures.CyclicBuffer.Input"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.InputStream.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.InputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source. </param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream. </param>
            <param name="count">The maximum number of bytes to be read from the current stream. </param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin" /> parameter. </param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position. </param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.InputStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream. </param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream. </param>
            <param name="count">The number of bytes to be written to the current stream. </param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.InputStream.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.InputStream.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.InputStream.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.InputStream.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.InputStream.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer.InputStream.BehaviorFlags.WhenFullGrow">
            <summary>
            When there is no more room for writing, grows the storage.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer.InputStream.BehaviorFlags.WhenFullThrow">
            <summary>
            When there is no more room for writing, throws an exception.
            </summary>
        </member>
        <member name="T:JetBrains.DataStructures.CyclicBuffer.OutputStream">
            <summary>
            <see cref="T:System.IO.Stream"/> for the <see cref="P:JetBrains.DataStructures.CyclicBuffer.Output"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.OutputStream.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source. </param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream. </param>
            <param name="count">The maximum number of bytes to be read from the current stream. </param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin" /> parameter. </param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position. </param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.OutputStream.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.CyclicBuffer.OutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream. </param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream. </param>
            <param name="count">The number of bytes to be written to the current stream. </param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.OutputStream.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.OutputStream.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.OutputStream.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.OutputStream.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.CyclicBuffer.OutputStream.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer.OutputStream.BehaviorFlags.WhenEmptyReadLess">
            <summary>
            When there are no more bytes to read, returns the reduced read-bytes count.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.CyclicBuffer.OutputStream.BehaviorFlags.WhenEmptyThrow">
            <summary>
            When there are no more bytes to read, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkHashSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkHashSet`1.SetEquals(JetBrains.Util.DataStructures.ChunkHashSet{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkHashSet`1.IsSupersetOf(System.Collections.Generic.ICollection{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkHashSet`1.IsSupersetOf(JetBrains.Util.DataStructures.ChunkHashSet{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DataStructures.ChunkHashSet`1.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.DataStructures.ChunkHashSet`1.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ChunkHashMap`2">
            <summary>
            Reimplementation of Dictionary.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:JetBrains.Util.DataStructures.ChunkHashMap`2.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.DataStructures.ChunkHashMap`2.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.ImmutableArray`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Sightly optimized version where the count of the data is known before hand
            </summary>
            <param name="data"></param>
            <param name="count"></param>
        </member>
        <member name="T:JetBrains.DataStructures.StreamPipe">
            <summary>
            Pipes a stream-for-writing into a stream-for-reading.
            Allows to pipe an output from some <see cref="T:System.IO.StreamWriter"/> into a <see cref="T:System.IO.StreamReader"/> directly, without storing the full stream contents in memory.
            The pipe executes two functions, one for writing and one for reading. The execution terminates when both routines exit. After the writing routine exits, the reading has nothing more to read (<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> always returns zero), and should exit too.
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.Run(System.Action{System.IO.Stream},System.Action{System.IO.Stream})">
            <summary>
            Runs the writing and reading, synchronously, thru the pipe.
            </summary>
            <param name="funcWriter">This function is given the stream it should write to. Try to use reasonably sized blocks, if possible.</param>
            <param name="funcReader">This function is given the stream it should read from.</param>
        </member>
        <member name="T:JetBrains.DataStructures.StreamPipe.Streamer">
            <summary>
            <see cref="T:System.IO.Stream"/> plus some events.
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.Streamer.Flush">
            <summary>
            When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.Streamer.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source. </param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream. </param>
            <param name="count">The maximum number of bytes to be read from the current stream. </param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.Streamer.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            When overridden in a derived class, sets the position within the current stream.
            </summary>
            <returns>
            The new position within the current stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin" /> parameter. </param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position. </param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.Streamer.SetLength(System.Int64)">
            <summary>
            When overridden in a derived class, sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.Streamer.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream. </param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream. </param>
            <param name="count">The number of bytes to be written to the current stream. </param>
            <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.Streamer.CanRead">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports reading.
            </summary>
            <returns>
            true if the stream supports reading; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.Streamer.CanSeek">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
            </summary>
            <returns>
            true if the stream supports seeking; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.Streamer.CanWrite">
            <summary>
            When overridden in a derived class, gets a value indicating whether the current stream supports writing.
            </summary>
            <returns>
            true if the stream supports writing; otherwise, false.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.Streamer.Length">
            <summary>
            When overridden in a derived class, gets the length in bytes of the stream.
            </summary>
            <returns>
            A long value representing the length of the stream in bytes.
            </returns>
            <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.Streamer.Position">
            <summary>
            When overridden in a derived class, gets or sets the position within the current stream.
            </summary>
            <returns>
            The current position within the stream.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="T:JetBrains.DataStructures.StreamPipe.StreamPipeRun">
            <summary>
            The object for the <see cref="T:JetBrains.DataStructures.StreamPipe"/> run.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.StreamPipe.StreamPipeRun.MinDemandDefault">
            <summary>
            Default value for <see cref="P:JetBrains.DataStructures.StreamPipe.StreamPipeRun.MinDemand"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataStructures.StreamPipe.StreamPipeRun.Buffer">
            <summary>
            The buffer that caches writer's output until there's enough data for the reader to read the next block (more specifically, until <see cref="P:JetBrains.DataStructures.StreamPipe.StreamPipeRun.MinDemand"/> is met).
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipe.StreamPipeRun.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.StreamPipeRun.MinDemand">
            <summary>
            <para>When the reader exhaust the buffer, it claims the demand on minimum buffer size required to proceed (usually, the number of bytes requested in the read command), and yields to the writer to fulfill the demand.</para>
            <para>The <see cref="P:JetBrains.DataStructures.StreamPipe.StreamPipeRun.MinDemand"/> value limits the minimum reasonable demand so that to prevent the reader and the writer from yielding to each other too often, for example, if they are reading and writing byte-by-byte.</para>
            <para>Set to <c>0</c> to suppress min-demand and operate on actual demands.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataStructures.StreamPipe.StreamPipeRun.Demand">
            <summary>
            When the reader needs more bytes that avail, it publishes the demand and yields to the writer.
            </summary>
        </member>
        <member name="T:JetBrains.DataStructures.StreamPipeXml">
            <summary>
            Pipes an <see cref="T:System.Xml.XmlWriter"/> into an <see cref="T:System.Xml.XmlReader"/>.
            Allows to pipe an output from some <see cref="T:System.Xml.XmlWriter"/> into a <see cref="T:System.Xml.XmlReader"/> directly, without storing the full stream contents in memory.
            The pipe executes two functions, one for writing and one for reading. The execution terminates when both routines exit. After the writing routine exits, the reading has nothing more to read (<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> always returns zero), and should exit too.
            </summary>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipeXml.Run(System.Action{System.Xml.XmlWriter},System.Action{System.Xml.XmlReader})">
            <summary>
            Runs the writing and reading, synchronously, thru the pipe.
            </summary>
            <param name="FInput">This function is given the stream it should write to. Try to use reasonably sized blocks, if possible.</param>
            <param name="FOutput">This function is given the stream it should read from.</param>
        </member>
        <member name="M:JetBrains.DataStructures.StreamPipeXml.Run(System.Action{System.Xml.XmlWriter},System.Action{System.Xml.XmlReader,System.Xml.XmlWriter},System.Action{System.Xml.XmlReader})">
            <summary>
            Runs the writing and reading, synchronously, thru the pipe.
            </summary>
            <param name="FInput">This function is given the stream it should write to. Try to use reasonably sized blocks, if possible.</param>
            <param name="FTransform">This function sits in the middle of the pipe.</param>
            <param name="FOutput">This function is given the stream it should read from.</param>
        </member>
        <member name="T:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1">
            <summary>
            Represents an integer value with specific semantics that cannot be freely assigned to/from other ints.
            </summary>
            <typeparam name="TType">This type is not used for storing data values. It it solely used for distinguishing between typed intrinsics.</typeparam>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.Limited(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{`0},JetBrains.Util.dataStructures.TypedIntrinsics.Int32{`0})">
            <summary>
            Limits the current value. Returns a copy that's guaranteed to be in the <c>[</c><paramref name="minInclusive"/><c>, </c><paramref name="maxExclusive"/><c>)</c> limits.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.Minus1">
            <summary>
            Adds one to the current value.
            Does not modify the original object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.Plus1">
            <summary>
            Adds one to the current value.
            Does not modify the original object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IComparable#CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj"/>. Zero This instance is equal to <paramref name="obj"/>. Greater than zero This instance is greater than <paramref name="obj"/>. 
            </returns>
            <param name="obj">An object to compare with this instance. </param><exception cref="T:System.ArgumentException"><paramref name="obj"/> is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IComparable{JetBrains#Util#dataStructures#TypedIntrinsics#Int32{TType}}#CompareTo(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{`0})">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for this instance.
            </summary>
            <returns>
            The enumerated constant that is the <see cref="T:System.TypeCode"/> of the class or value type that implements this interface.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToBoolean(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent Boolean value using the specified culture-specific formatting information.
            </summary>
            <returns>
            A Boolean value equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToByte(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 8-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 8-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToChar(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent Unicode character using the specified culture-specific formatting information.
            </summary>
            <returns>
            A Unicode character equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToDateTime(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.DateTime"/> using the specified culture-specific formatting information.
            </summary>
            <returns>
            A <see cref="T:System.DateTime"/> instance equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToDecimal(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.Decimal"/> number using the specified culture-specific formatting information.
            </summary>
            <returns>
            A <see cref="T:System.Decimal"/> number equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToDouble(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent double-precision floating-point number using the specified culture-specific formatting information.
            </summary>
            <returns>
            A double-precision floating-point number equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToInt16(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 16-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 16-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToInt32(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 32-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 32-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToInt64(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 64-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 64-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToSByte(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 8-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 8-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToSingle(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent single-precision floating-point number using the specified culture-specific formatting information.
            </summary>
            <returns>
            A single-precision floating-point number equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToString(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.String"/> using the specified culture-specific formatting information.
            </summary>
            <returns>
            A <see cref="T:System.String"/> instance equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an <see cref="T:System.Object"/> of the specified <see cref="T:System.Type"/> that has an equivalent value, using the specified culture-specific formatting information.
            </summary>
            <returns>
            An <see cref="T:System.Object"/> instance of type <paramref name="conversionType"/> whose value is equivalent to the value of this instance.
            </returns>
            <param name="conversionType">The <see cref="T:System.Type"/> to which the value of this instance is converted. </param><param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToUInt16(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 16-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 16-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToUInt32(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 32-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 32-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IConvertible#ToUInt64(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 64-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 64-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider"/> interface implementation that supplies culture-specific formatting information. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.Equals(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{`0})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <returns>
            A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String"/> specifying the format to use.-or- null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation. </param><param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.-or- null to obtain the numeric format information from the current locale setting of the operating system. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DictionaryEx.Add``2(System.Collections.Generic.IDictionary{``0,``1},JetBrains.DataFlow.Lifetime,``0,``1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>, for a limited lifetime.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="lifetime">Lifetime for the item to be present in the dictionary.</param>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <param name="dictionary">Dictionary.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryEquals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Checks that two dictionaries contain the same values under the same keys.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryEquals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Checks that two dictionaries contain the same values under the same keys.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryGetHashCode``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Computes hash code for Dictionary.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DirectoryScanner">
            <summary>
            Nant-syntax wildcard matcher on file system trees
            </summary>
        </member>
        <member name="T:JetBrains.UI.ExpectedBackgroundColorHintMode">
            <summary>
            Mode how to treat ExpectedBackgroundColorHint property
            </summary>
        </member>
        <member name="F:JetBrains.UI.ExpectedBackgroundColorHintMode.Semblance">
            <summary>
            (Legacy mode) Render will tune foreground slightly to preserve original color as far as possible. 
            Use it when you need to preserve your foreground color primarily but you need to be able to read it. 
            Other words hint for the engine to just makes sure the foreground color is visible over the background color
            </summary>
        </member>
        <member name="F:JetBrains.UI.ExpectedBackgroundColorHintMode.Contrast">
            <summary>
            Render will try to obey maximum contrast. 
            Use it when you need good text experience (perception) no matter where it will render
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener">
            <summary>
            Listens to the Logger events and writes them down into a <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ILogEventListener">
            <summary>
            Consumes the activities reported to the <see cref="T:JetBrains.Util.Logging.Logger"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener.CreateFileLogger(System.String)">
            <summary>
            Creates a logger that logs to a file. Starts listening to the events immediately, dispose of to stop.
            </summary>
            <param name="identity">Helps distinguish the file name. Should be filename-friendly.</param>
        </member>
        <member name="M:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener.PushToLogger(JetBrains.Util.LoggingLevel)">
            <summary>
            Adds self to the logger, removes when this object is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions">
            <summary>
            Collects all of the exceptions logged while the object is alive.
            When the object is disposed of, or <see cref="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions"/> is manually called, throws out all of the recorded exceptions as a composite exception.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.myFCreateExceptionContainer">
            <summary>
            Allows to customize the container.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.#ctor">
            <summary>
            Records all of the logged exceptions. Throws them all out either on <see cref="M:System.IDisposable.Dispose"/> or <see cref="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions"/>.
            </summary>
            <remarks>
            A lifetimed version was removed and should be used. A lifetime would intercept all of the exceptions upon termination. Thus, everything we throw in Dispose would be lost (as there's no other logger listener after we're removed on Dispose).
            Install this object with C# using(){} construct outside any lifetime creation.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.#ctor(System.Func{JetBrains.Util.CompoundException})">
            <param name="FCreateExceptionContainer">
            Allows to customize the container.
            </param>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.Dispose(System.Boolean)">
            <summary>
            Forces the finalizable objects to check whether their <see cref="M:System.IDisposable.Dispose"/> contract was fulfilled.
            Reports all of the exceptions that have occurred within the listener's life.
            Detaches from the logger.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.RecycleLoggedExceptions">
            <summary>
            Returns the current <see cref="P:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.LoggedExceptions"/> object, and creates a new (empty) one instead of it.
            Does not actually throw the exception.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions">
            <summary>
            If there are any logged exceptions, throws them out.
            Cleans up the exceptions store for further uses.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions_ThrowSpecial(JetBrains.Util.CompoundException)">
            <summary>
            Allows to extract any nested exceptions of a special type (like, test framework "Ignore Test"), and throw them in a special manner.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.Dispose">
            <summary>
            Reports all of the exceptions that have occurred within the listener's life.
            Detaches from the logger.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.LoggedExceptions">
            <summary>
            Exceptions logged during the session.
            </summary>
        </member>
        <member name="T:JetBrains.Util.StreamUnderLifetime">
            <summary>
              <para>An adapter from <see cref="T:JetBrains.DataFlow.Lifetime"/>s world into the <see cref="T:System.IDisposable"/> world: if your provider can give a stream under a lifetime, but your consumer wants a stream that it will dispose.</para>
              <para>Gives you the lifetime under which you can get the stream from provider.</para>
              <para>Terminates this lifetime when your consumer disposes of this object.</para>
              <para>Prevents the original stream which you've received under the lifetime from being disposed of when the consumer disposes of this object (whether to dispose of that stream is up to the producer who's given the lifetime).</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.FilePersistence.SafeFileThrowAwayAccess">
            <summary>
            Helper for reading and writing throw-away files (if the content is corrupted or there's an error reading it, it can be safely dropped and re-created (<c>False</c> result reported to caller).
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.GetTempPath">
            <summary>
            Returns the path of the current system's temporary folder. 
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.TryParse(System.String)">
            <summary>
            Parses a relative or absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.Parse(System.String)">
            <summary>
            Parses a relative or absolute path.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEvent.OldName">
            <summary>
            Old path for rename event, relative to watched directory
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEvent.ErrorMessage">
            <summary>
            Error message if Type is WatcherError
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatcherError">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatcherEventsBufferOverflow">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatchedDirectoryDeleted">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatchedDirectoryAborted">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPathEx">
            <summary>
            Extension methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetParentDirectories(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the parent directories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildDirectories(JetBrains.Util.FileSystemPath,System.String,JetBrains.Util.PathSearchFlags)">
            <summary>
            Gets the child directories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildren(JetBrains.Util.FileSystemPath,System.String,JetBrains.Util.PathSearchFlags)">
            <summary>
            Gets the child files or directories, or recurses into subdirectories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildFiles(JetBrains.Util.FileSystemPath,System.String,JetBrains.Util.PathSearchFlags)">
            <summary>
            Gets the child files.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.QuoteIfNeeded(JetBrains.Util.FileSystemPath)">
            <summary>
            Returns the full path, quoted if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.QuoteIfNeeded(JetBrains.Util.RelativePath)">
            <summary>
            Returns the full path, quoted if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.QuoteIfNeeded(JetBrains.Util.BackSlashSeparatedRelativePath)">
            <summary>
            Returns the full path, quoted if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.ToAbsolutePath(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Returns an absolute path.
            If the given path is already absolute (<see cref="P:JetBrains.Util.FileSystemPath.IsAbsolute"/>), leaves it as is.
            If the given path is relative, 
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathEx.FromDataAnonymousAssembly">
            <summary>
            See mono_image_open_from_data_with_name from image.c
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.TryGetPath(System.Reflection.Assembly)">
            <summary>
            For a file-based assembly, returns its path.
            If the assembly is not file-based, or the path could not be retrieved, returns <see cref="F:JetBrains.Util.FileSystemPath.Empty"/>.
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.Copy(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath,System.Boolean,System.Collections.Generic.ICollection{JetBrains.Util.FileSystemPath})">
            <summary>
            Copies either a file or a directory to the new location.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.String,System.Text.Encoding)">
            <summary>
            If the file already has this text (any encoding, ignores insignificant difference), won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.Byte[])">
            <summary>
            If the file already has these bytes, won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.IO.Stream)">
            <summary>
            If the file already has these bytes, won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.Delete(JetBrains.Util.FileSystemPath)">
            <summary>
            Deletes the item.
            In case of directory deletes recursively
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DeleteWithMoveAside(JetBrains.Util.FileSystemPath)">
            <summary>
            Deletes the item.
            In case of directory deletes recursively
            Does not fail if there is no such file or directory.
            Locked files are moved aside if they cannot be deleted, and their parent directories remain in place in such case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DeleteFileWithMoveAside(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Deletes the file. If the file is in use and cannot be deleted right now, moves it aside. This allows to still use the file name for writing the new file without immediately affecting the already-running process.
            </summary>
            <param name="path">The file to delete-with-move-aside.</param>
            <param name="dirMoveAsideDestination">Optionally, the folder into which the file should be moved-aside (by default, it's the file's original directory). This folder must be on the same volume for the move of a locked file to be successfull.</param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DoMoveAside(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Fn which does the MoveAside if nothing else worked.
            </summary>
            <param name="path"></param>
            <param name="dirMoveAsideDestination">Optionally, the folder into which the file should be moved-aside (by default, it's the file's original directory). This folder must be on the same volume for the move of a locked file to be successfull.</param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DeleteChildren(JetBrains.Util.FileSystemPath)">
            <summary>
            On a folder, deletes its children.
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.CleanUpChildren(JetBrains.Util.FileSystemPath,System.Collections.Generic.ICollection{JetBrains.Util.FileSystemPath})">
            <summary>
            On a folder, deletes its children.
            Does not fail if some file directory or file is failed to be removed (method return 'false' in this case)
            In case of all directories/files were removed, returns 'true' 
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPath">
            <summary>
            This class represents a path in the file system. It provides necessary methods for
            dealing with paths, and is more convenient for clients than raw strings, since it handles
            different separator characters, case etc
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.DeleteFile">
            <summary>
            Does not fail if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.DeleteFile(System.Boolean@,System.Int32)">
            <summary>
            Does not fail if there is no such file.
            </summary>
            <param name="isDirectory">return true if it is a directory</param>
            <param name="nAttempts"></param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.Unblock">
            <summary>
            Remove NTFS stream with sandboxing data.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.DeleteDirectoryNonRecursive">
            <summary>
            Deletes just an empty directory.
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.GetLongPath">
            <summary>
            Expands short name components in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.GetShortPath">
            <summary>
            Shrinks name components to their short form in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.CreateByCanonicalPath(System.String)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.TryParse(System.String)">
            <summary>
            Creates <see cref="T:JetBrains.Util.FileSystemPath"/> from string or <see cref="F:JetBrains.Util.FileSystemPath.Empty"/> if fails
            </summary>
            <param name="path"></param>
            <returns>Created path ot <see cref="F:JetBrains.Util.FileSystemPath.Empty"/></returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.Parse(System.String)">
            <summary>
            Create new <see cref="T:JetBrains.Util.FileSystemPath"/> from string. Throws exceptions if fails.
            </summary>
            <param name="path">Path string</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath"/></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path"/> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser"/> for details</exception>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.ParseRelativelyTo(System.String,JetBrains.Util.FileSystemPath)">
            <summary>
            Create new <see cref="T:JetBrains.Util.FileSystemPath"/> from string. Throws exceptions if fails.
            If the string represents an absolute path, just parses it as with <see cref="M:JetBrains.Util.FileSystemPath.Parse(System.String)"/>.
            If the string represents a relative path, treats it as relative to <see cref="!:basePathForRelativeStrings"/> to make an absolute path.
            This is the same as calling <see cref="M:JetBrains.Util.FileSystemDefinition.Parse(System.String)"/> and then <see cref="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath,JetBrains.Util.FileSystemPath)"/> (you can use the same path to get an analogy for <see cref="M:JetBrains.Util.FileSystemPath.TryParse(System.String)"/>).
            </summary>
            <param name="path">Path string</param>
            <param name="basePathForRelativeStrings">If <paramref name="path"/> represents a relative path, it's relative to this base.</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath"/></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path"/> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser"/> for details</exception>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.Combine(System.String)">
            <summary>
            Combines a path with one or more path components. Throws on failure.
            </summary>
            <remarks>
            Returns itself if component is null.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.ToDirectoryUri">
            <summary>
            Creates a system <see cref="T:System.Uri"/> object from this instance, making sure it ends in a slash.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.ToUri">
            <summary>
            Creates a system <see cref="T:System.Uri"/> object from this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.TryCombine(System.String)">
            <summary>
            Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.FileSystemPath.Empty"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.GetCanonicalPath(System.String)">
            <summary>
            Gets the canonical path, returns <c>""</c> in case of a failure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.GetDriveName">
            <summary>
            Gets the drive letter, if the path is rooted under a Windows drive.
            For convenience, the letter will be returned in uppercase.
            If the path has no drive char, a zero value will be returned.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.GetRootDir">
            <summary>
            Takes the first <see cref="M:JetBrains.Util.FileSystemPath.GetPathComponents">path components</see>, as many as needed for a meaningful root dir. Would be <c>\\Server\Share\</c> for UNC, <c>/usr/</c> for Unix, and so on.
            The returned string has the trailing path separator.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.Directory">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.Parent">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.Exists">
            <summary>
            Gets whether this path exists in the file system, and whether it is a directory or a file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.Info">
            <summary>
            Gets various information about file or directory in one system call. Throws on I/O errors.
            </summary>
            <returns>File/directory information if entity exists, null if not</returns>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.ExistsDirectory">
            <summary>
            Gets whether this instance points to a directory, and that directory exists on disk.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.ExistsFile">
            <summary>
            Gets whether this instance points to a file, and that file exists on disk.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.ExtensionNoDot">
            <summary>
            Gets the file extension, without the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>bat</c></example>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.ExtensionWithDot">
            <summary>
            Gets the file extension, including the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>.bat</c></example>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.FileModificationTimeUtc">
            <summary>
            Gets the last write time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.FileCreationTimeUtc">
            <summary>
            Gets the creation time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.FileLastAccessedTimeUtc">
            <summary>
            Gets the last accessed time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.FileAccessPath">
            <summary>
            Special path for passing to functions working with FS
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.Name">
            <summary>
            Gets the local name of the file/directory (the component after the last separator).
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.IsHidden">
            <summary>
            Gets whether this file system path is a hidden file or folder.
            Returns <c>False</c> for nonexistent paths.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPath.IsSystem">
            <summary>
            Gets whether this file system path is a system file or folder.
            Returns <c>False</c> for nonexistent paths.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPath.Existence">
            <summary>
            Determines whether the file system entity exists as a file or as a directory (if it does not exist at all, we cannot tell whether it's a file or a directory).
            You can check for “any existence” by comparing the value to zero (missing value is <c>0</c>).
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPath.Existence.Missing">
            <summary>
            The file system entity represented by this <see cref="T:JetBrains.Util.FileSystemPath"/> does not exist in the file system, or is invalid (e.g. <see cref="P:JetBrains.Util.FileSystemPath.IsEmpty"/>).
            This is the zero value of the enum.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPath.Existence.File">
            <summary>
            This is a file that actually exists in the file system.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPath.Existence.Directory">
            <summary>
            This is a directory that actually exists in the file system.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FolderContentCache">
            <summary>
            FolderContentCache is an utility class intended to use for folders that are 
            - never deleted
            - seldom change
            The cache should be cleared by it's creator.
            </summary>
        </member>
        <member name="T:JetBrains.Util.GenericIComparableCache">
            <summary>
              <para>Cached caller for generic <see cref="T:System.IComparable`1"/> interface on untyped objects.</para>
              <para>Caches call info so that not to use reflection when working on known types.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.GenericIComparableCache.ComparerHelperMethodGenericDefinition">
            <summary>
            Pre-calculated reflection object of <see cref="M:JetBrains.Util.GenericIComparableCache.InvokeCompareTo``1(System.Object,System.Object)"/>, for making a delegate off it.
            </summary>
        </member>
        <member name="F:JetBrains.Util.GenericIComparableCache.myFGetComparableSpecializations">
            <summary>
            Cache fn.
            </summary>
        </member>
        <member name="F:JetBrains.Util.GenericIComparableCache.myFGetInvocation">
            <summary>
            Cache fn.
            </summary>
        </member>
        <member name="F:JetBrains.Util.GenericIComparableCache.myComparableSpecializations">
            <summary>
            Cache. Thread-static to avoid concurrency issues.
            </summary>
        </member>
        <member name="F:JetBrains.Util.GenericIComparableCache.myCompareInvocationsCache">
            <summary>
            Cache. Thread-static to avoid concurrency issues.
            </summary>
        </member>
        <member name="M:JetBrains.Util.GenericIComparableCache.TryCompare(System.Object,System.Object)">
            <summary>
              <para>Cached caller for generic <see cref="T:System.IComparable`1"/> interface on untyped objects.</para>
              <para>Caches call info so that not to use reflection when working on known types.</para>
            </summary>
            <param name="ɑ">This is tested for <see cref="T:System.IComparable`1"/> interface.</param>
            <param name="β">This is passed into the <see cref="T:System.IComparable`1"/> of the first parameter, if matches the generic type.</param>
            <returns>NULL, if either <paramref name="ɑ"/> does not implement <see cref="T:System.IComparable`1"/>, or none of its <see cref="T:System.IComparable`1"/> can take <paramref name="β"/> as a parameter. The <see cref="M:System.IComparable`1.CompareTo(`0)"/> call result, otherwise.</returns>
        </member>
        <member name="M:JetBrains.Util.GenericIComparableCache.GetComparableSpecializations(System.Type)">
            <summary>
            Generic params of all the <see cref="T:System.IComparable`1"/> interfaces on this type.
            Cached per type per thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.GenericIComparableCache.GetInvocation(System.Type)">
            <summary>
            Creates a delegate for calling <see cref="M:System.IComparable`1.CompareTo(`0)"/> of a certain type without reflection.
            Cached per type per thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.GenericIComparableCache.InvokeCompareTo``1(System.Object,System.Object)">
            <summary>
            Helper method to lift the genericity off the <see cref="T:JetBrains.Util.GenericIComparableCache.CompareToDelegate"/>, so that it could be cached and called with objects.
            </summary>
        </member>
        <member name="T:JetBrains.Util.GenericIComparableCache.CompareToDelegate">
            <summary>
            Delegate for <see cref="M:JetBrains.Util.GenericIComparableCache.InvokeCompareTo``1(System.Object,System.Object)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Graph.DirectedGraphVirtualized`1">
            <summary>
            <para>An implementation of the <see cref="T:JetBrains.Util.Graph.IDirectedGraph`1"/> interface which does not store all of the dependencies and items inside, but delegates to lookup methods </para>
            instead.
            <para>Useful if you got a projection from some other data structure which is better to calculate on demand instead of loading all of the relations into the structure beforehand.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.IdentityFunc`2">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="T:JetBrains.Util.IdentityFunc`1">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.DpiResolution">
            <summary>
            Specifies the DPI resolution of some device, or device-independent 96 DPI.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.DpiResolution.CurrentScreenDpi">
            <summary>
            Gets the current device-dependent DPI value of the screen device.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.DpiResolution.DeviceIndependent96Dpi">
            <summary>
            Gets the WPF-standard device-independent resolution of 96x96 DPI.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.DpiResolution.NotSure">
            <summary>
            Use this as a temporary placeholder when you're not sure which resolution is in effect. Such cases should be adressed later.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.DpiResolution.DpiX">
            <summary>
            <para>Gets the resolution along the X-axis.</para>
            <para>Note that for an uninitialized structure this returns the device-independent DPI of 96.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.DpiResolution.DpiY">
            <summary>
            <para>Gets the resolution along the X-axis.</para>
            <para>Note that for an uninitialized structure this returns the device-independent DPI of 96.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.DpiUtil.DpiHorizontalFactor">
            <summary>
            It is DpiX / 96. (96 is default value of DPI in Windows)
            This factor can be used to multiply your size to scale it to user DPI settings
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.DpiUtil.DpiVerticalFactor">
            <summary>
            It is DpiY / 96. (96 is default value of DPI in Windows)
            This factor can be used to multiply your size to scale it to user DPI settings
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.DpiUtil.ScreenDpi">
            <summary>
            Gets the screen DPI along X and Y axes.
            </summary>
        </member>
        <member name="T:JetBrains.UI.CrossFramework.JetElementHost">
            <summary> 
            A Windows Forms control for hosting Avalon elements.
            As compared to the standard one, does not support WinForms transparency and backcolor inheritance, and thus does not waste memory on background color buffers.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.JetElementHost.Child">
            <summary> 
             The user-defined Avalon element in this host.
            </summary> 
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.HwndSourceHook(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Boolean@)">
            <summary> 
            Hook for the HwndSource.WndProc. 
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.InputManager_PostProcessInput(System.Object,System.Windows.Input.ProcessInputEventArgs)">
            <summary>
                Catch WM_CHAR messages which weren't handled by Avalon 
                (including mnemonics which were typed without the "Alt" key) 
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.IsInputChar(System.Char)">
            <summary>
                Ensures that all WM_CHAR key messages are forwarded to the hosted element.
            </summary>
            <internal> 
                Grab all WM_CHAR messages as text input to ensure they're sent to
                Avalon.  If Avalon doesn't handle the message, we will call 
                ProcessDialogChar later on. 
            </internal>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.OnGotFocus(System.EventArgs)">
            <summary> 
            Raises the GotFocus event.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.OnLeave(System.EventArgs)">
            <summary>
            Raises the Leave event. 
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)">
            <summary>
            Processes a command key, ensuring that the hosted element has an opportunity to handle the command before normal Windows Forms processing. 
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.ProcessMnemonic(System.Char)">
            <summary> 
            Processes a mnemonic character, ensuring that the hosted element has an opportunity to handle the mnemonic before normal Windows Forms processing.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.Select(System.Boolean,System.Boolean)">
            <summary> 
                Activates the hosted element.
            </summary> 
        </member>
        <member name="M:JetBrains.UI.CrossFramework.JetElementHost.WndProc(System.Windows.Forms.Message@)">
            <summary> 
            Processes Windows messages. 
            </summary>
            <param name="m"></param> 
        </member>
        <member name="P:JetBrains.UI.CrossFramework.JetElementHost.TopLevelElement">
            <summary>
            The top-level Avalon element over the HWND.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.JetElementHost.IsSelectable">
            <summary>
            Exposes Windows.Forms.Control Selectable style.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.JetElementHost.DefaultSize">
            <summary> 
            Gets the default size of the control.
            </summary> 
        </member>
        <member name="T:JetBrains.UI.CrossFramework.JetElementHost.RootDecorator">
            <summary>
            The root element in this host.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.JetElementHost.RootDecorator.LastMeasureSize">
            <summary>
            Set when the control is requested to Measure by the Avalon infrastructure.
            Allows to know when the control wants to resize.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.NativeDll">
            <summary>
            Encapsulates a native DLL module. Use <see cref="T:JetBrains.Util.Interop.NativeDllsLoader"/> to get instances of this class.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDll.Handle">
            <summary>
            The DLL module handle.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDll.File">
            <summary>
            The absolute path to the DLL file on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDll.#ctor(System.Void*,JetBrains.Util.Interop.NativeDllKey,JetBrains.Util.FileSystemPath,JetBrains.Util.Interop.IDllLoader)">
            <summary>
            Internal constructor. Used by <see cref="T:JetBrains.Util.Interop.NativeDllsLoader"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDll.myMethods">
            <summary>
            The table of loaded DLL entry points.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDll.ImportMethod``1(System.String)">
            <summary>
            Gets a delegate instance for the specified DLL entry point.
            </summary>
            <typeparam name="TDelegate">The delegate type a DLL entry point to be converted to.</typeparam>
            <param name="methodName">The name of a DLL entry point.</param>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDll.CreateComObject(System.Guid)">
            <summary>
            Creates an instance of a COM object without the Registry information, by invoking its class factory.
            </summary>
            <param name="guidClsid">CLSID of the object to create.</param>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDll.CreateComObject``1">
            <summary>
            Creates an instance of a COM object without the Registry information, by invoking its class factory.
            </summary>
            <typeparam name="TType">The type of the object to create.</typeparam>
        </member>
        <member name="T:JetBrains.Util.Interop.NativeDll.DllGetClassObjectDelegate">
            <summary>
            A delegate for the DllGetClassObject function.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.NativeDll.ComObject">
            <summary>
            A wrapper for an instance of a COM object created by <see cref="M:JetBrains.Util.Interop.NativeDll.CreateComObject(System.Guid)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDll.ComObject.Instance">
            <summary>
            The instance of a COM object.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDll.ComObject.CLSID">
            <summary>
            CLSID of the object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDll.ComObject.As``1">
            <summary>
            Casts the object to the specified interface type.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.NativeDllsLoader">
            <summary>
              Helps to load and work with native DLL modules.
            </summary>
            <remarks>
              Calling <c>LoadLibrary</c> increments the reference count.
              Calling the <c>FreeLibrary</c> or <c>FreeLibraryAndExitThread</c> function decrements the reference count.
              The system unloads a module when its reference count reaches zero or when the process terminates (regardless of the
              reference count).
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDllsLoader.#cctor">
            <summary>
              Static constructor gets the current processor architecture and corresponding DLL subdirectory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDllsLoader.LoadDll(JetBrains.DataFlow.Lifetime,JetBrains.Util.RelativePath,JetBrains.Util.Interop.NativeDllsLoader.Options)">
            <summary>
              Loads the DLL module and returns an instance of <see cref="T:JetBrains.Util.Interop.NativeDll"/> class.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="relativePathWithoutSuffix">The name of a DLL to load.</param>
            <param name="options">See <see cref="T:JetBrains.Util.Interop.NativeDllsLoader.Options"/></param>
        </member>
        <member name="M:JetBrains.Util.Interop.NativeDllsLoader.GetDllDirectory(JetBrains.Interop.WinApi.ProcessorArchitecture,System.PlatformID,System.Boolean)">
            <summary>
              Returns the full path for DLLs of the specified processor architecture ("current assembly directory"\"processor
              architecture subdirectory").
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDllsLoader.Options.None">
            <summary>
              Nothing special
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.NativeDllsLoader.Options.Debug">
            <summary>
              Debug version of dlls
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.RegistryEx">
            <summary>
              Extensions for accessing Registry in an explicitly-defined view on 64-bit systems, regardless of the architecture of
              the currently running process.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.KEY_32">
            <summary>
              Flag to access virtualized WOW6432 hive on x64 regardless of the running process architecture (N/A on NT versions
              below 5.1).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.KEY_64">
            <summary>
              Flag to access native Registry hive on x64 regardless of the running process architecture (N/A on NT versions below
              5.1).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.InProcessSpecific(Microsoft.Win32.RegistryKey)">
            <summary>
              <para>
                Follows the system policy for Registry virtualization: in 64-bit processes, sees the native Registry, and in
                32-bit processes sees the emulated one. This works the same as default .NET Registry accessor methods.
              </para>
              <para>On a 32-bit system, all of the readers read the same.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.InSystemNative(Microsoft.Win32.RegistryKey)">
            <summary>
              <para>
                Operates on the system-native Registry view (64-bit on 64-bit systems), regardless of the current process
                architecture.
              </para>
              <para>
                This means that in a 32-bit process on a 64-bit system this reader won't be tricked into the WoW-64-32
                emulation Registry branch, but will read the system-real value.
              </para>
              <para>On a 32-bit system, all of the readers read the same.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.InWin32(Microsoft.Win32.RegistryKey)">
            <summary>
              <para>Operates on the 32-bit Registry view (WoW-64-32 emulation view on 64-bit systems).</para>
              <para>
                This means that in a 64-bit process on a 64-bit system this reader will still read the same value as any 32-bit
                process running in the WoW-64-32 emulation will do.
              </para>
              <para>On a 32-bit system, all of the readers read the same.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.LoadAppHive(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,JetBrains.Util.OnError,JetBrains.Util.Interop.RegistryEx.LoadExclusiveness)">
            <summary>
            Uses the <see cref="M:JetBrains.Interop.WinApi.Advapi32Dll.RegLoadAppKeyW(System.String,System.Void**,System.UInt32,System.UInt32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.myIsCustomRootKey">
            <summary>
            Normally, we'd only allow a limited set of root HKEYs as <see cref="F:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.myKeyBase"/>.
            Loading an app hive makes an exception to this rule because it's a “virtual root” which is a valid root yet not in the list of the special keys.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.CreateKey(JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.OnError)">
            <summary>
              <para>Creates a key.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the key was successfully created.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.DeleteKey(JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.OnError)">
            <summary>
              <para>Deletes a key.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the key was successfully deleted.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.DeleteValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Deletes a value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully deleted.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetRawValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.UInt32@,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a raw value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="valuetype">Return value type</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetDwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a DWORD value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetQwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a QWORD value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetStringValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a string value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetStringArrayValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a string array value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetBinaryValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a binary value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetDwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.UInt32,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a DWORD value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="datavalue">DWORD value.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetQwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.UInt64,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a QWORD value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="datavalue">QWORD value.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetStringValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a string value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="datavalue">String value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetStringArrayValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.String[],JetBrains.Util.OnError)">
            <summary>
              <para>Writes a string array value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="datavalue">String value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetBinaryValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.Byte[],JetBrains.Util.OnError)">
            <summary>
              <para>Writes a string value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c>“”</c> for the default value.</param>
            <param name="datavalue">Byte array value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.LoadHive(JetBrains.DataFlow.Lifetime,JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.FileSystemPath,JetBrains.Util.OnError)">
            <summary>
              <para>Loads a Registry file on disk to work with it as with normal Registry.</para>
              <para>You might have to call <see cref="M:JetBrains.Interop.WinApi.Privileges.Adjust(System.Diagnostics.Process,JetBrains.Interop.WinApi.Privileges.NameAndAttributes[],System.Boolean)"/> to enable <see cref="F:JetBrains.Interop.WinApi.SeName.SE_RESTORE_NAME"/> and <see cref="F:JetBrains.Interop.WinApi.SeName.SE_BACKUP_NAME"/> before doing this for the first time.</para>
              <para>The only valid root keys for this are <see cref="F:Microsoft.Win32.Registry.LocalMachine"/> and <see cref="F:Microsoft.Win32.Registry.Users"/>.</para>
            </summary>
            <param name="lifetime"></param>
            <param name="subKey">Subpath into which the registry will be mounted.</param>
            <param name="fileName">Disk file with reg hive.</param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.LoadExclusiveness.AllowLoadingConcurrently">
            <summary>
            Does not prevent other clients from mapping the same file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.LoadExclusiveness.LoadExclusively">
            <summary>
            Prevents other clients from loading the same Registry file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.ShellLinkHelper.ExtensionNoDot">
            <summary>
            Shell link file extension.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.ShellLinkHelper.ExtensionWithDot">
            <summary>
            Shell link file extension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.ShellLinkHelper.CreateLink(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Creates a new Shell Link.
            </summary>
            <param name="pathLnkFile">The location of the newly-created .LNK file.</param>
            <param name="pathLinkTarget">The target this .LNK file will be pointing to.</param>
        </member>
        <member name="M:JetBrains.Util.Interop.ShellLinkHelper.ResolveLinkTarget(JetBrains.Util.FileSystemPath)">
            <summary>
            Given a path to an .LNK file, reads the target path of the shell link.
            </summary>
            <param name="pathLnk"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Progress.IProgressIndicatorModel">
            <summary>
            A data-only presentation of the <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> state.
            While <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> is producer-oriented, the <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> is intended for consumers.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction">
            <summary>
            <para>The current position of the progress, in the [0..1] range, inclusive.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning">
            <summary>
            Whether the producer thinks it's currently running. <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> SHOULD be at <c>1</c> when done running.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc.True">
            <summary>
            Function that always returns True
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc.False">
            <summary>
            Function that always returns False
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.True">
            <summary>
            Function that always returns True
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.False">
            <summary>
            Function that always returns False
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.Identity">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.IdentityConverter">
            <summary>
            Identity converter that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`2.True">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`2.False">
            <summary>
            Identity converter that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="T:JetBrains.Util.CountingLogger">
            <summary>
            Counts the number of processed events (forwarded to the underlying logger) without storing a copy of them.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.LogLog">
            <summary>
            To record exceptions occured in logger and don't fall into infinite recursion
            </summary>
        </member>
        <member name="M:JetBrains.Util.LogUtil.GetUserFriendlyShortName(System.Object)">
            <summary>
            Generate a user friendly object name for logging. Compatible with Focus Monitor.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.LogManager.SetConfig(JetBrains.Util.Logging.LogConfigModel)">
            <summary>
            Programming API for set hierarchical logger
            </summary>
            <param name="model"></param>
        </member>
        <member name="P:JetBrains.Util.Logging.LogManager.DisableFileAutoUpdates">
            <summary>
            When true, no new configuration is beeing read from file
            </summary>
        </member>
        <member name="T:JetBrains.Util.RecordAndThrowLogger">
            <summary>
            Records all of the exceptions, throws them out when object lifetime is terminated.
            Messages are dropped.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RecordAndThrowLogger.#ctor(JetBrains.DataFlow.Lifetime,System.Boolean)">
            <summary>
            Lifetime version. Throws when the lifetime terminates. Must not be disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RecordAndThrowLogger.#ctor(System.Boolean)">
            <summary>
            Disposable version. Throws when disposed of. Must be disposed of eventually.
            </summary>
        </member>
        <member name="T:JetBrains.Util.RecordingLogger">
            <summary>
            Intercepts all of the logger submissions, does not escalate them to any outer loggers.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ThrowWhatYouCanLogger">
            <summary>
            For any <see cref="M:JetBrains.Util.IExceptionThrowingLogger.LogOrThrowException(System.Exception,JetBrains.Util.ExceptionOrigin)"/>, does the throw thing. All other stuff is forwarded to the underlying logger.
            </summary>
        </member>
        <member name="T:JetBrains.Util.NamedPipes.AsyncMessageStreamReader">
            <summary>
            Reads packs of bytes from the stream, exactly as they were
            </summary>
        </member>
        <member name="F:JetBrains.Util.NamedPipes.AsyncMessageStreamReader.myBuffer">
            <summary>
            The active read buffer.
            The only buffer for single-chunk messages (that fit under buffer size).
            Each chunk in order for multi-chunk messages.
            </summary>
        </member>
        <member name="M:JetBrains.Util.NamedPipes.AsyncMessageStreamReader.#ctor(JetBrains.DataFlow.Lifetime,System.IO.Stream,System.Func{System.Boolean},System.Int32)">
            <summary>
            Inits.
            </summary>
            <param name="lifetime"></param>
            <param name="stream">The stream to read messages from.</param>
            <param name="FIsCompleteMessageReceived">As we've read a chunk of bytes from the stream, tells if this chunk represents a complete message (otherwise, the next chunk[s] should be appended to compose the complete message). For example, on a <see cref="T:System.IO.Pipes.PipeStream"/>, this is <see cref="P:System.IO.Pipes.PipeStream.IsMessageComplete"/>, which is available on its <see cref="T:System.IAsyncResult"/>, but somehow not exposed to the general public.</param>
            <param name="bufferSize">Default size of the buffer.</param>
        </member>
        <member name="F:JetBrains.Util.NamedPipes.AsyncMessageStreamReader.MessageReceived">
            <summary>
            There's a new pack of bytes.
            Fires for each received pack.
            </summary>
        </member>
        <member name="M:JetBrains.Util.NamedPipes.AsyncMessageStreamReader.BeginReadMessage">
            <summary>
            Initiates async reading.
            </summary>
        </member>
        <member name="T:JetBrains.Util.NamedPipes.AsyncServerPipeMessageReader">
            <summary>
            Reads packs of bytes from a pipe async.
            Wraps <see cref="T:JetBrains.Util.NamedPipes.AsyncMessageStreamReader"/>, but adds a wait for the pipe to be connected before actually starting any reads.
            </summary>
        </member>
        <member name="M:JetBrains.Util.NamedPipes.AsyncServerPipeMessageReader.BeginReadMessage">
            <summary>
            Initiates async reading.
            </summary>
        </member>
        <member name="P:JetBrains.Util.NamedPipes.AsyncServerPipeMessageReader.MessageReceived">
            <summary>
            There's a new pack of bytes.
            Fires for each received pack.
            </summary>
        </member>
        <member name="T:JetBrains.Util.NamedPipes.AsyncServerPipeObjectReader`1">
            <summary>
            Deserializes objects from a pipe working in the message mode.
            Extends <see cref="T:JetBrains.Util.NamedPipes.AsyncServerPipeMessageReader"/> by adding a deserializer.
            </summary>
        </member>
        <member name="F:JetBrains.Util.NamedPipes.AsyncServerPipeObjectReader`1.ObjectReceived">
            <summary>
            There's a new object.
            Fires for each received object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.NamedPipes.AsyncServerPipeObjectReader`1.BeginReadMessage">
            <summary>
            Initiates async reading.
            </summary>
        </member>
        <member name="T:JetBrains.Util.nameof">
            <summary>
            Class is used for getting a name of the property of the object in type safe way.
            </summary>
            <example>
            string s = "example";
            var lengthPropertyName = nameof.Property( () => s.Length );
            </example>
        </member>
        <member name="T:JetBrains.Util.nameof`1">
            <summary>
            Class is used for getting a name of the property of the type in type safely way without having an instance.
            </summary>
            <typeparam name="T">Type where interesting property declared.</typeparam>
            <example>var lengthPropertyName = nameof{ string }.Property( o => o.Length );</example>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.Assert(JetBrains.Interop.WinApi.HResults)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
            <remarks>Note: located here because we do not have ExtensionAttribute in Interop.WinAPI. In there, use <see cref="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])"/>.</remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.Assert(JetBrains.Interop.WinApi.HResults,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
            <remarks>Note: located here because we do not have ExtensionAttribute in Interop.WinAPI. In there, use <see cref="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])"/>.</remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.AssertSucceeded(System.Int32,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
            <remarks>Note: located here because we do not have ExtensionAttribute in Interop.WinAPI. In there, use <see cref="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])"/>.</remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.AssertSucceeded(System.UInt32,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
            <remarks>Note: located here because we do not have ExtensionAttribute in Interop.WinAPI. In there, use <see cref="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])"/>.</remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.AssertSucceeded(System.Int32)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
            <remarks>Note: located here because we do not have ExtensionAttribute in Interop.WinAPI. In there, use <see cref="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])"/>.</remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.Failed(JetBrains.Interop.WinApi.HResults)">
            <summary>
            The <c>FAILED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.HResultsEx.Succeeded(JetBrains.Interop.WinApi.HResults)">
            <summary>
            The <c>SUCCEEDED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Graphs.BiparititeGraphAlgorithms.MaximalMatching``2(JetBrains.Util.Graphs.IBipartiteGraph{``0,``1})">
            <summary>
            Finds maximal matching in bipartite graph using Hopcroft Karp algorithm
            http://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm
            </summary>
        </member>
        <member name="T:JetBrains.Util.ExceptionText">
            <summary>
            Result of rendering an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionText.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionText.FullText">
            <summary>
            <para>String representation of the exception rendered by collecting all of the data about the original exception and all of the inner/related exceptions in the tree.</para>
            <para>A more detailed and well-organized counterpart for <see cref="T:System.Exception"/>'s <see cref="M:System.Exception.ToString"/> method.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionText.Message">
            <summary>
            <para>Message of the exception, into which all of the inner exceptions' messages are also included.</para>
            <para>A more detailed counterpart for <see cref="T:System.Exception"/>'s <see cref="P:System.Exception.Message"/> property.</para>
            </summary>
        </member>
        <member name="T:JetBrains.UI.Application.LogEventListener">
            <summary>
            Listens for <see cref="T:JetBrains.Util.Logging.Logger"/> events, reports them to the consumer.
            Prevents reentrancy in handlers.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Application.LogEventListener.myIdentity">
            <summary>
            Identity.
            ACHTUNG ACHTUNG! Special handling in Equals.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Application.LogEventListener.myNoReentrancy_HasEntered">
            <summary>
            Reentrancy in these handler methods most probably means infinite recursion.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.#ctor(System.String,System.Action{JetBrains.Util.LogEvent})">
            <summary>
            Creates a listener that could be matched by its identity which prevents adding more than one instance with the same identity to the logger.
            An empty string is considered to be the unique identity.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.Equals(JetBrains.UI.Application.LogEventListener)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:JetBrains.UI.Application.LogEventListener.Identity">
            <summary>
            A listener that could be matched by its identity which prevents adding more than one instance with the same identity to the logger.
            An empty string is considered to be the unique identity.
            </summary>
        </member>
        <member name="E:JetBrains.UI.Application.LogEventListener.OnException">
            <summary>
            <see cref="M:JetBrains.Util.LoggingLevelEx.IsSeriousError(JetBrains.Util.LoggingLevel)"/>.
            </summary>
        </member>
        <member name="E:JetBrains.UI.Application.LogEventListener.OnMessage">
            <summary>
            Not <see cref="M:JetBrains.Util.LoggingLevelEx.IsSeriousError(JetBrains.Util.LoggingLevel)"/>.
            </summary>
        </member>
        <member name="E:JetBrains.UI.Application.LogEventListener.OnLogEvent">
            <summary>
            <see cref="M:JetBrains.Util.ILogEventListener.OnLogEvent(JetBrains.Util.LogEvent)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.src.NounUtilResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:JetBrains.Util.src.NounUtilResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:JetBrains.Util.src.NounUtilResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicatorBase.Fraction">
            <summary>
            Gives out the progress value as a floating point number in the [0…1] range.
            </summary>
        </member>
        <member name="T:JetBrains.Util.OnError">
            <summary>
            Option for the functions that serve as a <c>[NotNull]</c> or <c>[CanBeNull]</c> implementation, depending on the settings.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.#ctor(System.String,System.Action{System.Exception},System.Boolean)">
            <summary>
            Initializes with the handler to be called on <see cref="M:JetBrains.Util.OnError.Handle(System.Exception)"/>. Name is for reviewing the onerror kind in the debugger.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.Ignore">
            <summary>
            A handler that ignores failures.
            Provides for silent-<c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.LogException">
            <summary>
            A handler that reports the exceptions and then continues execution.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.LogExceptionSilently">
            <summary>
            A handler that reports the exceptions and then continues execution.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.Throw">
            <summary>
            A handler that always throws an exception.
            When the calling function is properly implemented, provides for <c>[NotNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.ThrowMessage(System.String)">
            <summary>
            A handler that always throws an exception.
            When the calling function is properly implemented, provides for <c>[NotNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.LogAssertion(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as an assertion to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.LogAlgorithmError(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as an algorithm error to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Error(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as an algorithm error to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Warn(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as a warning to that logger. This is analogous to the old <c>LogExceptionSilently</c> method.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Verbose(JetBrains.Util.ILogger,System.String)">
            <summary>
            A handler that logs the exception as a verbose message to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.LogForeignException(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as a foreign error to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Handle(System.Exception)">
            <summary>
            <para>Called by a not-null-or-can-be-null function when an exception-worth error occurs. Could throw, store, or ignore the failure.</para>
            <para>The calling code must be ready that an exception might be thrown out (<c>[NotNull]</c> case).</para>
            <para>The calling code must be ready that execution might continue (<c>[CanBeNull]</c> case should return <c>Null</c> if so).</para>
            <para>Typical usage:</para>
            <code>
            if(isFailed)
            {
                onerror.Handle(new InvalidOperationException("FAIL").AddData("More", () => "Info"));  // Throws in [NotNull] case
                return null;  // Executes in [CanBeNull] case
            }
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.WithMessage(System.String)">
            <summary>
            Creates a new <see cref="T:JetBrains.Util.OnError"/> object which wraps the handled exception with a given message exception before passing control to the current <see cref="T:JetBrains.Util.OnError"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Catch(System.Action)">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Catch``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="func"/> and returns its result or default value if exception happens.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="P:JetBrains.Util.OnError.IsIgnoringMessage">
            <summary>
            A technical helper which allows to avoid forming a complex exception in case the caller is only interested in the null/notnull result and won't be using the exception message.
            Only use if there're performance reasons.
            This flag should have no impact other than performance of forming the exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Returns an absolute path: if <see cref="T:JetBrains.Util.IPath"/> is already absolute, then it's left untouched. If relative, it's applied to <see cref="!:pathBaseForRelative"/> to get the absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.MakeAbsoluteBasedOn(JetBrains.Util.IPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Returns an absolute path: if <see cref="T:JetBrains.Util.IPath"/> is already absolute, then it's left untouched. If relative, it's applied to <see cref="!:pathBaseForRelative"/> to get the absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath)">
            <summary>
            Returns an absolute path if <see cref="T:JetBrains.Util.IPath"/> is absolute; otherwise, <c>NULL</c> or empty.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AssertAbsolute(JetBrains.Util.IPath)">
            <summary>
            Asserts the path is absolute and casts it to <see cref="T:JetBrains.Util.FileSystemPath"/>; throws on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AsRelative(JetBrains.Util.IPath)">
            <summary>
            Returns an relative path if <see cref="T:JetBrains.Util.IPath"/> is relative; otherwise, <c>NULL</c> or empty.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AssertRelative(JetBrains.Util.IPath)">
            <summary>
            Asserts the path is absolute and casts it to <see cref="T:JetBrains.Util.FileSystemPath"/>; throws on failure.
            </summary>
        </member>
        <member name="T:JetBrains.Util.PersistentMap.UnsafeStructAsIsMarshaller`1">
            <summary>
            Does not work with generic types! 
            This class is example of work with raw bytes.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Util.PersistentMap.UnsafePairMarshaller`2">
            <summary>
            Marshalls generic pairs
            </summary>
            <typeparam name="T1">Type of the first element of the pair</typeparam><typeparam name="T2">Type of the second element of the pair</typeparam>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReader.ReadCollection``2(JetBrains.Util.PersistentMap.UnsafeReader.ReadDelegate{``0},System.Func{System.Int32,``1})">
            <summary>
            Non optimal collection serialization. One can serialize internal structure (eg. array) instead.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCol"></typeparam>
            <param name="ptr"></param>
            <param name="readDelegate"></param>
            <param name="contructor"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.Alloc(System.Int32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Take the <see cref="P:JetBrains.Util.PersistentMap.UnsafeWriter.Ptr"/> value before calling <see cref="M:JetBrains.Util.PersistentMap.UnsafeWriter.Alloc(System.Int32)"/> to address the space correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.Write``2(JetBrains.Util.PersistentMap.UnsafeWriter.WriteDelegate{``0},``1)">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.ProcessCancelledException">
            <summary>
            A special Platform exception that fires when an interruptible activity is aborted.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.ProgressIndicator">
            <summary>
            <para>A self-container progress indicator implementations.</para>
            <para><see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> should be given to producers, and the consumers make use of this instance thru its <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/>.</para>
            <para>By default, no special threading model is implied on the members. They could be modified on any thread and fire changes on any thread.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myAdvanceFactor">
            <summary>
            The factor to be applied to the <see cref="!:Advance"/> units to make them <see cref="P:JetBrains.Application.Progress.ProgressIndicator.Fraction"/> units.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myEpsilon">
            <summary>
            Epsilon for the <see cref="T:System.Double"/> parameters of the progress.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myFraction">
            <summary>
            Model item.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myIsCanceled">
            <summary>
            Model item.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myIsRunning">
            <summary>
            Model item.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myName">
            <summary>
            Model item.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myStepName">
            <summary>
            Model item.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#Advance(System.Double)">
            <summary>
            <para>Advances the progress within the range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> call.</para>
            <para><see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> MUST be called first.</para>
            </summary>
            <param name="units">A whole or fractional number of units from the [0..totalWorkUnits] range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> method.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#Start(System.Int32)">
            <summary>
            <para>Starts the progress to run through the [0..range] range. You MUST call <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> at the end. Use <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> to identify the current execution span, once per <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>, and change the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> when doing <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="range">The inclusive upper limit of the progress range.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#Stop">
            <summary>
            <para>Completes the progress run. You MUST call <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> if you previously called <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>.</para>
            <para>Generally, you SHOULD always call the <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>-<see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> pair on the given indicator, even if gotten no items to process, so that a <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> could use up the parent range consistently.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.ReadonlyToken">
            <summary>
            An optional readonly token used by this object for accessing the <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> part.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#CurrentItemText">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#TaskName">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.Fraction">
            <summary>
            <para>The current position of the progress, in the [0..1] range, inclusive.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.IsRunning">
            <summary>
            Whether the producer thinks it's currently running. <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> SHOULD be at <c>1</c> when done running.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.Name">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.StepName">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            <para>Advances the progress by default fraction (1.0) within the range, as defined by the <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)"/> call.</para>
            <para><see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)"/> MUST be called first.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator,System.Double,System.Action{JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            <para>Advances the <paramref name="progressParent"/> by <paramref name="fUnitsInParentIndicator"/> units, while running the <paramref name="funcAdvanceSubprogress"/> task.</para>
            <para>Unlike the core <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> method, the increment goes gradually, as the <paramref name="funcAdvanceSubprogress"/> calls <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on the <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> it is given as a parameter. Note that its units are totally indipendent of the <paramref name="fUnitsInParentIndicator"/> in the <paramref name="progressParent"/>. Any range it chooses in its <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> will result in <paramref name="fUnitsInParentIndicator"/> advance of the parent.</para>
            </summary>
            <param name="progressParent">The parent progress.</param>
            <param name="fUnitsInParentIndicator">The number of units used up from the <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, when you do <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on this subprogress with any units of your liking.</param>
            <param name="funcAdvanceSubprogress">The subtask that gets its own subprogress.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSubProgress(JetBrains.Application.Progress.IProgressIndicator,System.Double)">
            <summary>
            <para>A sub-routine runs the whole <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run on the subprogress, with units of its own choice in <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> on the subprogress, which uses up only <paramref name="fUnitsInParentIndicator"/> in the parent <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>.</para>
            <para>This way, a few tasks could share the full progress range without knowing that they're using it together, each one running the whole length of its subprogress.</para>
            </summary>
            <param name="progressParent">The parent progress.</param>
            <param name="fUnitsInParentIndicator">The number of units used up from the <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, when you do <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on this subprogress with any units of your liking.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSubProgress(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
              <para>
                A sub-routine runs the whole <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>
                run on the subprogress, with units of its own choice in <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and
                <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> on the subprogress, in terms of its parent
                <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>.
              </para>
              <para>
                This way, a few tasks could share the full progress range without knowing that they're using it together,
                each one running the whole length of its subprogress.
              </para>
            </summary>
            <param name="progressParent">The parent progress.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSlowIndicator(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Returns slowed down progress indicator that is useful to test progress and cancellation support.
            Total progress duration is 10 seconds.
            </summary>
            <param name="progressIndicator">The parent progress to wrap.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSlowIndicator(JetBrains.Application.Progress.IProgressIndicator,System.TimeSpan)">
            <summary>
            Returns slowed down progress indicator that is useful to test progress and cancellation support.
            </summary>
            <param name="progressIndicator">The parent progress to wrap.</param>
            <param name="timeSpan">Total progress duration.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgressImpl``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean,System.Action{JetBrains.Application.Progress.IProgressIndicator,``0})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean,System.Action{``0,JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Action{``0,JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean,System.Action{``0})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Action{``0})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithProgressForEvery``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithSubProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.Double,System.String,System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.SelectWProgress``2(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Func{``0,``1})">
            <summary>
            A LINQ-like SELECT statement with progress.
            Works on <see cref="T:System.Collections.Generic.ICollection`1"/>, returns a committed <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <typeparam name="TSource">Source item types.</typeparam>
            <typeparam name="TResult">Resulting item types.</typeparam>
            <param name="source">Source items.</param>
            <param name="progress">The progress to track the source items iteration.</param>
            <param name="taskname">Name for the progress run.</param>
            <param name="selector">Selector function.</param>
            <returns>The resulting items.</returns>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)">
            <summary>
            <para>Starts the progress to run through the [0..totalWorkUnits] range. You MUST call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> at the end. Use <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> to identify the current execution span, once per <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>, and change the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> when doing <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <param name="sTaskName">The <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> value to be set for the run. You SHOULD NOT leave it unmodified, unless you are running a subprogress.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.StartProgress(JetBrains.Application.Progress.IProgressIndicator,System.Int32)">
            <summary>
            <para>Just call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and
            return the same instance of <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>.
            See <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> for details.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <returns>The same instance of IProgressIndicator in order to use fluent interface.</returns>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.StartProgress(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)">
            <summary>
            <para>Just call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and return the same instance of <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>. See <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> for details.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="taskName">The <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> value to be set for the run. You SHOULD NOT leave it unmodified, unless you are running a subprogress.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <returns>The same instance of IProgressIndicator in order to use fluent interface.</returns>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.StartStop(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String,System.Action)">
            <summary>
            <para>Starts the progress to run through the [0..totalWorkUnits] range, executes <paramref name="action"/>, and then stops the progress. Use <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> to identify the current execution span, once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>, and change the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> when doing <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <param name="taskName">The <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> value to be set for the run. You SHOULD NOT leave it unmodified, unless you are running a subprogress.</param>
            <param name="action">The task to execute in between <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.AnnotateInstanceMethod(System.Type,System.String,JetBrains.Util.Pair{System.String,System.String},System.Type[],System.Type)">
            <summary>
            Emits a wrapper with a user-chosen name to appear in the call stacks at runtime when the wrapped functionality is called.
            </summary>
            <param name="typeTargetMethodOwner">Object whose instance method is to be annotated. It should be passed as the first parameter to the delegate returned.</param>
            <param name="sTargetMethodName">Name of the method to be annotated.</param>
            <param name="sStackFrameText">Text to appear on the stack trace (the emitted method name).</param>
            <param name="typeParamsExceptThis">Types of instance method parameters (the implicit “this” parameter is not included).</param>
            <param name="typeRetVal">Return value type (or <c>Null</c> for void methods).</param>
            <returns>An Action or Func, first param is the instance type, then parameter types, then return value type (if any).</returns>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.AnnotateAction(JetBrains.Util.Pair{System.String,System.String})">
            <summary>
            Emits a wrapper with a user-chosen name to appear in the call stacks at runtime when the wrapped functionality is called.
            </summary>
            <param name="stackFrameText">Text to appear on the stack trace (the emitted method name).</param>
            <returns>An <see cref="T:System.Action`1"/> that takes an <see cref="T:System.Action"/>.</returns>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.AnnotateDelegate(JetBrains.Util.Pair{System.String,System.String},System.Boolean,System.Type[],System.Func{System.Type[],System.Type[]})">
            <summary>
            Emits a wrapper with a user-chosen name to appear in the call stacks at runtime when the wrapped functionality is called.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.Ldarg(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loags the given number of arguments on the stack, starting with #0 (“this” on an instance method).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.InterfaceImplementation.Ldarg(System.Reflection.Emit.ILGenerator,System.Int32,System.Boolean[])">
            <summary>
            Loags the given number of arguments on the stack, starting with #0 (“this” on an instance method).
            </summary>
        </member>
        <member name="T:JetBrains.Reflection.StringConversion">
            <summary>
            Helps with converting arbitrary types to and from strings.
            Calls into <see cref="T:System.ComponentModel.TypeDescriptor"/>'s <see cref="T:System.ComponentModel.TypeConverter"/>, and WPF's <see cref="T:System.Windows.Markup.ValueSerializer"/>, and handles some trivial cases on its own.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.ToInvariantString(System.Object,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">Value to be converted to a string.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.ParseInvariantString(System.String,System.Type,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">String representation.</param>
            <param name="type">Desired type of the object to be restored from the string representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.ParseInvariantString``1(System.String,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <typeparam name="T">Desired type of the object to be restored from the string representation.</typeparam>
            <param name="value">String representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.GetSomeLogger(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Either the <see cref="T:JetBrains.Util.ILogger"/> obtained from the <see cref="T:System.ComponentModel.ITypeDescriptorContext"/>, or the default logger dumping into the static <see cref="T:JetBrains.Util.Logging.Logger"/> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.GetTypeConverter(System.Type)">
            <summary>
            Caches <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)"/> results because it seems to walk the attributes every time, which takes considerable amount of times when doing repeated serializations in Settings.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.TryGetValueSerializer(System.Type)">
            <summary>
            <para>Looks up a serializer. Does not construct a fake serializer for wrapping the type converter (like <see cref="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)"/> does) if not found, but returns NULL.</para>
            <para>This is because a type-descriptor-converter wrapped into a value-converter would operate in the en-US locale while all previous calls of type-descriptor-converters operated in an invariant locale. We want all data previously written with an invariant type-converter to be now readable from persistent media, so we'd be calling type-descriptor-converters manually at the next stage.</para>
            <para>NOTE: logic for finding a <see cref="T:System.Windows.Markup.ValueSerializer"/>, as implemented at <see cref="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)"/>, is really this simple. That's why we can do it ourselves. On the contrary, getting a <see cref="T:System.ComponentModel.TypeConverter"/> is a hell of a work for the whole <see cref="T:System.ComponentModel.TypeDescriptor"/> subsystem, that's why we're not reimplementing it. Also, <see cref="T:System.Windows.Markup.ValueSerializerAttribute"/> refers to a type when given a <see cref="T:System.Type"/>, while <see cref="T:System.ComponentModel.TypeConverterAttribute"/> commits it into a string and sometimes has problems getting it back as a type.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.RelativePath">
            <summary>
            A relative path.
            </summary>
            <remarks>As the <see cref="T:JetBrains.Util.FileSystemPath"/> should only represent paths applicable to the file system, i.e. absolute paths, this class allows to store and perform path operations on relative paths.</remarks>
        </member>
        <member name="M:JetBrains.Util.RelativePath.#ctor(System.String)">
            <summary>
            Creates new instance.
            The constructor is left for backward compatibility only. Use <see cref="M:JetBrains.Util.FileSystemPath.Parse(System.String)"/> or <see cref="M:JetBrains.Util.FileSystemPath.TryParse(System.String)"/> instead.
            </summary>
            <param name="path">String that represents path</param>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws invalid path exception in case of invalid characters found.</exception>
        </member>
        <member name="M:JetBrains.Util.RelativePath.Parse(System.String)">
            <summary>
            Create new instance from string. Throws exceptions if fails.
            </summary>
            <param name="path">Path string</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath"/></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path"/> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Thrwos InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser"/> for details</exception>
        </member>
        <member name="M:JetBrains.Util.RelativePath.TryParse(System.String)">
            <summary>
            Creates <see cref="T:JetBrains.Util.FileSystemPath"/> from string or <see cref="F:JetBrains.Util.RelativePath.Empty"/> if fails
            </summary>
            <param name="path"></param>
            <returns>Created path ot <see cref="F:JetBrains.Util.RelativePath.Empty"/></returns>
        </member>
        <member name="M:JetBrains.Util.RelativePath.CreateByCanonicalPath(System.String)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.Combine(System.String)">
            <summary>
            Combines a path with one or more path components. Throws on failure.
            </summary>
            <remarks>
            Returns itself if component is null.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.RelativePath.ToDirectoryUri">
            <summary>
            Creates a system <see cref="T:System.Uri"/> object from this instance, making sure it ends in a slash.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.ToUri">
            <summary>
            Creates a system <see cref="T:System.Uri"/> object from this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.JetBrains#Util#IPath#TryCombine(System.String)">
            <summary>
            Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.RelativePath.Empty"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Util.RelativePath.Parent">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="T:JetBrains.Util.PathSearchFlags">
            <summary>
            Controls how <see cref="T:JetBrains.Util.FileSystemPath"/> looks for its sub-paths.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.RecurseIntoSubdirectories">
            <summary>
            If set, includes items in subfolders with the search. Otherwise looks among immediate children only.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.ExcludeHidden">
            <summary>
            Excludes items that have <see cref="F:System.IO.FileAttributes.Hidden"/> attribute set.
            In recursive mode will not exclude files in hidden directories.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.ExcludeFiles">
            <summary>
            Does not return paths that point to files.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.ExcludeDirectories">
            <summary>
            Does not return paths that point to directories.
            </summary>
        </member>
        <member name="F:JetBrains.Util.IsDisposedState.Live">
            <summary>
            The object is live and running.
            </summary>
        </member>
        <member name="F:JetBrains.Util.IsDisposedState.Disposing">
            <summary>
            The object is still valid, but has entered the disposal routine. Used to prevent the <see cref="M:System.IDisposable.Dispose"/> from reentrancy.
            </summary>
        </member>
        <member name="F:JetBrains.Util.IsDisposedState.Disposed">
            <summary>
            The object has been disposed of.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.EqualityComparer">
            <summary>
            Factory for anonmymous <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementations based on delegates provided.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.EqualityComparer.Create``1(System.Func{``0,``0,System.Boolean},System.Func{``0,System.Int32})">
            <summary>
            Returns equality comparer implementation from pair of delegates.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.EqualityComparer.Create``2(System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Returns equality comparer implementation projecting values to some keys using the delegate rule provided
            and comparing those keys with custom or default equality comparer for key type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.GetCustomAttributeByTypeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Gets custom attribute from reflection object that can provide custom attributes.
            </summary>
            <typeparam name="TAttribute">The type of attribute to find.</typeparam>
            <param name="attributeProvider">A reflection object that can provide custom attributes.</param>
            <param name="inherit">When true, look up the hierarchy chain for the inherited custom attribute.</param>
            <returns>The attribute instance if it is found successfully; otherwise, false.</returns>
            <exception cref="T:System.TypeLoadException">If the custom attribute type (<typeparamref name="TAttribute"/>) cannot be loaded.</exception>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.GetCustomAttributeNoInherit``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            For an attribute provider that has exactly one custom attribute of the given type, returns that attribute.
            Otherwise, throws.
            Inherited attributes are ignored.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.HasCustomAttributeNoInherit``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            For an attribute provider that has zero or one custom attribute of the given type, returns whether it's one not zero.
            Otherwise, throws.
            Inherited attributes are ignored.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.TryGetCustomAttributeNoInherit``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            For an attribute provider that has zero or one custom attribute of the given type, returns that attribute, or <c>Null</c> if none.
            Otherwise, throws.
            Inherited attributes are ignored.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.IWin32WindowEx.IsValidWindow(System.Windows.Forms.IWin32Window)">
            <summary>
            Checks that the window has a non-Null handle and that it represents a valid Win32 window.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.IWin32WindowEx.PushDisable(System.Windows.Forms.IWin32Window)">
            <summary>
            Disables the given window temporarily.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Read(System.IO.Stream,System.Byte[])">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads the whole stream contents.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ToMemoryStream(System.IO.Stream)">
            <summary>
            Reads the whole stream contents.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.StreamReader(System.IO.Stream,System.Action{System.IO.StreamReader})">
            <summary>
            Creates a stream reader over a stream.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.StreamWriter(System.IO.Stream,System.Action{System.IO.StreamWriter})">
            <summary>
            Creates a stream writer over a stream.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Rewind(System.IO.Stream)">
            <summary>
            <para>Rewinds the stream to the beginning so that it could be reused for reading.</para>
            <para>For example, this should be done to a <see cref="T:System.IO.MemoryStream"/> after writing and before each reading.</para>
            <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.EraseAndRewind(System.IO.Stream)">
            <summary>
            <para>Rewinds the stream to the beginning and removes its content so that it could be reused for writing.</para>
            <para>For example, this should be done to a <see cref="T:System.IO.MemoryStream"/> before reusing it for writing.</para>
            <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.StreamEquals(System.IO.Stream,System.IO.Stream,System.UInt32)">
            <summary>
            Compares the contents of two streams (both must be at position zero).
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="cdwChunkSize">Comparison chunks size, in DWORDs.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.WriteUtf8(System.IO.Stream,System.String)">
            <summary>
            Writes text in UTF-8 encoding.
            Spares additional allocations for strings which are not too long.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.AsSeekable(System.IO.Stream)">
            <summary>
            Wraps the stream if it's sequential-only, but leaves AS IS if it can seek already.
            </summary>
        </member>
        <member name="T:JetBrains.Extension.StreamEx.EncodingData">
            <summary>
            A nested class for lazy-creating stuff such as regexes and encodings when they are needed and not on any first access to this class.
            </summary>
        </member>
        <member name="T:JetBrains.Extension.TypeEx">
            <summary>
            Extension methods for <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetDefaultValue(System.Type)">
            <summary>
            Gets the default value for this reference or value type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValue(System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for this reference or value type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValue(System.Type,System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for this reference or value type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValueOrEmptyString(System.Type,System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for this reference or value type, or an empty string.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValueOrEmptyString(System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for its reference or value type, or an empty string.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.QuoteIfNeeded(System.Type)">
            <summary>
            Takes the type presentation, surrounds it with quotes if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.CoercePrimitiveValueToType(System.Object,System.Type,JetBrains.Util.ILogger)">
            <summary>
            <para>When a value has to be specified on an attribute, its type is limited to primitive types. Also, the primitive types might not match if an integer is specified where a floating-point type is expected.</para>
            <para>This method tries the following coersions:</para>
            <para>(*) NULL value: means the default value of the expected type. Also works for value types.</para>
            <para>(*) Exact type match: the given value is exactly of the expected type. Returns the value transparently.</para>
            <para>(*) Given a string value (the expected type is not a string): applies <see cref="T:System.ComponentModel.TypeConverter"/> to parse the invariant string into an object of the expected type.</para>
            <para>(*) Enum special case: if the expected type is an enum, and we're given its underlying type (maybe non-exact underlying type), <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> cannot handle that on its own.</para>
            <para>(*) System coersion (<see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> in invariant culture). Works for similar yet different primitive types, eg <see cref="T:System.Int32"/> and <see cref="T:System.UInt32"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetLocalNameFromFullTypeName(System.String,System.Boolean)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with “`” or “&lt;&gt;”, generic parameters recusrively specified inside “&lt;&gt;”, nested classes delimited with “.” or “+”.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetLocalNameFromFullTypeName(JetBrains.Util.StringSlice,System.Boolean)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with “`” or “&lt;&gt;”, generic parameters recusrively specified inside “&lt;&gt;”, nested classes delimited with “.” or “+”.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetLocalNameFromFullTypeName(JetBrains.Util.dataStructures.Sources.StringSource,System.Boolean)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with “`” or “&lt;&gt;”, generic parameters recusrively specified inside “&lt;&gt;”, nested classes delimited with “.” or “+”.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetTypeNameWithoutGenericArgs(System.String)">
            <summary>
            Strips possible generic args off the type name: grave accent “`”, angle brackets, square brackets, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetTypeNameWithoutGenericArgs(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Strips possible generic args off the type name: grave accent “`”, angle brackets, square brackets, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.EqualsTypeNameWithoutGenericArgs(JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Strips possible generic args off the type name: grave accent “`”, angle brackets, square brackets, etc; then checks if the result is equal to the given name which must have been already stripped of such.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetTypeNameWithoutGenericArgs(JetBrains.Util.StringSlice)">
            <summary>
            Strips possible generic args off the type name: grave accent “`”, angle brackets, square brackets, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetNamespaceFromFullTypeName(JetBrains.Util.StringSlice)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with “`” or “&lt;&gt;”, generic parameters recusrively specified inside “&lt;&gt;”, nested classes delimited with “.” or “+”.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetNamespaceFromFullTypeName(System.String)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with “`” or “&lt;&gt;”, generic parameters recusrively specified inside “&lt;&gt;”, nested classes delimited with “.” or “+”.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetNamespaceFromFullTypeName(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with “`” or “&lt;&gt;”, generic parameters recusrively specified inside “&lt;&gt;”, nested classes delimited with “.” or “+”.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FEx.Return``1(System.Action{System.Func{System.Func{``0},System.Action}})">
            <summary>
            <para>Allows to pass a return value thru a void-result <see cref="T:System.Action"/>.</para>
            <para>Suppose the following piece of code that should be surrounded with some pre- and post-activity:</para>
            <code>
            int GetResult()
            {
              return 5;
            }
            </code>
            <para>If the activity is available as an <see cref="T:System.IDisposable"/>, the code is surrounded with <c>using</c> without any problem with <c>return</c> statement:</para>
            <code>
            int GetResult()
            {
              using(EnterScope())
              {
                return 5;
              }
            }
            </code>
            <para>Suppose that the surrounding activity is implemented as a function that takes an <see cref="T:System.Action"/> to execute in the scope (e.g. <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>):</para>
            <code>
            int GetResult()
            {
              ExecuteInScope(delegate
              {
                return 5;  // Compilation error
              });
            }
            </code>
            <para>This won't compile, because <c>ExecuteInScope</c> is <c>void</c> and the action that it takes to execute is also <c>void</c>.</para>
            <para>A temp local variable could be an option to use it for assignment, but it's hard to maintain in case the inner action has multiple returns against various code paths.</para>
            <para>This <see cref="M:JetBrains.Util.FEx.Return``1(System.Action{System.Func{System.Func{``0},System.Action}})"/> function wraps the <c>ExecuteInScope</c> call and gives you a functor that turns your <c>int</c>-returning inner code into a <c>void</c> action suitable for the executor:</para>
            <code>
            int GetResult()
            {
              return FEx.Return&lt;int&gt;(FR =&gt; ExecuteInScope(FR(() =&gt;
              {
                return 5;
              })));
            }
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Graph.GraphAlgorithms.DepthFirstSearch``1(JetBrains.Util.Graph.IDirectedGraph{``0},``0,JetBrains.Util.Graph.GraphAlgorithms.PassingOnWayDownDelegate{``0},System.Action{``0},System.Action{``0})">
            <summary>
            A non-recursive DSF version suitable for bigger sets.
            Goes in the Outgoing direction. If you want the other direction, call the implementing utility function manually.
            </summary>
            <typeparam name="TNode"></typeparam>
            <param name="graph"></param>
            <param name="start">Initial point.</param>
            <param name="FEnteringOnWayDown">Will be called each time we're about to enter a node, for the first time or not. Allows to control whether to go further, inspect the path, etc.</param>
            <param name="FPassingOnWayDownSimple">Called when we're passing the node on the way down, before doing its children. By default, won't enter the same node for the second time (unless told to by <paramref name="FEnteringOnWayDown" />).</param>
            <param name="FPassingOnWayUp">Called when we're passing the node on the way up, after doing its children.</param>
        </member>
        <member name="M:JetBrains.Util.Graph.GraphAlgorithms.DepthFirstSearch``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}},JetBrains.Util.Graph.GraphAlgorithms.PassingOnWayDownDelegate{``0},System.Action{``0},System.Action{``0})">
            <summary>
            A non-recursive DSF version suitable for bigger sets.
            Operates on abstract graph structures.
            </summary>
            <typeparam name="TNode"></typeparam>
            <param name="rootcollection">Initial nodes.</param>
            <param name="FGetLinkedNodes">Walks the directional graph by getting the nodes linked to the given one.</param>
            <param name="FEnteringOnWayDown">Will be called each time we're about to enter a node, for the first time or not. Allows to control whether to go further, inspect the path, etc.</param>
            <param name="FPassingOnWayDownSimple">Called when we're passing the node on the way down, before doing its children. By default, won't enter the same node for the second time (unless told to by <paramref name="FEnteringOnWayDown" />).</param>
            <param name="FPassingOnWayUp">Called when we're passing the node on the way up, after doing its children.</param>
        </member>
        <member name="T:JetBrains.Util.Graph.GraphAlgorithms.PassingOnWayDownDelegate`1">
            <summary>
            A callback that we're passing a node on the way down (before processing its children).
            </summary>
            <param name="node">The current node.</param>
            <param name="visit">Whether we're visiting the node for the first time.</param>
            <param name="path">The current path how we got here, starting with the initial node of the search. The same list is reused for each call, take care!</param>
            <returns>How to go further.</returns>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.GoDownIfFirstTime">
            <summary>
            The default behavior for non-looping DFS: walk children if they haven't been visited yet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.GoDown">
            <summary>
            Proceed walking the node children, even if the node has already been visited. Take care of looping infinitely, but might be useful if you want to see all the paths for reaching the node.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.GoUp">
            <summary>
            Don't go into node's children at all, go up instead. The passing-on-way-up callback won't be called in this case.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.Abort">
            <summary>
            Don't walk anything else, exit immediately.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Graph.DirectedGraph`1.AddDependency(`0,`0)">
            <summary>
            Sets a directed edge between nodes. Does not fail if it's already set.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Graph.DirectedGraph`1.Nodes">
            <summary>
            Nodes as a collection.
            Allows effective <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> lookup, and adding/removing nodes consistently with dependencies.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddDataUnsafe``1(``0,System.String,System.Object)">
            <summary>
            <para>Adds some data to be reported with the exception.</para>
            <para>Note that the data is added as an object by default, and is not committed to text until the exception is rendered with <see cref="T:JetBrains.Util.ExceptionRenderer"/>.</para>
            <para>This method is unsafe because when you're reporting an unexpected condition which caused an exception, any objects from which you're reading the additional state are often also inconsistent and might cause secondary exceptions, which would mask the original exception or even get out of the safe environment. The use of overload with a lambda suppresses all exceptions caused by the lambda code execution. Only use the unsafe method for primitive expressions or when you're totally sure.</para>
            </summary>
            <param name="exception">The exception to enrich with data.</param>
            <param name="name">Data entry name. Must be unique with the exception.</param>
            <param name="value">Data entry value. For calculated values consider passing as a function for exception safety.</param>
            <returns>The same exception object, for fluent usages.</returns>
            <remarks>This method is non-conditional and will add the data even when in production mode.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})">
            <summary>
            Adds some data to be reported with the exception.
            Note that the data is added as an object by default, and is not committed to text until the exception is.
            </summary>
            <param name="exception">The exception to enrich with data.</param>
            <param name="name">Data entry name. Must be unique with the exception.</param>
            <param name="FValue"><para>Data entry value, passed as a func so that it were executed in a safe context (meaning that all of the exceptions in the data value retrieval are suppressed altogether).</para><para>When you're reporting an unexpected condition which caused an exception, any objects from which you're reading the additional state are often also inconsistent and might cause secondary exceptions, which would mask the original exception or even get out of the safe environment.</para></param>
            <returns>The same exception object, for fluent usages.</returns>
            <remarks>This method is conditional and won't create or execute the lambda when in production mode</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Object)">
            <summary>
            Adds some data to be reported with the exception.
            Note that the data is added as an object by default, and is not committed to text until the exception is.
            </summary>
            <param name="exception">The exception to enrich with data.</param>
            <param name="name">Data entry name. Must be unique with the exception.</param>
            <param name="value">Data entry value. For calculated values consider passing as a function for exception safety.</param>
            <returns>The same exception object, for fluent usages.</returns>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddDataIndirect``1(``0,System.Action{System.Exception})">
            <summary>
            Adds some data to be reported with the exception.
            Allows to call a data-adding function on some object that bears the exception context.
            The call is executed in a safe manner.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.FlattenDataValue(System.Object)">
            <summary>
            “Flattens” the data value by converting all of the objects to their string representation. Understands some kinds of collections.
            This is needed for safe marshalling of exceptions containing data values across appdomain boundaries. Keeping original object values might fail unmarshalling their custom types.
            // TODO: maybe use some parts of exception renderer for walking the value trees
            </summary>
            <param name="oValue"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.ExceptionRenderer">
            <summary>
            Renders exceptions by extracting as much data as possible (including inner exceptions in nonstandard properties, like <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions"/>, and special parameters like <see cref="P:System.ArgumentException.ParamName"/>), and presents them in human-readable and machine-readable format and in a reasonable order of inner exceptions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.GetAllNestedExceptions(System.Exception)">
            <summary>
            Looks up all of the exceptions in the exception tree. Checks for the <see cref="P:System.Exception.InnerException"/>, other possible exception properties (eg <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions"/>), and data bag. The original exception is too included with the collection.
            </summary>
            <param name="ex">The exception to look into.</param>
            <returns>The <paramref name="ex"/> plus all of the nested exceptions.</returns>
            <remarks>This method is slow somewhat and does not cache the results.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.RenderException(System.Exception,System.Collections.Generic.IDictionary{System.Object,System.Collections.Generic.IList{System.Object}})">
            <summary>
              <para>Renders a string representation of the exception by collecting all of the data about the original exception and all of the inner/related exceptions in the tree.</para>
              <para>Explicitly outlines the relation between the exceptions, like which is whose inner and where they're coming from in the inner-exception tree.</para>
              <para>Note that <see cref="P:System.Exception.Message"/> plus <see cref="P:System.Exception.StackTrace"/> might miss the custom fields of the exception, and <see cref="M:System.Exception.ToString"/> ignores related exceptions that are not exactly inners (eg <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions"/>).</para>
            </summary>
            <param name="ex">The exception to render.</param>
            <param name="customData"></param>
            <returns>
              <para>A string containing all of the meaningful messages of all the inner exceptions.</para>
              <para>A string with the above message plus stack traces and any other associated data.</para>
            </returns>
            <remarks>This method might be slow, but it caches the rendered data on the exception after the first call.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.RenderOuterExceptionMessageAndData(System.Exception)">
            <summary>
            Renders the exception message that includes all of the additional data fields, but of the outermost exception only.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.IsBusy">
            <summary>
            Per-thread recursion prevention flag. Might be leading to a stofl if happens.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.CollectExDatas(System.Exception)">
            <summary>
            Traverses the inner exceptions tree and extracts atomic datas ready for printing out.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.GetExceptionDataCached(System.Exception,System.String,System.Func{System.String})">
            <summary>
            Gets the value cached on the exception object.
            Calculates and caches if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.PrintExDatas(System.Collections.Generic.IList{JetBrains.Util.ExceptionRenderer.ExData})">
            <summary>
            All of the data is collected, entries are atomic, render them (just resolve the exception index references).
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.PrintExMessage(System.Collections.Generic.ICollection{JetBrains.Util.ExceptionRenderer.ExData})">
            <summary>
            Extracts the exception message out of the exceptions. In case the inner exceptions message is omitted from the outer exception, tries to collect all such messages too.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.RenderSingleExceptionObject(JetBrains.Util.ExceptionRenderer.ExData)">
            <summary>
            Starts rendering an exception object, walks into expandable properties depth-first.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.myParentStorage">
            <summary>
            Parent, for simplicity just an array.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.Lines">
            <summary>
            Exception data lines in the Name=Value form.
            In case an exception is encountered among data values, a new <see cref="T:JetBrains.Util.ExceptionRenderer.ExData"/> is created and a reference to it is written in a special form into the data lines (<see cref="T:JetBrains.Util.ExceptionRenderer.ExData.InnerExceptionReference"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.Guid">
            <summary>
            Uniquely identifies the exception, allows to reference it from parent exceptions (ref inner from outer).
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.AddInnerException(System.String,System.Exception)">
            <summary>
            Reports an inner exception of the current exception.
            </summary>
            <param name="relprefix">Path relative to the current object.</param>
            <param name="exIn">The inner exception to register.</param>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.AddPathLines">
            <summary>
            For every entry in the <see cref="F:JetBrains.Util.ExceptionRenderer.ExData.Paths"/>, adds a line to the head of the <see cref="F:JetBrains.Util.ExceptionRenderer.ExData.Lines"/> list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.DemoteLine(System.String)">
            <summary>
            Moves a line with the given name to be the last in the list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.PromoteLine(System.String)">
            <summary>
            Moves a line with the given name to be the first in the list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.WithLineByName(System.String,System.Action{JetBrains.Util.ExceptionRenderer.Line,System.Int32})">
            <summary>
            Find the line, exec if OK.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry">
            <summary>
            Storage class which represents a named data entry when traversing exception data recursively, either an object which can be further expanded, or a leaf data which should be reported to the full exception text.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Value">
            <summary>
            The value of this entry, either primitive or expandable, see <see cref="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKind"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Name">
            <summary>
            The full hierarchical name of the entry, root's being empty.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Depth">
            <summary>
            Current depth, root's being 0, tracked recursively to prevent infinite loops in exception data.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Root(System.Exception)">
            <summary>
            Starts enumeration with the root, which is always an exception.
            If an exception is at the root, it's expandable.
            If deeper, then it would be treated as a reference to another exception object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.DetectEntryKind(System.Object,System.Boolean)">
            <summary>
            Detects how this node should be treated — expanded into children, rendered as a primitive, dropped out, treated as a reference to an exception, etc.
            Detects by the value type.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKind">
            <summary>
            The <see cref="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.DetectEntryKind(System.Object,System.Boolean)">detected</see> kind of the entry.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.MaxDepth">
            <summary>
            Limits walking down expandable nodes to this many.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.MaxItems">
            <summary>
            Takes only so many items from a collection.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.GetChildren">
            <summary>
            Expands into child entries, if this one is of an expandable kind.
            Otherwise, yields empty.
            Applies recursion and item count limitations.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Render(JetBrains.Util.ExceptionRenderer.ExData)">
            <summary>
            Renders as an exception data line, if applicable (a primitive or a reference to an exception).
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Render_Primitive(System.String,System.Object,JetBrains.Util.ExceptionRenderer.ExData)">
            <summary>
            Special handlings upon rendering primitive values.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.CoerceToString(System.Object)">
            <summary>
            Save to-string conversion using the type/value converters where available.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice">
            <summary>
            Tells how this node should be treated — expanded into children, rendered as a primitive, dropped out, treated as a reference to an exception, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Empty">
            <summary>
            Empty entry, should not be rendered.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Primitive">
            <summary>
            This entry is not expandable and would be rendered as a primitive value.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Expandable">
            <summary>
            This entry should be expanded into child entries.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Exception">
            <summary>
            This entry is a nested exception, so a reference to another exception instance should be rendered instead of going deep into the actual exception.
            </summary>
        </member>
        <member name="T:JetBrains.Util.LoggerException">
            <summary>
            A version of the Internal Error Exception that was created within the logger.
            </summary>
        </member>
        <member name="M:JetBrains.Util.LoggerException.#ctor(System.String,System.Exception,System.Nullable{System.Int32},JetBrains.Util.LoggerException.ToStringBehavior,System.String)">
            <summary>
            Creates a new logger exception.
            </summary>
            <param name="message">Optional. Exception message. If omitted, <paramref name="innerException"/>'s message will be used. If both are omitted, the default message will be used.</param>
            <param name="innerException">Optional. An inner exception. If the explicit <paramref name="message"/> is not defined, the message of this exception will be used.</param>
            <param name="ignoreFrames"><c>Null</c> to use the exception-default stack trace capture behavior (from throw-point to catch-point). A non-negative number to capture the full stack trace at exception consturction point (usually same as throw-point). This is useful for the outermost exception to have the full stack traces from the thread entry point, as opposed to the default .NET behavior, which does not give us the context. A non-zero number skips top stack frames.</param>
            <param name="toStringBehavior">How to render <see cref="M:JetBrains.Util.LoggerException.ToString"/> on this exception instance.</param>
            <param name="sOverrideStackTrace">Allows to set the stack trace string manually, e.g. when “unmarshalling” an exception from a string form.</param>
        </member>
        <member name="M:JetBrains.Util.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.LoggerException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>
            A string representation of the current exception.
            </returns>
            <filterpriority>1</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*"/></PermissionSet>
        </member>
        <member name="F:JetBrains.Util.LoggerException.ToStringBehavior.RenderExceptionFullText">
            <summary>
            Uses <see cref="T:JetBrains.Util.ExceptionRenderer"/> to yield the full formatted text.
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggerException.ToStringBehavior.BaseException">
            <summary>
            Just calls default exception string formatting.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockToHtml.HtmlEncode(System.String)">
            <summary>
            HTML-encodes a string and returns the encoded string.
            </summary>
            <param name="text">The text string to encode. </param>
            <returns>The HTML-encoded text.</returns>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextEx.IsNullOrEmpty(JetBrains.UI.RichText.RichText)">
            <summary>
            Gets whether the rich text object is empty (<c>Null</c> or has no text).
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetSemanticVersion.ToVersion4Lossy">
            <summary>
            Throws out all other information but for the version number.
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetSemanticVersion.ToVersion2Lossy">
            <summary>
            Throws out all other information but for the version number.
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetSemanticVersion.ToVersion4Exact">
            <summary>
            For a semantic version which has only the version number, returns the version number.
            </summary>
        </member>
        <member name="P:JetBrains.Util.JetSemanticVersion.IsVersionNumberOnly">
            <summary>
            Gets whether this semantic version has no info besides the version number.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Sizeof">
            <summary>
            <para>Gets the real runtime size for instances of the specified type, the same size that applies to array elements as they sum up to the array size. Works for intrinsic types, value types, reference types, whatever.</para>
            <para>Uses the <c>sizeof</c> CIL instruction to get the actual size. Note that C#'s <c>sizeof()</c> does not work for all types, and <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)"/> gets the marshalling size, which is a 4x error for a boolean.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Sizeof.Type``1">
            <summary>
            <para>Gets the real runtime size for instances of the specified type, the same size that applies to array elements as they sum up to the array size. Works for intrinsic types, value types, reference types, whatever.</para>
            <para>Uses the <c>sizeof</c> CIL instruction to get the actual size. Note that C#'s <c>sizeof()</c> does not work for all types, and <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)"/> gets the marshalling size, which is a 4x error for a boolean.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.SlowProgressIndicator">
            <summary>
            Usefull to testing indicators progress and cancellation.
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Parse string to enum without any checking
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnum``1(System.String,``0,System.Boolean)">
            <summary>
            Parse string to enum with returning specified default value if parameter is null
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnumSafe``1(System.String,``0,System.Boolean)">
            <summary>
            Parse string to enum with returning specified default value if parameter is null or invalid
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnumNullable``1(System.String)">
            <summary>
            Parse string to nullable enum with returning null if parameter is null
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnumNullableSafe``1(System.String,System.Nullable{``0},System.Boolean)">
            <summary>
            Parse string to nullable enum with returning specified default value if parameter is null or invalid
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.FormatEx(System.String,System.Object[])">
            <summary>
            <para>
            Replaces the format item in a specified <see cref="T:System.String"/> 
            with the text equivalent of the value of a corresponding <see cref="T:System.Object"/> 
            instance in a specified array.
            </para>
            <para>
            This method just call <see cref="M:System.String.Format(System.String,System.Object[])"/> 
            but can be used in more cool way:
            </para>
            <code>
            "Hello, {0}!".FormatEx("World")
            </code>
            </summary>
            <param name="format">A composite format string. </param>
            <param name="args">An <see cref="T:System.Object"/> array containing zero or more objects to format. </param>
            <returns>
            A copy of <paramref name="format"/> in which the format items have been replaced by the <see cref="T:System.String"/> 
            equivalent of the corresponding instances of <see cref="T:System.Object"/> in <paramref name="args"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="format"/> or <paramref name="args"/> is null. 
            </exception>
            <exception cref="T:System.FormatException"> 
            <paramref name="format"/> is invalid.-or- The number indicating an argument to format is less than zero, 
            or greater than or equal to the length of the <paramref name="args"/> array. 
            </exception>
        </member>
        <member name="M:JetBrains.StringEx.FormatNoInline(System.String,System.Object[])">
            <summary>
            The original <c>String::Format</c> method, if inlined, brings allocation of the <c>System.ParamsArray</c> value type on the stack (even if not called), which assumes zeroing its memory and for small and fast functions might make up the longest slice of own cpu time. If this string formatting is on the cold path, use the non-inlineable function.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.SubProgressIndicator">
            <summary>
            <para>Allows for a few tasks to share the full progress range without knowing that they're using it together, each one running the whole length of its subprogress.</para>
            <para>See <see cref="M:JetBrains.Application.Progress.SubProgressIndicator.#ctor(JetBrains.Application.Progress.IProgressIndicator,System.Double)"/> for details.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.SubProgressIndicator.#ctor(JetBrains.Application.Progress.IProgressIndicator,System.Double)">
            <summary>
            <para>A sub-routine runs the whole <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run on the subprogress, with units of its own choice in <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> on the subprogress, which uses up only <paramref name="fUnitsInParentIndicator"/> in the parent <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>.</para>
            <para>This way, a few tasks could share the full progress range without knowing that they're using it together, each one running the whole length of its subprogress.</para>
            </summary>
            <param name="progressParent">The parent progress.</param>
            <param name="fUnitsInParentIndicator">The number of units used up from the <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, when you do <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on this subprogress with any units of your liking.</param>
        </member>
        <member name="T:JetBrains.Util.SystemObjectEqualityComparer`1">
            <summary>
            Uses methods from base <see cref="T:System.Object"/> class for equality comparison: the object equality is checked bitwise on the reference value (or value type body), and the hash code is produced from the sync table entry. The object contents is not inspected (on reference types), and object's methods are not called (in either case).
            Extremely recommended for delegates, because normally they should only match themselves, and comparing or hashing a delegate is an expensive operation in modern NetFX.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Lazy">
            <summary>
            Set of factories for creation <see cref="T:System.Lazy`1"/> instances.
            </summary>
            <remarks>
            *** PLEASE, DO NOT USE LAZY{T} IN INTERRUPTIBLE ACTIVITIES!! ***
            BCL's implementation of Lazy{T} type stores the exception thrown by value factory,
            even the <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> used to stop interruptible activities.
            As a result, you may experience infinite cyclic restarts of activities like R#'s daemon.
            Use the <see cref="T:JetBrains.Util.Concurrency.InterruptibleLazy`1"/> type in such cases.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.TestPresentationMap">
            <summary>
            Must be used with <code>using (new TestPresentationMap()) {...}</code> idiom
            </summary>
        </member>
        <member name="T:JetBrains.Util.CollectionAdapter`1">
            <summary>
            Adapts a generic collection so that it can be handled as a non-generic collection.
            </summary>
            <typeparam name="T">Type of the generic collection.</typeparam>
        </member>
        <member name="M:JetBrains.Util.CollectionAdapter`1.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing. </param>
            <param name="index">The zero-based index in array at which copying begins. </param>
            <exception cref="T:System.ArgumentNullException">array is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
            <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.CollectionAdapter`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.CollectionAdapter`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.CollectionAdapter`1.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            
            <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.CollectionAdapter`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
            
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Util.LocalList`1">
            <summary>
            Represents collection of items that doesn't create heap objects unless items are added
            List is presented as array with capacity increasing as fibonacci numbers. To obtain <c>IList</c> invoke <c>ResultingList()</c>
            </summary>
        </member>
        <member name="M:JetBrains.Util.LocalList`1.Add(`0)">
            <summary>
            Adds an weak reference to item to the <see cref="T:JetBrains.Util.LocalList`1"></see>.
            </summary>
            <param name="item">The object to add to the <see cref="T:JetBrains.Util.LocalList`1"></see>.</param>
        </member>
        <member name="M:JetBrains.Util.LocalList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:JetBrains.Util.LocalList`1"></see>.
            </summary>
            <returns>
            true if item was successfully removed from the <see cref="T:JetBrains.Util.LocalList`1"></see>; otherwise, false.
            This method also returns false if item is not found in the original <see cref="T:JetBrains.Util.LocalList`1"></see>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:JetBrains.Util.LocalList`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:JetBrains.Util.LocalList`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Util.LocalList`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:JetBrains.Util.LocalList`1"></see> contains a specific value.
            </summary>
            <returns>
            true if item is found in the <see cref="T:JetBrains.Util.LocalList`1"></see>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:JetBrains.Util.LocalList`1"></see>.</param>
        </member>
        <member name="P:JetBrains.Util.LocalList`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:JetBrains.Util.LocalList`1"></see>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakToStrongDictionary`2.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakToStrongDictionary`2.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakToStrongDictionary`2.Entry.PrevEntryIndex">
            <summary>
            Index of previous entry in the chain of keys with the same hashcodes (modulo size), -1 means first
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakToWeakDictionary`2.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakToWeakDictionary`2.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakToWeakDictionary`2.Entry.PrevEntryIndex">
            <summary>
            Index of previous entry in the chain of keys with the same hashcodes (modulo size), -1 means first
            </summary>
        </member>
        <member name="F:JetBrains.Application.CompanyInfo.PlatformProductRegistryKeyName">
            <summary>
              <para>In the Registry, name of the key that's shared by all of the Platform-based products (under the company name key).</para>
              <para>Things like InstanceId that are used by usage statistics of all the products are stored there.</para>
            </summary>
            <example><code>HKEY_CURRENT_USER\Software\JetBrains\Platform</code></example>
        </member>
        <member name="F:JetBrains.Application.CompanyInfo.HistoricalDefaultProductName">
            <summary>
            Name of the main historical Visual Studio integrated product of which we keep most of the technical decorations over VS CTO command names prefix, VS command line keys prefix, etc.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.Comparer">
            <summary>
            Factory for anonmymous <see cref="T:System.Collections.Generic.IComparer`1"/> implementations based on delegates provided.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.Comparer.Create``1(System.Comparison{``0})">
            <summary>
            Returns comparer implementation from comparison delegate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.Comparer.Create``2(System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns comparer implementation projecting values to some keys using the delegate rule provided
            and comparing those keys with custom or default relation comparer for key type.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEvent">
            <summary>
            <para>An event that groups multiple incoming signals within a time span and issues only one outgoing signal for them.</para>
            <para>This allows to accomodate for external events firing at a high rate and execute the handler only when their activity suspends.</para>
            <para>The object is thread-safe: the incoming event may fire on any thread, the outgoing activity always happens on the primary thread, identified by <see cref="P:JetBrains.Threading.GroupingEvent.Host"/>-&gt;<see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>-&gt;<see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/>.</para>
            <para>If the owning <see cref="T:JetBrains.Threading.GroupingEventHost"/> has <see cref="!:GroupingEventHost.IsGuarded"/> on, then the outgoing activity is executed under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.</para>
            <para>The maximum grouping interval is limited by <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myDeadline">
            <summary>
            The deadline, in <see cref="T:System.DateTime"/>-UTC format, if waiting for execution. <c>Null</c>, otherwise.
            Interlocked access required.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myFHandler">
            <summary>
            The outgoing event handler, as passed from ctor, if available.
            <c>Null</c> when:
            (1) Not given to ctor (user relies on <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/>).
            (2) After <see cref="!:Dispose"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myIncoming">
            <summary>
            Lazy-created backing for <see cref="P:JetBrains.Threading.GroupingEvent.Incoming"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myIncomingDontProlongate">
            <summary>
            Lazy-created backing for <see cref="P:JetBrains.Threading.GroupingEvent.IncomingDontProlongate"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myIsExecuting">
            <summary>
            True while we're inside the user <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> handler execution, to avoid reentrancy.
            Primary-thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myLazyIsWaiting">
            <summary>
            Lazy-created by <see cref="M:JetBrains.Threading.GroupingEvent.CreateIsWaitingProperty"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myLockOutgoingField">
            <summary>
            Ensures thread safety of <see cref="F:JetBrains.Threading.GroupingEvent.myOutgoing"/>.
            SWL wouldn't create system table entries for the object's monitor handle and allows zero impact for the case we do not use the signals/locks on a shortlived grouping-event.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myOutgoing">
            <summary>
            Lazy-created backing for <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Threading.GroupingEventHost,System.String,System.TimeSpan,System.Action)">
            <summary>
            Creates a new grouping event. Must be executed on the primary thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.MaxInterval">
            <summary>
            Limit for an interval of a <see cref="T:JetBrains.Threading.GroupingEvent"/>.
            To avoid the overhead, events with intervals exceeding this value are not supported.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.CancelIncoming">
            <summary>
            If there were incoming firings for which there was no outgoing firing yet, cancels that outgoing firing.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.CreateIsWaitingProperty">
            <summary><seealso cref="M:JetBrains.Threading.GroupingEvent.IsWaiting"/>
            Creates a property that tells whether the event is currently waiting for grouped execution.
            This method is not thread-safe.
            The property firings are free-threaded.
            </summary>
            <remarks>Lazy-creates the property so that the event resources are not spent if it's not needed.</remarks>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.FireIncoming">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread (if <see cref="!:GroupingEventHost.IsGuarded"/>, then under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>) after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> prolongates the wait by the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.FireIncomingDontProlongate">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread (if <see cref="!:GroupingEventHost.IsGuarded"/>, then under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>) after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> does not change the initial deadline, unlike <see cref="M:JetBrains.Threading.GroupingEvent.FireIncoming"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.IsWaiting">
            <summary><seealso cref="M:JetBrains.Threading.GroupingEvent.CreateIsWaitingProperty"/>
            <para>Checks whether the event has incoming firings for which there were no outgoing firings yet, ie is waiting for the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> to elapse or for the reentrancy guard to allow the execution (if <see cref="!:GroupingEventHost.IsGuarded"/>) after it elapses.</para>
            <para>When the user action starts executing, gets <c>False</c> until there's the next icoming firing.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.Execute">
            <summary>
            Called by the host on the primary thread to fire the action.
            Must be already guarded, if needed by <see cref="!:GroupingEventHost.IsGuarded"/>.
            Must not throw out.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.IsExpired(System.Int64)">
            <summary>
            Gets whether the event has expired waiting for the outgoing firing.
            This means there were no outgoing firings after the incoming firing, and at least an <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> has elapsed since the last incoming firing.
            </summary>
            <param name="datetimeNow">Caches the <see cref="P:System.DateTime.UtcNow"/> value, to avoid re-quering it in the loops. A 64bit integer in the <see cref="T:System.DateTime"/> format. Must be UTC!</param>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Host">
            <summary>
            Gets the owning host for this object.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Incoming">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread under the reentrancy guard after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> prolongates the wait by the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.IncomingDontProlongate">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread under the reentrancy guard after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> does not change the initial deadline, unlike <see cref="M:JetBrains.Threading.GroupingEvent.FireIncoming"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Interval">
            <summary>
            The interval within which the incoming events are grouped before the outgoing event fires and the action is executed.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Name">
            <summary>
            Identifier for this event.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Outgoing">
            <summary>
            The outgoing event. Executed on the primary thread (if <see cref="!:GroupingEventHost.IsGuarded"/>, then under a <see cref="T:JetBrains.Threading.ReentrancyGuard"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEventHost">
            <summary>
            Manages the <see cref="T:JetBrains.Threading.GroupingEvent"/> schedulling.
            Is affined to the thread thru <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/> (even if not <see cref="!:IsGuarded"/>), by making the events fire on that thread only. All of the manipulations over this class (<see cref="M:JetBrains.Threading.GroupingEventHost.CreateEvent(JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)"/>) or the <see cref="T:JetBrains.Threading.GroupingEvent">events</see> are free-threaded.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myClockTimer">
            <summary>
            Clocks the checks for expired events.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myDebugTotalEvents">
            <summary>
            In debug mode, counts the total number of events this instance met.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myDebugTotalThroughput">
            <summary>
            In debug mode, counts the total number of event state changes, like incoming firings, outgoing firings, and cancellings.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myEvents">
            <summary>
            The events handled by this instance, both waiting and not.
            Free-threaded, must be synced with <see cref="F:JetBrains.Threading.GroupingEventHost.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myExecuteExpiredEventsLocalGuard">
            <summary>
            If not <see cref="!:IsGuarded"/> and we're not using <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>, event execution becomes reentrancy prone. Protect the <see cref="M:JetBrains.Threading.GroupingEventHost.ExecuteExpiredEvents"/> func locally in this case.
            Not used when <see cref="!:IsGuarded"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myIsWaitingOnReentrancyGuard">
            <summary>
            When timeout expires on any of the events, we try taking the reentrancy guard to execute it.
            This is <c>True</c> while we're waiting for the async or sync reega call.
            Primary-thread only.
            N/a if not <see cref="!:IsGuarded"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myLock">
            <summary>
            Protects the <see cref="F:JetBrains.Threading.GroupingEventHost.myEvents"/> access.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myWatchdogEvent">
            <summary>
            A dummy event of the maximum inteval.
            The event is incoming-fired whenever any other live event fires, and keeps the clock alive until expires.
            This makes sure the timer is not constantly switched on and off (which means marshalling).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.#ctor(JetBrains.DataFlow.Lifetime,System.Boolean)">
            <summary>
            Creates the new host for the groping events that group multiple incoming signals into one outgoing signal that occurs with a limited frequency.
            </summary>
            <param name="lifetime">Host lifetime.</param>
            <param name="isGuarded">Whether the outgoing action executions should be guarded by the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.</param>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard">
            <summary>
            Identifies the hosts's primary thread.
            If non-<c>Null</c>, guards the execution of all the outgoing actions.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.Dispatcher">
            <summary>
            Identifies the hosts's primary thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.CreateEvent(JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)">
             <summary>
             Creates and registers a new grouping event.
             </summary>
            <param name="lifetime">Lifetime for the event object.</param>
            <param name="name">A name to identify the event.</param>
             <param name="interval">The grouping interval. The incoming events are grouped until there's a pause of the <paramref name="interval"/> length, and after that the outgoing event is fired. The interval must be not above <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</param>
            <param name="FFirstHandler">Optional. The first handler for the <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> signal. Others could be advised on the signal object proper. Using this param avoids creating the signal object, and is preferrable in simple cases.</param>
            <returns>The event on which the incoming events can be fired. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.AddEvent(JetBrains.Threading.GroupingEvent)">
            <summary>
            Registers a new event on the host.
            Free-threaded.
            Must not be called on already-added events.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.OnDeadlineChanged(JetBrains.Threading.GroupingEvent)">
            <summary>
            There was an incoming firing on one of the events, or a waiting event has been cancelled.
            Anyway, its deadline has changed and we must accomodate the schedulle.
            Free-threaded.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.RemoveEvent(JetBrains.Threading.GroupingEvent)">
            <summary>
            Unregisters an event from the host.
            Free-threaded.
            Safe to call more than once (on unregistered events).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.ExecuteExpiredEvents">
            <summary>
            Executes any events that are currently in the expired state.
            Must be run under the <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>, if <see cref="!:IsGuarded"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.OnClockTimerTick">
            <summary>
            The clock signal has fired.
            Check if there's anything to execute.
            Primary thread.
            Safe to throw.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEventHost.ClockTimer">
            <summary>
            The timer that clocks the checks-for-execution.
            Supports free-threaded IsEnabled.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.Interval">
            <summary>
            Default clock period.
            A value less than 50ms approx means we will be called each time the Thread Message Queue gets empty.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myLifetime">
            <summary>
            We use this to track whether we've been disposed of.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myIsEnabledDesiredState">
            <summary>
            What we want to do to the timer. The immediate value set by <see cref="P:JetBrains.Threading.GroupingEventHost.ClockTimer.IsEnabled"/> from any thread.
            After marshalling to the UI thread, applies to the timer.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myIsMarshalling">
            <summary>
            True while there's a pending <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> running. 
            We should avoid posting multiple simultaneous marshalling requests.
            The <see cref="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myIsEnabledDesiredState"/> is not enough an indication, as it might be changed back and forth while a marshalling is in progress.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.ClockTimer.OnTimerTick(System.Object,System.EventArgs)">
            <summary>
            The internal timer has ticked. Tick the clock.
            Primary thread.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEventHost.ClockTimer.IsEnabled">
            <summary>
            Controls the enabled state of the timer.
            Free-threaded.
            Will not pump.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEventHosts">
            <summary>
            Exposes grouping event hosts for various possible guarding modes.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHosts.CreateEvent(JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,JetBrains.Threading.Rgc,System.Action)">
             <summary>
             Creates and registers a new grouping event.
             </summary>
            <param name="lifetime">Lifetime for the event object.</param>
            <param name="name">A name to identify the event.</param>
             <param name="interval">The grouping interval. The incoming events are grouped until there's a pause of the <paramref name="interval"/> length, and after that the outgoing event is fired. The interval must be not above <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</param>
            <param name="guarding">Whether the execution of the event's output signal should be guarded. Currently, only <see cref="F:JetBrains.Threading.Rgc.Guarded"/> and <see cref="F:JetBrains.Threading.Rgc.Invariant"/> options are supported.</param>
            <param name="FFirstHandler">Optional. The first handler for the <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> signal. Others could be advised on the signal object proper. Using this param avoids creating the signal object, and is preferrable in simple cases.</param>
            <returns>The event on which the incoming events can be fired. Must be disposed of.</returns>
        </member>
        <member name="P:JetBrains.Threading.GroupingEventHosts.Item(JetBrains.Threading.Rgc)">
            <summary>
            Retrieves the host for a particular guarding option.
            </summary>
            <param name="guarding">Currently, only <see cref="F:JetBrains.Threading.Rgc.Guarded"/> and <see cref="F:JetBrains.Threading.Rgc.Invariant"/> options are supported.</param>
        </member>
        <member name="T:JetBrains.Threading.RecurrentAlarm">
            <summary>
            Manages the recurrent actions. Wraps execution into the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.
            Makes sure that the action can be cancelled even if it's pending on the <see cref="T:JetBrains.Threading.ReentrancyGuard"/> queue.
            Works on the primary thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.OptionExecutionPrecision">
            <summary>
            Action can be executed as much time before the deadline. 
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.OptionTimerPrecision">
            <summary>
            Timer deadline is set up with this precision.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.IsApplicationActive">
            <summary>
            Gets or sets whether the application that owns the alarm is currently active.
            Recurring actions are executed once at most when the application is inactive.
            This property must be set by the external owner in the UI applications.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.myGeneration">
            <summary>
            A generation is increased each time the application is deactivated. After deactivation, each action can be executed at most once until the app is activated again.
            Whenever an action is executed, its generation is set to the generation of the alarm.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.myIsDeferredSettingTimer">
            <summary>
            <see cref="M:JetBrains.Threading.RecurrentAlarm.UpdateNearestDeadline_SetTimer(System.DateTime)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.myNearestDeadline">
            <summary>
            The nearest deadline for which the timer is set up, or default value if not waiting for any actions.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.myQueue">
            <summary>
            List of all the actions known to the alarm, those waiting for deadline, and waiting on reentrancy guard, and running.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.myReentrancyGuard">
            <summary>
            Identifies the primary thread.
            Guards actions execution.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.myTimer">
            <summary>
            Timer that is set to tick when the <see cref="F:JetBrains.Threading.RecurrentAlarm.myNearestDeadline"/> elapses.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.#ctor">
            <summary>
            Creates the instance.
            Attaches to the primary thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.Create(System.String,System.TimeSpan,System.Action)">
            <summary>
            Schedulles a new timed action that executes the <paramref name="action"/> at recurring <paramref name="interval"/>s.
            The new interval starts when the previous action completes exection, so the total interval depends on the execution time.
            This class can be used on the main thread only.
            </summary>
            <param name="name">Name to identify the action.</param>
            <param name="interval">Interval between the execution (end-to-start). The interval must be positive and not below 50 milliseconds.</param>
            <param name="action">The action to execute.</param>
            <returns>A token that MUST be disposed to stop the recurrence.</returns>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.ExecuteElapsedActions">
            <summary>
            When the deadline comes, executes the actions.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.InternalAddAction(JetBrains.Threading.RecurrentAlarm.RecurrentAction)">
            <summary>
            Queue manipulation. Affects deadline.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.InternalRemoveAction(JetBrains.Threading.RecurrentAlarm.RecurrentAction)">
            <summary>
            Queue manipulation. Affects deadline.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.UpdateNearestDeadline">
            <summary>
            Scans thru the queue.
            Calculates the nearest deadline.
            Sets up the timer to point to that deadline.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.UpdateNearestDeadline_SetTimer(System.DateTime)">
            <summary>
            If <see cref="M:JetBrains.Threading.RecurrentAlarm.UpdateNearestDeadline"/> decided that the deadline should be changed, applies the deadline and adjusts the timer.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Threading.RecurrentAlarm.EligibleTimedActions">
            <summary>
            Skips those actions already in the execution queue and, if the app is inactive, those that have already executed within this inactivity period.
            Returns only those actions that are eligible for execution at some later moment, from the current point of view.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.RecurrentAction.ZeroDeadlineAction">
            <summary>
            Dummy.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.RecurrentAction.myDeadline">
            <summary>
            The deadline date/time, if we're currently waiting for the deadline.
            <c>Null</c>, if we've reached the deadline and are now waiting for execution/executing/etc.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.RecurrentAlarm.RecurrentAction.myLastExecutedGeneration">
            <summary>
            When the action executes, this is set to the current generation of the alarm.
            Allows to track whether the action has executed since the last application deactivation, or not.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.RecurrentAction.BeginExecute(JetBrains.Threading.ReentrancyGuard,System.UInt32,System.Action,System.Func{JetBrains.Threading.RecurrentAlarm.RecurrentAction,System.Boolean})">
            <summary>
            After waiting on the alarm timer queue, starts waiting on the reentrancy guard.
            Called by the alarm queue when the <see cref="P:JetBrains.Threading.RecurrentAlarm.RecurrentAction.Deadline"/> comes.
            Places self on the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>. Must not exec the action on this stack, must <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.
            </summary>
            <param name="reega">Allows to execute reentrant-safe.</param>
            <param name="generation">Generation we should get upon execution.</param>
            <param name="funcDeadlineChanged">Notify parent when we reschedulle.</param>
            <param name="funcAmIAlive">Check if still alive after waiting on reega.</param>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.RecurrentAction.Reschedulle">
            <summary>
            Schedulles the deadline for the action.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.RecurrentAlarm.RecurrentAction.CompareTo(JetBrains.Threading.RecurrentAlarm.RecurrentAction)">
            <summary>
            Compares by the deadline.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.RecurrentAlarm.RecurrentAction.Deadline">
            <summary>
            The deadline date/time, if we're currently waiting for the deadline.
            Default value if we've reached the deadline and are now waiting for execution, or executing.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.RecurrentAlarm.RecurrentAction.LastExecutedGeneration">
            <summary>
            When the action executes, this is set to the current generation of the alarm.
            Allows to track whether the action has executed since the last application deactivation, or not.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.TimedActionsHost">
            <summary>
            Manages the timed deferred actions, optionally protecting their execution with the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.
            Makes sure that the action can be canceled even if it's pending on the <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/> queue.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myGeneration">
            <summary>
            A generation is increased each time the application is deactivated. After deactivation, each action can be executed at most once until the app is activated again.
            Whenever an action is executed, its generation is set to the generation of the alarm.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myReentrancyGuard">
            <summary>
            <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myTimedActions">
            <summary>
            The list of timed actions that are waiting for their deadline to come, and the actions already in the execution queue, whose deadline is <c>Null</c>.
            Main thread access only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myTimer">
            <summary>
            Timer that is set to tick when the <see cref="F:JetBrains.Threading.TimedActionsHost.NearestDeadline"/> elapses.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.NearestDeadline">
            <summary>
            Nearest deadline of all those deadlines of the timed actions in <see cref="F:JetBrains.Threading.TimedActionsHost.myTimedActions"/> that are eligible for execution under the current conditions (application inactivity etc).
            Or <c>0</c>, if there are no eligible timed actions to execute.
            Changes to this property start/stop and edit the <see cref="F:JetBrains.Threading.TimedActionsHost.myTimer"/>.
            UTC!
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.NearestDeadlineGottenDirty">
            <summary>
            Means the <see cref="F:JetBrains.Threading.TimedActionsHost.NearestDeadline"/> has to be recalculated.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.IsApplicationActive">
            <summary>
            Gets or sets whether the application that owns the alarm is currently active.
            Recurring actions are executed once at most when the application is inactive.
            This property must be set by the external owner in the UI applications.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.Queue(JetBrains.DataFlow.Lifetime,System.String,System.Action,System.TimeSpan,JetBrains.Threading.TimedActionsHost.Recurrence,JetBrains.Threading.Rgc)">
            <summary>
            Queues a timed action.
            May be called on any thread.
            </summary>
            <param name="lifetime">Limiting lifetime of the action. After the lifetime terminates, no subsequent execution is performed.</param>
            <param name="name">Name of the action.</param>
            <param name="action">Action executor.</param>
            <param name="interval">Timeout/interval.</param>
            <param name="recurrence">Whether to repeat.</param>
            <param name="guarding">Whether to guard timed actions or not. Currently, only <see cref="F:JetBrains.Threading.Rgc.Guarded"/> and <see cref="F:JetBrains.Threading.Rgc.Invariant"/> options are supported.</param>
            <returns>A token to cancel the activity.</returns>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.OnTimerTick">
            <summary>
            When the timer ticks, the action whose deadline was reached are executed.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard">
            <summary>
            Gets the reentrancy guard for the thread this scheduller is working on.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.Dispatcher">
            <summary>
            Gets the dispatcher for the thread this scheduller is working on.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.EligibleTimedActions">
            <summary>
            Skips those actions already in the execution queue and, if the app is inactive, those that have already executed within this inactivity period.
            Returns only those actions that are eligible for execution at some later moment, from the current point of view.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.TimedActionsHost.Recurrence">
            <summary>
            Tells apart one-time and recurring actions.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.TimedActionsHost.TimedAction">
            <summary>
            <para>The schedulling unit of the alarm.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myDeadline">
            <summary>
            The deadline date/time, if we're currently waiting for the deadline.
            <c>Null</c>, if we've reached the deadline and are now waiting for execution/executing/etc.
            UTC!
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myLastExecutedGeneration">
            <summary>
            When the action executes, this is set to the current generation of the alarm.
            Allows to track whether the action has executed since the last application deactivation, or not.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myLock">
            <summary>
            Protects non-atomic <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.State"/>-related operations, as they might be executed from different threads.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myQueueMembershipToken">
            <summary>
            A token of the membership in the alarm's queue, or a <see cref="F:JetBrains.DataFlow.Disposable.Empty"/> dummy.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.State">
            <summary>
            The current state of the timed action, see <see cref="T:JetBrains.Threading.TimedActionsHost.TimedAction.States"/> for details.
            First states might be set on a foreign thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.GottenDirty">
            <summary>
            Fires when the timed-action state changes and the common deadline timer has to be recalculated.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.BeginExecute(System.UInt32)">
            <summary>
            After waiting on the alarm timer queue in <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/>, starts waiting on the reentrancy guard.
            Called by the alarm queue when the <see cref="P:JetBrains.Threading.TimedActionsHost.TimedAction.Deadline"/> comes.
            Places self on the <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/>. Must not exec the action on this stack, must <see cref="!:ReentrancyGuard.Queue"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.MarshallingComplete(JetBrains.DataFlow.ICollectionEvents{JetBrains.Threading.TimedActionsHost.TimedAction})">
            <summary>
            Called on the guarded thread as soon as possible after creating the action.
            Transitions from <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Marshalling"/> to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/>.
            Adds itself to the alarm queue, if not cancelled yet (atomically).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.Execute">
            <summary>
            After waiting on the reentrancy guard in <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingReentrancy"/>, executes the action actually.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.Reschedulle">
            <summary>
            Schedulles the deadline for the action.
            Free-threaded.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.CompareTo(JetBrains.Threading.TimedActionsHost.TimedAction)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the other parameter.Zero This object is equal to other. Greater than zero This object is greater than other. 
            </returns>
            
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.Terminated">
            <summary>
            Cancels the timed action.
            Might be called on any thread
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.TimedAction.Deadline">
            <summary>
            The deadline date/time, if we're currently waiting for the deadline.
            <c>Null</c>, if we've reached the deadline and are now waiting for execution/executing/etc.
            UTC!
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.TimedAction.LastExecutedGeneration">
            <summary>
            When the action executes, this is set to the current generation of the alarm.
            Allows to track whether the action has executed since the last application deactivation, or not.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.TimedAction.Name">
            <summary>
            The user-supplied action name.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.New">
            <summary>
            The action has just been created. It has not been returned to the user or added to the queue.
            Transites into <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Marshalling"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Marshalling">
            <summary>
            The action has been fully created, but has not been added to the queue.
            If created on the guarded thread, this immediately transitions into <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/> by the <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.MarshallingComplete(JetBrains.DataFlow.ICollectionEvents{JetBrains.Threading.TimedActionsHost.TimedAction})"/> method.
            If created on a foreign thread, the action is returned to the user and can be either cancelled (with <see cref="M:System.IDisposable.Dispose"/>, transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/>) or added to the queue (by <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.MarshallingComplete(JetBrains.DataFlow.ICollectionEvents{JetBrains.Threading.TimedActionsHost.TimedAction})"/>, transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer">
            <summary>
            Waiting for the <see cref="P:JetBrains.Threading.TimedActionsHost.TimedAction.Deadline"/> to come on the alarm queue. Accepts <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.BeginExecute(System.UInt32)"/> (transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingReentrancy"/>) or <see cref="M:System.IDisposable.Dispose"/> (to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingReentrancy">
            <summary>
            Deadline has come. Waiting when the <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/> allows us to run.
            <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.Execute"/> transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Executing"/>.
            <see cref="M:System.IDisposable.Dispose"/> transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Executing">
            <summary>
            The action is running. Too late to cancel.
            When thru, transitions either to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/> (one-time) or <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/> (recurring).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead">
            <summary>
            Either the action has been cancelled, or a one-time action has executed. Terminal state.
            Removes itself from the queue, if any.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard">
            <summary>
            A reentrancy guard that prevents controlled actions from running one on top of another.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myDefaultExternalDriverExecutionLimit">
            <summary>
            The number of actions to be executed in a row in response to the external driver call to <see cref="M:JetBrains.Threading.ReentrancyGuard.PumpQueue(System.Int32)"/>, unless overridden in the function arguments.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.OptionQueueReasonableSizeThresholdMask">
            <summary>
            Report an exception when the queue reaches this limit. Shouldn't be stacking these many actions on the queue.
            This limit is a full-ones mask, and it should not be much above the limit of the dispatcher, <see cref="F:JetBrains.Threading.JetDispatcher.OptionQueueReasonableSizeLimit"/>, because if the guard is oversized, the dispatcher would typically also be overly full, but won't provide details on which actions are stacked in the guard.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myInstance">
            <summary>
            The per-thread guard instance.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myDispatcher">
            <summary>
            A dispatcher that identifies the guarded thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myExecutionStack">
            <summary>
            While executing an action, the reentrancy constraint can be lifted and another action executed.
            The executions and liftings thus form a stack.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myQueueActions">
            <summary>
            Actions that are coming through the <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> method.
            Added from any thread, peeked/removed from the UI thread.
            
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myIsExecutePendingActionsFromIsExecutingFallingSchedulled">
            <summary>
            See <see cref="M:JetBrains.Threading.ReentrancyGuard.BeginInvokeExecutePendingActions(System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myTraces">
            <summary>
            Lazy-created. Main thread modifications only.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.#ctor">
            <summary>
            Constructs an instance for the current thread, on first request to <see cref="P:JetBrains.Threading.ReentrancyGuard.Current"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)">
            <summary>
            When under an <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/> reentrancy guard, temporarily lifts the reentrancy constraints and allows other <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/> to be called, as if there were no executions on the stack.
            This function can be called under execution only.
            </summary>
            <param name="name">A name that identifies this constraint lifting.</param>
            <param name="action">The activity to be executed with the constraint lifted.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AssertGuarded">
            <summary>
            Checks that the activity is executed on the proper thread and is being guarded from reentrancy.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)">
            <summary>
              <para>If called on the guarded thread and <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/>, executes the <paramref name="action"/> immediately and synchronously.</para>
              <para>Otherwise, throws an exception and doesn't execute or queue the action.</para>
              <para>Throws exceptions on fatal errors, traps exceptions from the <paramref name="action"/> proper.</para>
            </summary>
            <param name="name">Identifies the action being executed.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.Execute``2(System.String,``0,System.Func{``0,``1})">
            <summary>
              <para>If called on the guarded thread and <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/>, executes the <paramref name="func"/> immediately and synchronously.</para>
              <para>Otherwise, throws an exception and doesn't execute or queue the action.</para>
              <para>Throws exceptions on fatal errors, traps exceptions from the <paramref name="func"/> proper.</para>
            </summary>
            <param name="name">Identifies the action being executed.</param>
            <param name="func">The function to execute. Exceptions will be trapped.</param>
            <param name="state">Extra state to pass in functon to eliminate closures.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              <para>Executes an action on the guarded thread in a reentrant-safe manner.</para>
              <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
              <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> does.</para>
            </summary>
            <param name="name">Identifies the action in the queue.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="priority"></param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.PumpQueue(System.Int32)">
            <summary>
            Causes the internal guard actions queue to pump, and actions to execute.
            The function must be called under good conditions (<see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/>).
            </summary>
            <param name="limit">The maximum number of actions to execute, or <c>0</c> for the default internal value.</param>
            <returns>The number of actions actually executed.</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              <para>Queues the action to execute asynchronously on the guarded thread, as soon as possible.</para>
              <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="name">Identifies the action in the queue.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="priority"></param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)">
            <summary>
            <para>If called on the guarded thread and <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/>, executes the <paramref name="action"/> immediately and synchronously and returns <c>True</c>.</para>
            <para>Otherwise, immediately returns <c>False</c> and doesn't execute or queue the action.</para>
            </summary>
            <param name="name">Identifies the action being executed.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ReportOversizedQueue">
            <summary>
            Emits diagnostics if there're too many queued items.
            That happens when the size is any multiple of the threshold, defined as <see cref="F:JetBrains.Threading.ReentrancyGuard.OptionQueueReasonableSizeThresholdMask"/><c> + 1</c>.
            Note that this call might happen on any thread, so the size at the moment of the report is not necessarily equal to the threshold.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AddExceptionData(System.Exception)">
            <summary>
            Dumps state for an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AssertCanExecute(System.String)">
            <summary>
            Check that thread-affinity and reentrancy conditions allow us to execute an action right now.
            </summary>
            <param name="name">Action name, for error-reporting.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.BeginInvokeExecutePendingActions(System.Boolean)">
            <summary>
            A method that schedulles execution of the actions queue.
            Called when <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/> comes true or from within <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.
            Can be called on any thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutePendingActions">
            <summary>
            Executes the pending actions on the guarded thread, if possible.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.Current">
            <summary>
            <para>Gets or creates a reentrancy guard for the current thread.</para>
            <para>Take caution if your code might execute on other threads. In these cases you might want to explicitly take the Guard for the desired thread instead of using <see cref="P:JetBrains.Threading.ReentrancyGuard.Current"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow">
            <summary>
            Tells whether the guard can execute actions at this moment, which means there's no action currently executing. Readonly.
            </summary>
            <seealso cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.CurrentActionName">
            <summary>
            <para>Gets a readonly property that tells the name of the current action (an execution or a lifting of the reentrancy constraint, see <see cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/>), or <c>Null</c> if neither is present.</para>
            <para>This is always non-<c>Null</c> when <see cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/>, but could be also non-<c>Null</c> when not <see cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/> (if <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/> was called).</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.Dispatcher">
            <summary>
            Gets the dispatcher for the thread guarded by this instance.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.IsEmpty">
            <summary>
            Gets whether there are no pending actions on the Reentrancy Guard queue.
            All of the deferred actions go through this queue.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.IsExecuting">
            <summary>
            <para>Gets whether a reentrant-safe execution is currently in progress.</para>
            <para>If <c>True</c>, then <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/> is <c>False</c>.</para>
            <para>As the <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/> method that “lifts” the guard, this flag falls and only becomes <c>True</c> when an execution, not lifting, is on top of the executions stack.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.ExecutionStack">
            <summary>
            Encapsulates the stack of executions and reentrancy liftings.
            Supposed number of items: less than 10.
            Main-thread-only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.myCurrentActionName">
            <summary>
            Backend for <see cref="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.CurrentActionName"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.myIsExecuting">
            <summary>
            Backend for <see cref="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.IsExecuting"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.myStack">
            <summary>
            Storage for executions and liftings.
            An execution is added with <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>, and a lifting with <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/>. An execution prevents other executions, and a lifting allows them.
            An execution can only be added into an empty stack or on top of a lifting, and a lifting can only be added on top of an execution.
            Thus, the bottom of the stack and every even-indexed item is an execution, and every odd-indexed item is a lifting.
            Thread safety: changes only on the home thread (remember, this is the execution stack, not the actions queue). Safe to read on the home thread only. Lock-free.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.IsExecutingFalling">
            <summary>
            Event.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.PopExecution(System.String)">
            <summary>
            Removes a recorded execution from the stack.
            Home thread only.
            </summary>
            <param name="name">Item name.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.PushExecution(System.String)">
            <summary>
            Records an execution on the stack.
            Home thread only.
            </summary>
            <param name="name">Item name.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.AddLifting(System.String)">
            <summary>
            Records a reentrancy constraint lifting on the stack, removes upon retval disposal.
            Home thread only.
            </summary>
            <param name="name">Item name.</param>
            <remarks>Note: PushExecution has been broken into Push/Pop to avoid creating the disposable object. A lifting is a much rarer thing, let's keep the safer code here.</remarks>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.RemoveLifting(System.String)">
            <summary>
            Pairing func to <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.AddLifting(System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.CurrentActionName">
            <summary>
            The name of the execution or lifting currently active (on top of the execution stack), or <c>Null</c> if there's none such.
            </summary>
            <remarks>
            This property could be evaluated on demand, but this is not thread-safe, so we make a copy in a thread-safe context (execution stack is only modified on the home thread).
            </remarks>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.IsExecuting">
            <summary>
            Tells whether an execution is currently in progress.
            This means that the stack is not empty (an <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/> is running), and the execution guard has not been lifted with <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/> since the last <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>.
            </summary>
            <remarks>
            Technically, tells whether the number of items in the stack is even.
            This property could be evaluated on demand, but this is not thread-safe, so we make a copy in a thread-safe context (execution stack is only modified on the home thread).
            </remarks>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1">
            <summary>
            A stack data structure with events, lite version (compared to <see cref="T:JetBrains.DataFlow.CollectionEvents`1"/> and others), without interlocking.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.AddRemove">
            <summary>
            Fires when an add/remove operation is performed on the storage.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.Add(`0)">
            <summary>
            Adds an item to the stack. Updates the properties.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.Remove(`0)">
            <summary>
            Removes an item from the stack. Updates the properties.
            </summary>
            <param name="item">Ensures that we removed exactly the same name we added (valid bracket structure).</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.TryGetLast">
            <summary>
            Peeks the item on top of the stack. <c>Null</c> if empty.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.InterlockedQueue">
            <summary>
            Encapsulates the queue in a thread-safe manner.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.myLock">
            <summary>
            Lock for protecting the data structure.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.myStorage">
            <summary>
            The internal storage. Must be protected by <see cref="F:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.myLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.Enqueue(JetBrains.Threading.ReentrancyGuard.QueuedAction)">
            <summary>
            Adds an item to the end of the queue.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.TryDequeue(System.Action{JetBrains.Threading.ReentrancyGuard.QueuedAction})">
            <summary>
            Removes the first item in the queue. Does not throw if the queue is empty.
            Thread-safe.
            <param name="funcVisitor">A handler that will be executed on the removed item, in case there were any items in the queue.</param>
            </summary>
            <returns>Whether the queue was not empty and anything were executed.</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.GetQueuedActionNames">
            <summary>
            Diagnostics. Dumps the RG queue.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.IsEmpty">
            <summary>
            Gets whether the queue currently has no items in it.
            Thread-safe.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext">
            <summary>
            A synchro-context to be set on the thread while executing the no-reentrancy action.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.#ctor">
            <summary>
            Attaches to the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.#ctor(JetBrains.Threading.JetDispatcher)">
            <summary>
            Attaches to some given thread (needed for <see cref="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.CreateCopy"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.Push">
            <summary>
            Pushes/pops the context on the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.CreateCopy">
            <summary>
            Clone.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Use the dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Use the dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.QueuedAction">
            <summary>
            Implements a data item that waits on the queue.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.QueuedAction.Action">
            <summary>
            The method to execute.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.QueuedAction.Name">
            <summary>
            User-assigned name of the action.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.QueuedAction.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> containing a fully qualified type name.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuardTimer">
            <summary>
            A timer that executes its activities under a reentrancy guard and (optionally) suspends the activity when the application is inactive, after executing the action once.
            This class must be disposed of.
            Can be used on the primary thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.InactiveExecutionTime">
            <summary>
            When the <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.Tick"/> event is about to fire, is set to <see cref="P:System.DateTime.Now"/> if the app is inactive, or to a <c>Null</c> value if the app is active.
            Helps with the app-inactivity execution conditions: stop after first time inactive, fire if missed an execution when get active.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsNotWaitingTimer">
            <summary>
            Raised when we're not waiting for the timer event, but sitting on the <see cref="T:JetBrains.Threading.ReentrancyGuard"/> queue or executing.
            In this state, the new timer events are ignored to avoid parallel execution.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsWinFormsTimerEnabled">
            <summary>
            Tells whether the underlying WinForms <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.myTimer"/> should be ON. Applied to the timer offstack to avoid pumping on <see cref="M:System.Windows.Forms.Timer.Stop"/>.
            Is composed from all the states: <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsEnabled"/>, <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsApplicationActive"/>, <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.InactiveExecutionTime"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.myReentrancyGuard">
            <summary>
            Identifies the owning thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.myTimer">
            <summary>
            The timer implementation.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.Interval">
            <summary>
            Gets or sets the timer interval.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsApplicationActive">
            <summary>
            Allows to suspend the timer execution when application gets inactive.
            It's different from <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsEnabled"/> in that after <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsApplicationActive"/> falls, the action executes once more until the timer is suspended. When the application gets back active, if the action execution was missed, it's executed immediately.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsEnabled">
            <summary>
            Gets or sets whether the timer is currently enabled.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.Tick">
            <summary>
            Fires when the timer ticks, under a reentrancy guard.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.OnTimerTick">
            <summary>
            Tick of the underlying winforms timer. Unguarded.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.OnTimerTickReentrantSafe">
            <summary>
            Executes on the timer tick, but under the reentrancy guard.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuardTimer.Name">
            <summary>
            The name of this instance.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.SpinWaitLockRef">
            <summary>
            A reference wrapper for the <see cref="T:JetBrains.Util.Concurrency.SpinWaitLock"/> for those usages that don't mind creating a new object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Enter">
            <summary>
            Locks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Exit">
            <summary>
            Unlocks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Push">
            <summary>
            Pushes an <see cref="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Enter"/>/<see cref="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Exit"/> bracket.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ThreadAccessException">
            <summary>
            Reports a thread access inconsistency.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ThreadAccessException.ThreadDesired">
            <summary>
            Gets the thread the action was expected to execute on. Optional.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ThreadAccessException.ThreadWrong">
            <summary>
            Gets the thread on which the action was prevented from being executed.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.WeakTimer">
            <summary>
            A timer that is not held on a strong reference by the system.
            If there are no more root paths to your class that owns the timer, the ticks stop automatically.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.Interval">
            <summary>
            Gets or sets the timer ticks interval.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.IsEnabled">
            <summary>
            Gets or sets whether the timer is currently running.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.Tick">
            <summary>
            Fires when the timer ticks.
            Sinking this event does not hold you on a permanent GC root.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.myStrongTimer">
            <summary>
            This timer is held on a strong reference, but it does not hold us.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.WeakTimer.#ctor(JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates the timer. If you got the lifetime, pass it in. Otherwise, could be the eternal lifetime, because the timer is held on weak ref and won't be keeping this object alive.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.WeakTimer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.DataStructures.RegistrySettingsTable.Load(System.Action{System.Version})">
            <summary>
            Returns false if the expected key does not exist in the registry
            or exceprion is thrown
            </summary>
        </member>
        <member name="T:JetBrains.Util.EnumEx">
            <summary>
            Extension methods for enums.
            </summary>
        </member>
        <member name="F:JetBrains.Util.EnumEx.myMapEnumValueToName">
            <summary>
            Caches the <see cref="M:JetBrains.Util.EnumEx.GetNamesOfValue(System.Type,System.Object)"/> results, as they use reflection and are thus very slow.
            Copy-on-write, non-locked (the values are expendable and can be regenerated in case of a race).
            </summary>
        </member>
        <member name="M:JetBrains.Util.EnumEx.CoerceEnumValueSlow``1(``0)">
            <summary>
            If the enum value does not fall into the list of valid enum values, coerce it to be the first available enum value.
            This is silent, no exception is thrown.
            Note: this operation is slow, do not use often.
            </summary>
        </member>
        <member name="M:JetBrains.Util.EnumEx.GetNamesOfValue(System.Type,System.Object)">
            <summary>
            Gets all of the alternative names for the value of an enum.
            The value is not required to be coerced to the enum type, it must be of any integral type.
            </summary>
            <param name="type">Enum type.</param>
            <param name="value">Enum value to be named, must be of an integral type.</param>
        </member>
        <member name="M:JetBrains.Util.EnumEx.UnboxQWord(System.Object)">
            <summary>
            Unboxes an object of an integral type (intXXX, bool, byte, char, enum, etc) as a QWORD integer value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.IsPathAbsolute(System.String,System.Boolean)">
            <summary>
            Determines that <paramref name="path"/> is absolute.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.IsPathRelativeToDriveRoot(System.String,System.Boolean)">
            <summary>
            Determines that <paramref name="path"/> is relative to drive root path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.TryConvertToRelativePath(System.String,System.String,System.Boolean,System.Char)">
            <summary>
            Note: valid arguments are relative both or absolute both or unc both. 
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.GetDirectoryNameOfFileAbove(JetBrains.Util.FileSystemPath,System.String)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given file in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="sMarkerFileName">Name of the file to look for.</param>
            <returns>The folder which has the file. Throws an exception if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.TryGetDirectoryNameOfFileAbove(JetBrains.Util.FileSystemPath,System.String)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given file in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="sMarkerFileName">Name of the file to look for.</param>
            <returns>The folder which has the file. <c>Null</c> if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.GetDirectoryNameOfItemAbove(JetBrains.Util.FileSystemPath,JetBrains.Util.RelativePath)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given file in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="markerPath">Name of the item to look for  (may be file or folder).</param>
            <returns>The folder which has the file. Throws an exception if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.TryGetDirectoryNameOfItemAbove(JetBrains.Util.FileSystemPath,JetBrains.Util.RelativePath)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given item in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="markerPath">Name of the item to look for (may be file or folder).</param>
            <returns>The folder which has the item. <c>Null</c> if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.GetPathOnDiskWithCorrectCase(JetBrains.Util.FileSystemPath)">
            <summary>
              Looks for the path on disk regardless of given case, works on all platforms.
              Unc paths are not supported. Throws <see cref="T:System.ArgumentException"/> if several entries
              match given path.
            </summary>
            <param name="path">The path to look for, should be absolute</param>
            <returns>The path on disk if it exists. <c>Null</c> if not found.</returns>[CanBeNull]
        </member>
        <member name="T:JetBrains.Util.DnsAPI.IP6Address">
            <summary>
            Represents an IPv6 IP Address
            </summary>
            <remarks>
            This struct is used by various classes in
            the <see cref="!:Dns.Records"/> namespace to represent
            IPv6 addresses.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag1">
            <summary>
            IP fragment 1
            </summary>
            <remarks>
            IP fragment 1
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag2">
            <summary>
            IP fragment 2
            </summary>
            <remarks>
            IP fragment 2
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag3">
            <summary>
            IP fragment 3
            </summary>
            <remarks>
            IP fragment 3
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag4">
            <summary>
            IP fragment 4
            </summary>
            <remarks>
            IP fragment 4
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag5">
            <summary>
            IP fragment 5
            </summary>
            <remarks>
            IP fragment 5
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag6">
            <summary>
            IP fragment 6
            </summary>
            <remarks>
            IP fragment 6
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag7">
            <summary>
            IP fragment 7
            </summary>
            <remarks>
            IP fragment 7
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP6Address.IPFrag8">
            <summary>
            IP fragment 8
            </summary>
            <remarks>
            IP fragment 8
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.IP6Address.ToString">
            <summary>
            returns a string representation of the IP address v6
            </summary>
            <returns>a human readable ipv6 address</returns>
            <remarks>
            Used to display a human readable IPv6 address.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.IP4_Array">
            <summary>
            Represents an array of IP addresses
            </summary>
            <remarks>
            This struct is used by the DnsQuery API to hold the selected
            DNS servers to query.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP4_Array.AddrCount">
            <summary>
            Gets or sets the number of element in the 
            <see cref="F:JetBrains.Util.DnsAPI.IP4_Array.AddrArray"/> array.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.IP4_Array.AddrArray">
            <summary>
            Gets or sets the array of IP addresses
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsRecord">
            <summary>
            Represents a complete DNS record (DNS_RECORD)
            </summary>
            <remarks>
            This structure is used to hold a complete DNS record
            as returned from the DnsQuery API.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.Next">
            <summary>
            Gets or sets the next record.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.Name">
            <summary>
            Gets or sets the name of the record.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.RecordType">
            <summary>
            Gets or sets the type.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.DataLength">
            <summary>
            Gets or sets the data length.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.Flags">
            <summary>
            Gets or sets the flags.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.Ttl">
            <summary>
            Gets or sets the TTL count
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.Reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsRecord.DnsRecordFlags">
            <summary>
            Represents the flags of a <see cref="T:JetBrains.Util.DnsAPI.DnsRecord"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.DnsRecordFlags.DW">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecord.DnsRecordFlags.S">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsQueryType">
            <summary>
            DNS query types
            </summary>
            <remarks>
            This enum is used by the DnsQuery API call to describe the
            options to be given to a DNS server along with a query.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.STANDARD">
            <summary>
            Standard
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.ACCEPT_TRUNCATED_RESPONSE">
            <summary>
            Accept truncated response
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.USE_TCP_ONLY">
            <summary>
            Use TCP only
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.NO_RECURSION">
            <summary>
            No recursion
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.BYPASS_CACHE">
            <summary>
            Bypass cache
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.NO_WIRE_QUERY">
            <summary>
            Cache only
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.NO_LOCAL_NAME">
            <summary>
            Directs DNS to ignore the local name.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.NO_HOSTS_FILE">
            <summary>
            Prevents the DNS query from consulting the HOSTS file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.NO_NETBT">
            <summary>
            Prevents the DNS query from using NetBT for resolution.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.WIRE_ONLY">
            <summary>
            Directs DNS to perform a query using the network only, 
            bypassing local information.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.TREAT_AS_FQDN">
            <summary>
            Treat as FQDN
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.ALLOW_EMPTY_AUTH_RESP">
            <summary>
            Allow empty auth response
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.DONT_RESET_TTL_VALUES">
            <summary>
            Don't reset TTL values
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.RESERVED">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.CACHE_ONLY">
            <summary>
            obsolete.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryType.RETURN_MESSAGE">
            <summary>
            Directs DNS to return the entire DNS response message.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode">
            <summary>
            The possible return codes of the DNS API call. This enum can
            be used to decypher the <see cref="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode"/>
            property's return value.
            </summary>
            <remarks>
            This enum is used to describe a failed return code by the
            DnsQuery API used in the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> class.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.SUCCESS">
            <summary>
            Successful query
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.UNSPECIFIED_ERROR">
            <summary>
            Base DNS error code
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.MASK">
            <summary>
            Base DNS error code
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.FORMAT_ERROR">
            <summary>
            DNS server unable to interpret format.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.SERVER_FAILURE">
            <summary>
            DNS server failure.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NAME_ERROR">
            <summary>
            DNS name does not exist.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NOT_IMPLEMENTED">
            <summary>
            DNS request not supported by name server.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.REFUSED">
            <summary>
            DNS operation refused.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.YXDOMAIN">
            <summary>
            DNS name that ought not exist, does exist.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.YXRRSET">
            <summary>
            DNS RR set that ought not exist, does exist.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NXRRSET">
            <summary>
            DNS RR set that ought to exist, does not exist.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NOTAUTH">
            <summary>
            DNS server not authoritative for zone.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NOTZONE">
            <summary>
            DNS name in update or prereq is not in zone.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.BADSIG">
            <summary>
            DNS signature failed to verify.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.BADKEY">
            <summary>
            DNS bad key.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.BADTIME">
            <summary>
            DNS signature validity expired.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.PACKET_FMT_BASE">
            <summary>
            Packet format
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NO_RECORDS">
            <summary>
            No records found for given DNS query.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.BAD_PACKET">
            <summary>
            Bad DNS packet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.NO_PACKET">
            <summary>
            No DNS packet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.RCODE">
            <summary>
            DNS error, check rcode.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsQueryReturnCode.UNSECURE_PACKET">
            <summary>
            Unsecured DNS packet.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsFreeType">
            <summary>
            Possible arguments for the DnsRecordListFree api
            </summary>
            <remarks>
            This enum is used by the DnsRecordListFree API.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsFreeType.FreeFlat">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsFreeType.FreeRecordList">
            <summary>
            Frees the record list returned by the DnsQuery API
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsException">
            <summary>
            Represents the exception that occurs when a <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/>
            fails.
            </summary>
            <remarks>
            <para>
            The exception that occurs when a DNS request fails at any level.
            </para>
            <para>
            This class is used to represent two broad types of exceptions:
            <list type="bullet">
               <item><description>Win32 API Exceptions that occurred when calling the DnsQuery API</description></item>
               <item><description>Exceptions of other types that occurred when working with
               the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
               classes.</description></item>
            </list>
            </para>
            <para>
            Win32 errors that are DNS specific are specified in the
            <see cref="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode"/> enumeration but if the 
            <see cref="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode"/> returned is not defined in that 
            enum then the number returned will be defined in WinError.h.
            </para>
            <para>
            Exceptions of other types are available through the 
            InnerException property.
            </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsException.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsException"/>
            </summary>
            <remarks>
            Used to raise a <see cref="T:JetBrains.Util.DnsAPI.DnsException"/> with all the default
            properties. The message property will return: Unspecified
            DNS exception.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsException.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsException"/>
            </summary>
            <param name="message">the human readable description of the problem</param>
            <remarks>
            Used to raise a <see cref="T:JetBrains.Util.DnsAPI.DnsException"/> where the only important
            information is a description about the error. The <see cref="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode"/>
            property will return 0 or SUCCESS indicating that the DNS API calls
            succeeded, regardless of whether they did or did not.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsException.#ctor(System.String,System.UInt32)">
            <summary>
            Initializes a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsException"/>
            </summary>
            <param name="message">the human readable description of the problem</param>
            <param name="errcode">the error code (<see cref="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode"/>)
            if the DnsQuery api failed</param>
            <remarks>
            Used to raise a <see cref="T:JetBrains.Util.DnsAPI.DnsException"/> where the underlying DNS
            API call fails. In this case, the <see cref="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode"/> property
            is the most important information about the exception. In most cases,
            the number returned is a value in the <see cref="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode"/>
            enum however, if it is not, the error is defined in WinError.h.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsException"/>
            </summary>
            <param name="message">the human readable description of the 
            problem</param>
            <param name="innerException">the exception that caused the 
            underlying error</param>
            <remarks>
            Used to raise a <see cref="T:JetBrains.Util.DnsAPI.DnsException"/> where the exception is
            some other type but a typeof(DnsException) is desired to be raised
            instead. In this case, the <see cref="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode"/> property
            always returns 0 or SUCCESS and is a useless property.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsException"/> for <see cref="T:System.Runtime.Serialization.ISerializable"/>
            </summary>
            <param name="info">the serialization information</param>
            <param name="context">the context</param>
            <remarks>
            Used by the <see cref="T:System.Runtime.Serialization.ISerializable"/> interface.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode">
            <summary>
            Gets the error code (<see cref="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode"/>)
            if the DnsQuery api failed. Will be set to success (0) if the API
            didn't fail but another part of the code did.
            </summary>
            <remarks>
            Win32 errors that are DNS specific are specified in the
            <see cref="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode"/> enumeration but if the 
            <see cref="P:JetBrains.Util.DnsAPI.DnsException.ErrorCode"/> returned is not defined in that 
            enum then the number returned will be defined in WinError.h.
            </remarks>
            <value>Value will be defined in WinError.h if not defined in the
            <see cref="T:JetBrains.Util.DnsAPI.DnsQueryReturnCode"/> enum.</value>
            <example>
            This example shows how to decypher the return of the
            ErrorCode property.
            <code>
            try
            {
               ...
            }
            catch(DnsException dnsEx)
            {
               int errcode = dnsEx.ErrorCode;
               if (! Enum.IsDefined(typeof(DnsQueryReturnCode), errcode))
               {
                 //defined in winerror.h
                 Console.WriteLine("WIN32 Error: {0}", errcode);
                 return;
               }
               
               DnsQueryReturnCode errretcode = (DnsQueryReturnCode) errcode;
               if (errretcode == DnsQueryReturnCode.SUCCESS)
               {
                 //inner exception contains the goodies
                 Console.WriteLine(dnsEx.InnerException.ToString());
                 return;
               }
               
               //dns error
               Console.WriteLine("DNS Error: {0}", errretcode.ToString("g"));
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsRecordType">
            <summary>
            DNS record types
            </summary>
            <remarks>
            This enum represents all possible DNS record types that
            could be returned by the DnsQuery API.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.A">
            <summary>
            Address record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.NS">
            <summary>
            Name Server record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MD">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MF">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.CNAME">
            <summary>
            Canonical Name record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.SOA">
            <summary>
            Start Of Authority record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MB">
            <summary>
            Mailbox record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MG">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MR">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.NULL">
            <summary>
            NULL data for a DNS resource record.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.WKS">
            <summary>
            Well-Known Service record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.PTR">
            <summary>
            Pointer record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.HINFO">
            <summary>
            Host Information record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MINFO">
            <summary>
            mail information (MINFO) record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MX">
            <summary>
            Mail Exchange record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.TEXT">
            <summary> 
            Text record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.RP">
            <summary>
            Responsible Person record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.AFSDB">
            <summary>
            AFS Data Base location record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.X25">
            <summary>
            X25
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.ISDN">
            <summary>
            ISDN
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.RT">
            <summary>
            Route Through
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.NSAP">
            <summary>
            Network service access point address record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.NSAPPTR">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.SIG">
            <summary>
            Cryptographic signature record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.KEY">
            <summary>
            Public key record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.PX">
            <summary>
            Pointer to X.400/RFC822 information record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.GPOS">
            <summary>
            Geographical position record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.AAAA">
            <summary>
            IPv6 address record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.LOC">
            <summary>
            Location record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.NXT">
            <summary>
            Next record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.SRV">
            <summary>
            Server record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.ATMA">
            <summary>
            ATM address (ATMA) record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.TKEY">
            <summary>
            TKEY resource record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.TSIG">
            <summary>
            secret key transaction authentication (TSIG) record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.IXFR">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.AXFR">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MAILB">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.MAILA">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.ALL">
            <summary>
            All records
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.ANY">
            <summary>
            Any records
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.WINS">
            <summary>
            WINS record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.WINSR">
            <summary>
            Windows Internet Name Service reverse-lookup record
            </summary>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsRecordType.NBSTAT">
            <summary>
            Windows Internet Name Service reverse-lookup record
            </summary>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsServerCollection">
            <summary>
            Represents a collection of servers by hostname or ip address.
            </summary>
            <remarks>
            Represents a collection of DNS servers that were specified as
            hostnames or ip addresses. Regardless of the way the server
            was entered, it is resolved to an <see cref="T:System.Net.IPAddress"/> object
            internally.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsServerCollection.#ctor">
            <summary>
            Creates a new instance of the collection.
            </summary>
            <remarks>
            This initializer creates an instance of the collection.
            The collection will be empty and contain 0 items.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsServerCollection.Add(System.String)">
            <summary>
            Adds a new hostname or ip address representing a DNS server
            to the collection.
            </summary>
            <param name="host">The ip address or hostname of a DNS server
            to add to the collection</param>
            <remarks>
            Adds a DNS server to the collection. The hostname or ip address
            is first resolved to one or more <see cref="T:System.Net.IPAddress"/> instances
            and then added to the collection. If a given hostname resolves
            to 10 ip addresses, those 10 addresses will be added to the collection.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsServerCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Net.IPAddress"/> instance found at the current
            index of the collection.
            </summary>
            <remarks>
            Gets the <see cref="T:System.Net.IPAddress"/> at the specified index of the
            collection.
            </remarks>
            <param name="idx">The index of the <see cref="T:System.Net.IPAddress"/> to 
            retrieve from the collection.</param>
            <value>The <see cref="T:System.Net.IPAddress"/> at the specified index.</value>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsWrapper">
            <summary>
            Represents a container for a DNS record of any type
            </summary>
            <remarks>
            The <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType"/> property's value
            helps determine what type real type of the 
            <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/> property returns as
            noted in this chart:
            <list type="table">
               <listheader>
                 <term>RecordType</term>
                 <description>RecordData</description>
               </listheader>
               <item>
                 <term>A</term>
                 <description><see cref="!:Dns.Records.ARecord"/></description>
               </item>
               <item>
                 <term>CNAME</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MB</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MD</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MF</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MG</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MR</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>NS</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>PTR</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>HINFO</term>
                 <description><see cref="!:Dns.Records.TXTRecord"/></description>
               </item>
               <item>
                 <term>ISDN</term>
                 <description><see cref="!:Dns.Records.TXTRecord"/></description>
               </item>
               <item>
                 <term>X25</term>
                 <description><see cref="!:Dns.Records.TXTRecord"/></description>
               </item>
               <item>
                 <term>MINFO</term>
                 <description><see cref="!:Dns.Records.MINFORecord"/></description>
               </item>
               <item>
                 <term>RP</term>
                 <description><see cref="!:Dns.Records.MINFORecord"/></description>
               </item>
               <item>
                 <term>MX</term>
                 <description><see cref="!:Dns.Records.MXRecord"/></description>
               </item>
               <item>
                 <term>AFSDB</term>
                 <description><see cref="!:Dns.Records.MXRecord"/></description>
               </item>
               <item>
                 <term>RT</term>
                 <description><see cref="!:Dns.Records.MXRecord"/></description>
               </item>
               <item>
                 <term>NULL</term>
                 <description><see cref="!:Dns.Records.NULLRecord"/></description>
               </item>
               <item>
                 <term>SOA</term>
                 <description><see cref="!:Dns.Records.SOARecord"/></description>
               </item>
               <item>
                 <term>WKS</term>
                 <description><see cref="!:Dns.Records.WKSRecord"/></description>
               </item>
               <item>
                 <term>AAAA</term>
                 <description><see cref="!:Dns.Records.AAAARecord"/></description>
               </item>
               <item>
                 <term>ATMA</term>
                 <description><see cref="!:Dns.Records.ATMARecord"/></description>
               </item>
               <item>
                 <term>NBSTAT</term>
                 <description><see cref="!:Dns.Records.WINSRRecord"/></description>
               </item>
               <item>
                 <term>SRV</term>
                 <description><see cref="!:Dns.Records.SRVRecord"/></description>
               </item>
               <item>
                 <term>TKEY</term>
                 <description><see cref="!:Dns.Records.TKEYRecord"/></description>
               </item>
               <item>
                 <term>TSIG</term>
                 <description><see cref="!:Dns.Records.TSIGRecord"/></description>
               </item>
               <item>
                 <term>WINS</term>
                 <description><see cref="!:Dns.Records.WINSRecord"/></description>
               </item>
               <item>
                 <term>LOC</term>
                 <description><see cref="!:Dns.Records.LOCRecord"/></description>
               </item>
               <item>
                 <term>AXFR</term>
                 <description>null</description>
               </item>
               <item>
                 <term>GPOS</term>
                 <description>null</description>
               </item>
               <item>
                 <term>IXFR</term>
                 <description>null</description>
               </item>
               <item>
                 <term>KEY</term>
                 <description>null</description>
               </item>
               <item>
                 <term>MAILA</term>
                 <description>null</description>
               </item>
               <item>
                 <term>MAILB</term>
                 <description>null</description>
               </item>
               <item>
                 <term>NSAP</term>
                 <description>null</description>
               </item>
               <item>
                 <term>NSAPPTR</term>
                 <description>null</description>
               </item>
               <item>
                 <term>NXT</term>
                 <description>null</description>
               </item>
               <item>
                 <term>PX</term>
                 <description>null</description>
               </item>
               <item>
                 <term>SIG</term>
                 <description>null</description>
               </item>
               <item>
                 <term>TEXT</term>
                 <description>null</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType">
            <summary>
            Gets or sets the type of DNS record contained in the 
            <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/> property.
            </summary>
            <remarks>
            This property indicates the type of DNS record
            that the <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/> property is
            holding.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData">
            <summary>
            Gets or sets the DNS record object as denoted in the 
            <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType"/> field.
            </summary>
            <remarks>
            This property holds the actual DNS record.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsWrapper.Equals(JetBrains.Util.DnsAPI.DnsRecordType)">
            <summary>
            Determines whether or not this <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/>
            instance is equal to a specific <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/>
            by comparing the <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType"/> property of the
            current <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> against the 
            <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/> argument.
            </summary>
            <param name="type">The <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/> to compare to.</param>
            <returns>A boolean indicating whether or not this <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/>
            object contains a DNS record matching the entered type.</returns>
            <remarks>
            Determines if this <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> is of a specific
            <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/>. The comparison does not test the
            <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/> field.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsWrapper.Equals(System.Object)">
            <summary>
            Determines whether or not this <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> instance
            is equal to another <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> or to a 
            <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/> instance.
            </summary>
            <param name="obj">The object to compare to this instance.</param>
            <returns>A boolean indicating whether or not this <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/>
            object equals the entered object.</returns>
            <remarks>
            Determines if this <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> instance is equal to
            an object. If the object is a <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/>, the
            <see cref="M:JetBrains.Util.DnsAPI.DnsWrapper.Equals(JetBrains.Util.DnsAPI.DnsRecordType)"/> method is used to determine
            equality based on the record type. If the object is a <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/>
            object, the <see cref="M:JetBrains.Util.DnsAPI.DnsWrapper.CompareTo(System.Object)"/> method is used to determine
            equality. If the object is any other type, the <see cref="T:System.Object"/>
            class's Equal method is used for comparison.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsWrapper.GetHashCode">
            <summary>
            Serves as a hash function for a particular type, suitable 
            for use in hashing algorithms and data structures like a 
            hash table.
            </summary>
            <returns>Integer value representing the hashcode of this 
            instance of <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/>.</returns>
            <remarks>
            The GetHashCode method uses the hash codes of the <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/>
            and <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType"/> properties to generate a unique code
            for this particular record type/data combination.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsWrapper.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the 
            comparands. The return value has these meanings:
            <list type="table">
               <listheader>
                 <term>Value</term>
                 <description>Meaning</description>
               </listheader>
               <item>
                 <term>Less than zero</term>
                 <description>This instance is less than obj. The <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/>
                 types do not match.</description>
               </item>
               <item>
                 <term>Zero</term>
                 <description>This instance is equal to obj. </description>
               </item>
               <item>
                 <term>Greater than zero</term>
                 <description>This instance is greater than obj. The <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType"/>
                 do not match.</description>
               </item>
            </list>
            </returns>
            <remarks>
            Compares a <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> to this instance by its
            <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordType"/> and <see cref="F:JetBrains.Util.DnsAPI.DnsWrapper.RecordData"/> properties.
            </remarks>
            <exception cref="T:System.ArgumentException">
            obj is not the same type as this instance.
            </exception>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsWrapperCollection">
            <summary>
            Represents a collection of <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> objects.
            </summary>
            <remarks>
            The DnsWrapperCollection is a collection of <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/>
            objects. The resultant collection represents all of the DNS records
            for the given domain that was looked up. This class cannot be directly
            created - it is created by the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and
            <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> classes to hold the returned DNS
            records for the given domain.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsWrapperCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> at the specified
            ordinal in the collection
            </summary>
            <remarks>
            Gets the <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> at the specified
            index of the collection.
            </remarks>
            <param name="i">The index to retrieve from the collection.</param>
            <value>The <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> at the specified index of
            the collection.</value>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsRequest">
            <summary>
            Represents one DNS request. Allows for a complete DNS record lookup 
            on a given domain using the Windows API.
            </summary>
            <remarks>
            <para>
            The DnsRequest class represents a complete DNS request for a given
            domain on a specified DNS server, including all options. The
            DnsRequest class uses the Windows API to do the query and the dlls
            used are only found on Windows 2000 or higher machines. The class
            will throw a <see cref="T:System.NotSupportedException"/> exception if run
            on an machine not capable of using the APIs that are required.
            </para>
            <para>
            Version Information
            </para>
            <para>
                 3/8/2003 v1.1 (C#) - Released on 5/31/2003
             </para>
             <para>
            Created by: Bill Gearhart. Based on code by Patrik Lundin. 
            See version 1.0 remarks below. Specific attention was given
            to the exposed interface which got a 110% overhaul.
            </para>
            <para>
            Notable changes from the previous version:
            <list type="bullet">
              <item>
                <description>
                  structs filled with constants were changed to enums
                </description>
              </item>
              <item>
                <description>
                  .net datatypes were changed to c# datatypes
                </description>
              </item>
              <item>
                <description>
                  every object is now in it's own *.cs file 
                </description>
              </item>
              <item>
                <description>
                  custom collections and exceptions added 
                </description>
              </item>
              <item>
                <description>
                  better object orientation - request and response classes 
                  created for the dns query request/response session so that 
                  it follows the .NET model
                </description>
              </item>
              <item>
                <description>
                  eliminated duplicate recs returned by an ALL query
                </description>
              </item>
              <item>
                <description>
                  bad api return code enumeration added
                </description>
              </item>
              <item>
                <description>
                  ToString() overridden to provide meaningful info for many 
                  of the dns data structs
                </description>
              </item>
              <item>
                <description>
                  documentation and notes were created for all classes
                </description>
              </item>
              <item>
                <description>
                  added check to ensure code only runs on w2k or better
                </description>
              </item>
              <item>
                <description>
                  obsolete DNS record types are now marked as such
                </description>
              </item>
              <item>
                <description>
                  newer enum values added to DnsQueryType enum
                </description>
              </item>
              <item>
                <description>
                  compiled html documentation was written which always takes
                  20 times longer than writing the code does.
                </description>
              </item>
              <item>
                <description>
                  this list of changes was compiled by your's truly...
                </description>
              </item>
              <item>
                <description>
                  smoothed out object and member names so they were more 
                  intuitive - for instance: DNS_MX_DATA became MXRecord
                </description>
              </item>
              <item>
                <description>
                  added call to DnsRecordListFree API to free resources after 
                  DnsQuery call
                </description>
              </item>
              <item>
                <description>
                  altered DnsQuery API call to allow for servers other than the 
                  local DNS server from being queried
                </description>
              </item>
            </list>
            </para>
            <para>
              4/15/2002 v1.0 (C#)
            </para>
            <para>
            Created by: Patrik Lundin
            </para>
            <para>
            Based on code found at: 
            <a href="http://www.c-sharpcorner.com/Code/2002/April/DnsResolver.asp">http://www.c-sharpcorner.com/Code/2002/April/DnsResolver.asp</a>
                
            <list type="bullet">
              <item>
                <description>
                  Initial implementation.
                </description>
              </item>
            </list>
            </para>
            </remarks>
            <example>
            Use the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> objects
            together to get DNS information for aspemporium.com from the nameserver
            where the site is hosted.
            <code>
            using System;
            using netlib.Dns;
            using netlib.Dns.Records;
            
            namespace ClassLibrary1
            {
              class __loader
              {
                static void Main()
                {
                  try
                  {
                    DnsRequest request = new DnsRequest();
                    request.TreatAsFQDN=true;
                    request.BypassCache=true;
                    request.Servers.Add("dns.compresolve.com");
                    request.Domain = "aspemporium.com";
                    DnsResponse response = request.GetResponse();
            
                    Console.WriteLine("Addresses");
                    Console.WriteLine("--------------------------");
                    foreach(ARecord addr in response.ARecords)
                      Console.WriteLine("\t{0}", addr.ToString());
                    Console.WriteLine();
            
                    Console.WriteLine("Name Servers");
                    Console.WriteLine("--------------------------");
                    foreach(PTRRecord ns in response.NSRecords)
                      Console.WriteLine("\t{0}", ns.ToString());
                    Console.WriteLine();
            
                    Console.WriteLine("Mail Exchanges");
                    Console.WriteLine("--------------------------");
                    foreach(MXRecord exchange in response.MXRecords)
                      Console.WriteLine("\t{0}", exchange.ToString());
                    Console.WriteLine();
            
                    Console.WriteLine("Canonical Names");
                    Console.WriteLine("--------------------------");
                    foreach(PTRRecord cname in response.GetRecords(DnsRecordType.CNAME))
                      Console.WriteLine("\t{0}", cname.ToString());
                    Console.WriteLine();
            
                    Console.WriteLine("Start of Authority Records");
                    Console.WriteLine("--------------------------");
                    foreach(SOARecord soa in response.GetRecords(DnsRecordType.SOA))
                      Console.WriteLine("\t{0}", soa.ToString());
                    Console.WriteLine();
            
                    //foreach(DnsWrapper wrap in response.RawRecords)
                    //{
                    //  Console.WriteLine(wrap.RecordType);
                    //}
            
                    response = null;
                    request = null;
                  }
                  catch(DnsException ex)
                  {
                    Console.WriteLine("EXCEPTION DOING DNS QUERY:");
                    Console.WriteLine("\t{0}", ((DnsQueryReturnCode) ex.ErrorCode).ToString("g"));
            
                    if (ex.InnerException != null)
                      Console.WriteLine(ex.InnerException.ToString());
                  }
                }
              }
            }
            
            </code>
            </example>
            
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsRequest.DnsQuery(System.String,JetBrains.Util.DnsAPI.DnsRecordType,JetBrains.Util.DnsAPI.DnsQueryType,System.IntPtr,System.IntPtr@,System.IntPtr)">
            <summary>
            http://msdn.microsoft.com/library/en-us/dns/dns/dnsquery.asp
            </summary>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsRequest.DnsRecordListFree(System.IntPtr,JetBrains.Util.DnsAPI.DnsFreeType)">
            <summary>
            http://msdn.microsoft.com/library/en-us/dns/dns/dnsrecordlistfree.asp
            </summary>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsRequest.#ctor">
            <summary>
            Creates a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/>
            </summary>
            <remarks>
            The <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.Domain"/> property is set to null
            and all other properties have their default value
            of false, except for <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.TreatAsFQDN"/> which has a value
            of true. The system is set to use the local DNS
            server for all queries.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsRequest.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/>
            </summary>
            <remarks>
            The <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.Domain"/> property is set to the domain
            argument and all other properties have their default value
            of false, except for <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.TreatAsFQDN"/> which has a value
            of true. The system is set to use the local DNS
            server for all queries.
            </remarks>
            <param name="domain">The hostname that DNS information is desired for.
            This should not be an ip address. For example: yahoo.com</param>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsRequest.GetResponse">
            <summary>
            Queries the local DNS server for information about 
            this instance of <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and returns
            the response as a <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/>
            </summary>
            <returns>A <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> object containing the response 
            from the DNS server.</returns>
            <exception cref="T:System.NotSupportedException">
            The code is running on a machine lesser than Windows 2000
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.Domain"/> property is null
            </exception>
            <exception cref="T:JetBrains.Util.DnsAPI.DnsException">
            The DNS query itself failed or parsing of the returned 
            response failed
            </exception>
            <remarks>
            Returns a <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> representing the response
            from the DNS server or one of the exceptions noted in the
            exceptions area, the most common of which is the
            <see cref="T:JetBrains.Util.DnsAPI.DnsException"/>.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.Servers">
            <summary>
            Gets a collection of DNS servers to use for the current request.
            If the collection contains no items, the local DNS servers are used.
            </summary>
            <remarks>
            If the collection contains 0 <see cref="T:System.Net.IPAddress"/> references,
            the default DNS servers are used. Otherwise, servers are used in a 
            decending order from their ordinal position in the collection.
            You can add as many DNS Servers as you need to the collection by
            host name or IP address.
            </remarks>
            <value>A <see cref="T:JetBrains.Util.DnsAPI.DnsServerCollection"/> that can be used to 
            manage the DNS servers that will be used for the query.</value>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.UseTCPOnly">
            <summary>
            Gets or sets whether or not to use TCP only for the query.
            </summary>
            <value>Boolean indicating whether or not to use TCP instead of UDP for the query</value>
            <remarks>
            If set to true, the DNS query will be done via TCP rather than UDP. This
            is useful if the DNS service you are trying to reach is running on
            TCP but not on UDP.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.AcceptTruncatedResponse">
            <summary>
            Gets or sets whether or not to accept truncated results — 
            does not retry under TCP.
            </summary>
            <value>Boolean indicating whether or not to accept truncated results.</value>
            <remarks>
            Determines wherher or not the server will be re-queried in the event
            that a response was truncated.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.NoRecursion">
            <summary>
            Gets or sets whether or not to perform an iterative query
            </summary>
            <value>Boolean indicating whether or not to use recursion
            to resolve the query.</value>
            <remarks>
            Specifically directs the DNS server not to perform 
            recursive resolution to resolve the query.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.BypassCache">
            <summary>
            Gets or sets whether or not to bypass the resolver cache 
            on the lookup. This must be set to true if you specified
            a server in the <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.Servers"/> collection.
            </summary>
            <value>Boolean indicating whether or not to bypass the cache
            and use the list of servers in the <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.Servers"/>
            collection.
            </value>
            <remarks>
            Setting this to true allows you to specify one or more DNS servers
            to query instead of querying the local DNS cache and server.
            If false is set, the list of servers is ignored and the local DNS
            cache and server is used to resolve the query.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.QueryCacheOnly">
            <summary>
            Gets or sets whether or not to direct DNS to perform a 
            query on the local cache only
            </summary>
            <value>Boolean indicating whether or not to only use the
            DNS cache to resolve a query.</value>
            <remarks>
            This option allows you to query the local DNS cache only instead
            of making a DNS request over either UDP or TCP.
            This property represents the logical opposite of the
            <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.WireOnly"/> property.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.WireOnly">
            <summary>
            Gets or sets whether or not to direct DNS to perform a 
            query using the network only, bypassing local information.
            </summary>
            <value>Boolean indicating whether or not to use the
            network only instead of local information.</value>
            <remarks>
            This property represents the logical opposite of the
            <see cref="P:JetBrains.Util.DnsAPI.DnsRequest.QueryCacheOnly"/> property.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.NoLocalName">
            <summary>
            Gets or sets whether or not to direct DNS to ignore the 
            local name.
            </summary>
            <value>Boolean indicating whether or not to ignore the local name.</value>
            <remarks>
            Determines how the DNS query handles local names.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.NoHostsFile">
            <summary>
            Gets or sets whether or not to prevent the DNS query from 
            consulting the HOSTS file.
            </summary>
            <value>Boolean indicating whether or not to deny access to
            the HOSTS file when querying.</value>
            <remarks>
            Determines how the DNS query handles accessing the HOSTS file when
            querying for DNS information.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.NoNetbt">
            <summary>
            Gets or sets whether or not to prevent the DNS query from 
            using NetBT for resolution.
            </summary>
            <value>Boolean indicating whether or not to deny access to
            NetBT during the query.</value>
            <remarks>
            Determines how the DNS query handles accessing NetBT when
            querying for DNS information.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.QueryReturnMessage">
            <summary>
            Gets or sets whether or not to direct DNS to return 
            the entire DNS response message.
            </summary>
            <value>Boolean indicating whether or not to return the entire
            response.</value>
            <remarks>
            Determines how the DNS query expects the response to be
            received from the server.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.TreatAsFQDN">
            <summary>
            Gets or sets whether or not to prevent the DNS 
            response from attaching suffixes to the submitted 
            name in a name resolution process.
            </summary>
            <value>Boolean indicating whether or not to allow
            suffix attachment during resolution.</value>
            <remarks>
            Determines how the DNS server handles suffix appending
            to the submitted name during name resolution.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.DontResetTTLValues">
            <summary>
            Gets or sets whether or not to store records 
            with the TTL corresponding to the minimum value 
            TTL from among all records
            </summary>
            <value>Boolean indicating whether or not to
            use TTL values from all records.</value>
            <remarks>
            Determines how the DNS query handles TTL values.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsRequest.Domain">
            <summary>
            Gets or sets the domain to query. The domain must be a hostname,
            not an IP address.
            </summary>
            <remarks>
            This method is expecting a hostname, not an IP address. The
            system will fail with a <see cref="T:JetBrains.Util.DnsAPI.DnsException"/> when
            <see cref="M:JetBrains.Util.DnsAPI.DnsRequest.GetResponse"/> is called if Domain is an IP address.
            </remarks>
            <value>String representing the domain that DNS information
            is desired for. This should be set to a hostname and not an
            IP Address.</value>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.DnsResponse">
            <summary>
            Represents one DNS response. This class cannot be directly created - 
            it is returned by the <see cref="M:JetBrains.Util.DnsAPI.DnsRequest.GetResponse"/> method.
            </summary>
            <remarks>
            The DnsResponse class represents the information returned by a DNS 
            server in response to a <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/>. The DnsResponse
            class offers easy access to all of the returned DNS records for a given
            domain.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.DnsResponse.GetRecords(JetBrains.Util.DnsAPI.DnsRecordType)">
            <summary>
            Returns a collection of DNS records of a specified
            <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/>. The collection's data type
            is determined by the type of record being sought in the
            type argument.
            </summary>
            <param name="type">A <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/> enumeration
            value indicating the type of DNS record to get from the list of
            all DNS records (available in the <see cref="P:JetBrains.Util.DnsAPI.DnsResponse.RawRecords"/>
            property.</param>
            <returns>an <see cref="T:System.Collections.ArrayList"/> of one of the types
            specified in the <see cref="!:Dns.Records"/> namespace based
            on the <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/> argument representing the
            type of DNS record desired.
            </returns>
            <remarks>
            It is recommended that you loop through the results of this
            method as follows for maximum convenience:
            <code>
            foreach (<see cref="!:Dns.Records"/> record in obj.GetRecords(<see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/>))
            {
               string s = record.ToString();
            }
            </code>
            The following table indicates the DNS record type you can expect to get
            back based on the <see cref="T:JetBrains.Util.DnsAPI.DnsRecordType"/> requested. Any items returning
            null are not currently supported.
            <list type="table">
               <listheader>
                 <term>DnsRecordType enumeration value</term>
                 <description>GetRecords() returns</description>
               </listheader>
               <item>
                 <term>A</term>
                 <description><see cref="!:Dns.Records.ARecord"/></description>
               </item>
               <item>
                 <term>CNAME</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MB</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MD</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MF</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MG</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>MR</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>NS</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>PTR</term>
                 <description><see cref="!:Dns.Records.PTRRecord"/></description>
               </item>
               <item>
                 <term>HINFO</term>
                 <description><see cref="!:Dns.Records.TXTRecord"/></description>
               </item>
               <item>
                 <term>ISDN</term>
                 <description><see cref="!:Dns.Records.TXTRecord"/></description>
               </item>
               <item>
                 <term>X25</term>
                 <description><see cref="!:Dns.Records.TXTRecord"/></description>
               </item>
               <item>
                 <term>MINFO</term>
                 <description><see cref="!:Dns.Records.MINFORecord"/></description>
               </item>
               <item>
                 <term>RP</term>
                 <description><see cref="!:Dns.Records.MINFORecord"/></description>
               </item>
               <item>
                 <term>MX</term>
                 <description><see cref="!:Dns.Records.MXRecord"/></description>
               </item>
               <item>
                 <term>AFSDB</term>
                 <description><see cref="!:Dns.Records.MXRecord"/></description>
               </item>
               <item>
                 <term>RT</term>
                 <description><see cref="!:Dns.Records.MXRecord"/></description>
               </item>
               <item>
                 <term>NULL</term>
                 <description><see cref="!:Dns.Records.NULLRecord"/></description>
               </item>
               <item>
                 <term>SOA</term>
                 <description><see cref="!:Dns.Records.SOARecord"/></description>
               </item>
               <item>
                 <term>WKS</term>
                 <description><see cref="!:Dns.Records.WKSRecord"/></description>
               </item>
               <item>
                 <term>AAAA</term>
                 <description><see cref="!:Dns.Records.AAAARecord"/></description>
               </item>
               <item>
                 <term>ATMA</term>
                 <description><see cref="!:Dns.Records.ATMARecord"/></description>
               </item>
               <item>
                 <term>NBSTAT</term>
                 <description><see cref="!:Dns.Records.WINSRRecord"/></description>
               </item>
               <item>
                 <term>SRV</term>
                 <description><see cref="!:Dns.Records.SRVRecord"/></description>
               </item>
               <item>
                 <term>TKEY</term>
                 <description><see cref="!:Dns.Records.TKEYRecord"/></description>
               </item>
               <item>
                 <term>TSIG</term>
                 <description><see cref="!:Dns.Records.TSIGRecord"/></description>
               </item>
               <item>
                 <term>WINS</term>
                 <description><see cref="!:Dns.Records.WINSRecord"/></description>
               </item>
               <item>
                 <term>LOC</term>
                 <description><see cref="!:Dns.Records.LOCRecord"/></description>
               </item>
               <item>
                 <term>AXFR</term>
                 <description>null</description>
               </item>
               <item>
                 <term>GPOS</term>
                 <description>null</description>
               </item>
               <item>
                 <term>IXFR</term>
                 <description>null</description>
               </item>
               <item>
                 <term>KEY</term>
                 <description>null</description>
               </item>
               <item>
                 <term>MAILA</term>
                 <description>null</description>
               </item>
               <item>
                 <term>MAILB</term>
                 <description>null</description>
               </item>
               <item>
                 <term>NSAP</term>
                 <description>null</description>
               </item>
               <item>
                 <term>NSAPPTR</term>
                 <description>null</description>
               </item>
               <item>
                 <term>NXT</term>
                 <description>null</description>
               </item>
               <item>
                 <term>PX</term>
                 <description>null</description>
               </item>
               <item>
                 <term>SIG</term>
                 <description>null</description>
               </item>
               <item>
                 <term>TEXT</term>
                 <description>null</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsResponse.RawRecords">
            <summary>
            Gets a <see cref="T:JetBrains.Util.DnsAPI.DnsWrapperCollection"/> containing
            all of the DNS information that the server returned about
            the queried domain.
            </summary>
            <remarks>
            Returns all of the DNS records retrieved about the domain
            as a <see cref="T:JetBrains.Util.DnsAPI.DnsWrapperCollection"/>. This property
            is wrapped by the <see cref="M:JetBrains.Util.DnsAPI.DnsResponse.GetRecords(JetBrains.Util.DnsAPI.DnsRecordType)"/> method, the
            <see cref="P:JetBrains.Util.DnsAPI.DnsResponse.ARecords"/>, <see cref="P:JetBrains.Util.DnsAPI.DnsResponse.MXRecords"/>, and
            <see cref="P:JetBrains.Util.DnsAPI.DnsResponse.NSRecords"/> properties.
            </remarks>
            <value>Gets a collection of <see cref="T:JetBrains.Util.DnsAPI.DnsWrapper"/> objects.</value>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsResponse.ARecords">
            <summary>
            Gets all the <see cref="T:JetBrains.Util.DnsAPI.ARecord"/> for the queried domain.
            </summary>
            <remarks>
            Uses the <see cref="M:JetBrains.Util.DnsAPI.DnsResponse.GetRecords(JetBrains.Util.DnsAPI.DnsRecordType)"/> method to retrieve an
            array of <see cref="T:JetBrains.Util.DnsAPI.ARecord"/>s representing all the Address
            records for the domain.
            </remarks>
            <value>An array of <see cref="T:JetBrains.Util.DnsAPI.ARecord"/> objects.</value>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsResponse.MXRecords">
            <summary>
            Gets all the <see cref="T:JetBrains.Util.DnsAPI.MXRecord"/> for the queried domain.
            </summary>
            <remarks>
            Uses the <see cref="M:JetBrains.Util.DnsAPI.DnsResponse.GetRecords(JetBrains.Util.DnsAPI.DnsRecordType)"/> method to retrieve an
            array of <see cref="T:JetBrains.Util.DnsAPI.MXRecord"/>s representing all the Mail Exchanger
            records for the domain.
            </remarks>
            <value>An array of <see cref="T:JetBrains.Util.DnsAPI.MXRecord"/> objects.</value>
        </member>
        <member name="P:JetBrains.Util.DnsAPI.DnsResponse.NSRecords">
            <summary>
            Gets all the DNS name servers for the queried domain as an
            array of <see cref="T:JetBrains.Util.DnsAPI.PTRRecord"/>s.
            </summary>
            <remarks>
            Uses the <see cref="M:JetBrains.Util.DnsAPI.DnsResponse.GetRecords(JetBrains.Util.DnsAPI.DnsRecordType)"/> method to retrieve an
            array of <see cref="T:JetBrains.Util.DnsAPI.PTRRecord"/>s representing all the Name Server
            records for the domain.
            </remarks>
            <value>An array of <see cref="T:JetBrains.Util.DnsAPI.PTRRecord"/> objects.</value>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.WKSRecord">
            <summary>
            Represents a DNS Well Known Service record (DNS_WKS_DATA)
            </summary>
            <remarks>
            The WKSRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WKSRecord.IpAddress">
            <summary>
            Gets or sets the IP address
            </summary>
            <remarks>
            IP address, in the form of an IP4_ADDRESS structure. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WKSRecord.Protocol">
            <summary>
            Gets or sets the protocol
            </summary>
            <remarks>
            IP protocol for this record. Valid values are UDP or TCP. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WKSRecord.BitMask">
            <summary>
            Gets or sets the bitmask
            </summary>
            <remarks>
            Mask representing well known service being represented in the RR. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.WKSRecord.ToString">
            <summary>
            Returns a string representation of the service record
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            IP Address: [IPADDR] Protocol: [PROTO] BitMask: [BITMASK]
            where [IPADDR] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WKSRecord.IpAddress"/> as specified here <see cref="M:System.Net.IPAddress.ToString"/>
            and   [PROTO] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WKSRecord.Protocol"/>
            and   [BITMASK] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.WKSRecord.BitMask"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.WINSRRecord">
            <summary>
            Represents a DNS Windows Internet Name Service reverse-lookup 
            (WINSR) record (DNS_WINSR_DATA)
            </summary>
            <remarks>
            The WINSRRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRRecord.MappingFlag">
            <summary>
            Gets or sets the mapping flag
            </summary>
            <remarks>
            WINS mapping flag that specifies whether the record must be included 
            into the zone replication. It may have only two values: 0x80000000 
            and 0x00010000 corresponding to the replication and no-replication 
            (local record) flags, respectively. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRRecord.LookupTimeout">
            <summary>
            Gets or sets the lookup timeout
            </summary>
            <remarks>
            Time, in seconds, that a DNS Server attempts resolution using WINS 
            lookup. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRRecord.CacheTimeout">
            <summary>
            Gets or sets the cache timeout
            </summary>
            <remarks>
            Time, in seconds, that a DNS Server using WINS lookup may cache the 
            WINS Server's response. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRRecord.ResultDomain">
            <summary>
            Gets or sets the result domain name
            </summary>
            <remarks>
            Pointer to a string representing the domain name to append to the 
            returned NetBIOS name. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.WINSRRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            mapping flag: [FLAG] lookup timeout: [LOOKUP] cache timeout: [CACHE] result domain: [DOMAIN]
            where [FLAG] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRRecord.MappingFlag"/>
            and   [LOOKUP] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRRecord.LookupTimeout"/>
            and   [CACHE] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRRecord.CacheTimeout"/>
            and   [DOMAIN] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRRecord.ResultDomain"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.WINSRecord">
            <summary>
            Represents a DNS Windows Internet Name Service (WINS) record (DNS_WINS_DATA)
            </summary>
            <remarks>
            The WINSRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRecord.MappingFlag">
            <summary>
            Gets or sets the mapping flag
            </summary>
            <remarks>
            WINS mapping flag that specifies whether the record must be 
            included into the zone replication. It may have only two values: 
            0x80000000 and 0x00010000 corresponding to the replication and 
            no-replication (local record) flags, respectively. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRecord.LookupTimeout">
            <summary>
            Gets or sets the lookup timeout
            </summary>
            <remarks>
            Time, in seconds, that a DNS Server attempts resolution using 
            WINS lookup. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRecord.CacheTimeout">
            <summary>
            Gets or sets the cache timeout
            </summary>
            <remarks>
            Time, in seconds, that a DNS Server using WINS lookup may cache 
            the WINS Server's response. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRecord.ServerCount">
            <summary>
            Gets or sets the count of WINS servers
            </summary>
            <remarks>
            Number of WINS Servers listed in the WinsServers member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.WINSRecord.WinsServers">
            <summary>
            Gets or sets the WINS server array pointer
            </summary>
            <remarks>
            Array of WINS Servers, each of type int . 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.WINSRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            mapping flag: [FLAG] lookup timeout: [LOOKUP] cache timeout: [CACHE] server count: [SERVERCT] server ptr: [SERVERS]
            where [FLAG] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRecord.MappingFlag"/>
            and   [LOOKUP] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRecord.LookupTimeout"/>
            and   [CACHE] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRecord.CacheTimeout"/>
            and   [SERVERCT] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRecord.ServerCount"/>
            and   [SERVERS] = string representation of <see cref="F:JetBrains.Util.DnsAPI.WINSRecord.WinsServers"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.TXTRecord">
            <summary>
            Represents a DNS Text record (DNS_TXT_DATA)
            </summary>
            <remarks>
            The TXTRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TXTRecord.StringCount">
            <summary>
            Gets or sets the string count
            </summary>
            <remarks>
            Number of strings represented in pStringArray. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TXTRecord.StringArray">
            <summary>
            Gets or sets the string array
            </summary>
            <remarks>
            Array of strings representing the descriptive text of the 
            TXT resource record. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.TXTRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            string count: [COUNT] string array: [ARR]
            where [COUNT] = string representation of <see cref="F:JetBrains.Util.DnsAPI.TXTRecord.StringCount"/>
            and   [ARR] = string representation of <see cref="F:JetBrains.Util.DnsAPI.TXTRecord.StringArray"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.TSIGRecord">
            <summary>
            represents a secret key transaction authentication (TSIG) record (DNS_TSIG_DATA)
            </summary>
            <remarks>
            The TSIGRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.Algorithm">
            <summary>
            Gets or sets the name algorithm
            </summary>
            <remarks>
            Name of the key used in the domain name syntax. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.AlgorithmPacket">
            <summary>
            Gets or sets the algorithm packet
            </summary>
            <remarks>
            Pointer to the packet containing the algorithm. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.Key">
            <summary>
            Gets or sets the key
            </summary>
            <remarks>
            Pointer to the signature. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.OtherData">
            <summary>
            Gets or sets the other data
            </summary>
            <remarks>
            Pointer to other data. This member is empty unless a BADTIME error is returned.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.CreateTime">
            <summary>
            Gets or sets the create time
            </summary>
            <remarks>
            Time the key transaction authentication was created, expressed in seconds since the beginning of January 1, 1970, Greenwich Mean Time (GMT), excluding leap seconds. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.FudgeTime">
            <summary>
            Gets or sets the fudge time
            </summary>
            <remarks>
            Time, in seconds, from which the i64CreateTime may be in error. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.OriginalXid">
            <summary>
            Gets or sets the original XID
            </summary>
            <remarks>
            Original message identifier. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.Error">
            <summary>
            Gets or sets the error
            </summary>
            <remarks>
            Error, expressed in expanded RCODE that covers TSIG processing. See Remarks for more information about the TSIG resource record. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.KeyLength">
            <summary>
            Gets or sets the key length
            </summary>
            <remarks>
            Length, in bytes, of the pSignature member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.OtherLength">
            <summary>
            Gets or sets the other length
            </summary>
            <remarks>
            Length, in bytes, of the pOtherData member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.AlgNameLength">
            <summary>
            Gets or sets the algorithm length
            </summary>
            <remarks>
            Length, in bytes, of the pNameAlgorithm member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TSIGRecord.PacketPointers">
            <summary>
            Gets or sets whether or not to use packet pointers
            </summary>
            <remarks>
            Reserved for future use. 
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.TKEYRecord">
            <summary>
             Represents a DNS TKEY resource record, used to 
             establish and delete shared-secret keys between 
             a DNS resolver and server. (DNS_TKEY_DATA)
            </summary>
            <remarks>
            The TKEYRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.Algorithm">
            <summary>
            Gets or sets the name algorithm
            </summary>
            <remarks>
            Pointer to a string representing the name of the algorithm 
            used with the key. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.AlgorithmPacket">
            <summary>
            Gets or sets the algorithm packet.
            </summary>
            <remarks>
            Pointer to the packet containing the algorithm. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.Key">
            <summary>
            Gets or sets the key
            </summary>
            <remarks>
            Pointer to the key. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.OtherData">
            <summary>
            Gets or sets the other data
            </summary>
            <remarks>
            Reserved for future use. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.CreateTime">
            <summary>
            Gets or sets the create time
            </summary>
            <remarks>
            Date and time at which the key was created, expressed in seconds 
            since the beginning of January 1, 1970, Greenwich Mean Time (GMT), 
            excluding leap seconds. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.ExpireTime">
            <summary>
            Gets or sets the expire time
            </summary>
            <remarks>
            Expiration date of the key, expressed in seconds since the beginning 
            of January 1, 1970, Greenwich Mean Time (GMT), excluding leap seconds. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.Mode">
            <summary>
            Gets or sets the mode
            </summary>
            <remarks>
            Scheme used for key agreement or the purpose of the TKEY DNS Message. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.Error">
            <summary>
            Gets or sets the error
            </summary>
            <remarks>
            Error, expressed in expanded RCODE that covers TSIG processing and 
            TKEY processing. See Remarks. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.KeyLength">
            <summary>
            Gets or sets the key length
            </summary>
            <remarks>
            Length, in bytes, of the pSignature member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.OtherLength">
            <summary>
            Gets or sets the other length
            </summary>
            <remarks>
            Length, in bytes, of the pOtherData member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.AlgNameLength">
            <summary>
            Gets or sets the name algorithm's length
            </summary>
            <remarks>
            Length, in bytes, of the pNameAlgorithm member. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.TKEYRecord.PacketPointers">
            <summary>
            Gets or sets whether or not to use packet pointers
            </summary>
            <remarks>
            Reserved for future use. 
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.SRVRecord">
            <summary>
            Represents a DNS Server record. (DNS_SRV_DATA)
            </summary>
            <remarks>
            The SRVRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SRVRecord.NameNext">
            <summary>
            Gets or sets the name
            </summary>
            <remarks>
            Pointer to a string representing the target host. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SRVRecord.Priority">
            <summary>
            Gets or sets the priority
            </summary>
            <remarks>
            Priority of the target host specified in the owner name. Lower numbers imply higher priority. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SRVRecord.Weight">
            <summary>
            Gets or sets the weight
            </summary>
            <remarks>
            Weight of the target host. Useful when selecting among hosts with the same priority. The chances of using this host should be proportional to its weight. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SRVRecord.Port">
            <summary>
            Gets or sets the port
            </summary>
            <remarks>
            Port used on the target host for the service. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SRVRecord.Pad">
            <summary>
            Reserved.
            </summary>
            <remarks>
            Reserved. Used to keep pointers DWORD aligned. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.SRVRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            name next: [SERVER] priority: [PRIOR] weight: [WEIGHT] port: [PORT]
            where [SERVER] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SRVRecord.NameNext"/>
            and   [PRIOR] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SRVRecord.Priority"/>
            and   [WEIGHT] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SRVRecord.Weight"/>
            and   [PORT] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SRVRecord.Port"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.SOARecord">
            <summary>
            Represents a DNS Start Of Authority record (DNS_SOA_DATA)
            </summary>
            <remarks>
            The SOARecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.PrimaryServer">
            <summary>
            Gets or sets the primary server
            </summary>
            <remarks>
            Pointer to a string representing the name of the authoritative 
            DNS server for the zone to which the record belongs. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.Administrator">
            <summary>
            Gets or sets the name of the administrator
            </summary>
            <remarks>
            Pointer to a string representing the name of the responsible party 
            for the zone to which the record belongs. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.SerialNo">
            <summary>
            Gets or sets the serial number
            </summary>
            <remarks>
            Serial number of the SOA record. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.Refresh">
            <summary>
            Gets or sets the refresh
            </summary>
            <remarks>
            Time, in seconds, before the zone containing this record should be 
            refreshed. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.Retry">
            <summary>
            Gets or sets the retry count
            </summary>
            <remarks>
            Time, in seconds, before retrying a failed refresh of the zone to 
            which this record belongs 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.Expire">
            <summary>
            Gets or sets the expiration
            </summary>
            <remarks>
            Time, in seconds, before an unresponsive zone is no longer authoritative. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SOARecord.DefaultTtl">
            <summary>
            Gets or sets the default ttl
            </summary>
            <remarks>
            Lower limit on the time, in seconds, that a DNS server or caching 
            resolver are allowed to cache any RRs from the zone to which this 
            record belongs. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.SOARecord.ToString">
            <summary>
            Returns a string representation of the Start Of Authority record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            administrator: [ADMIN] TTL: [TTL] primary server: [SERVER] refresh: [REFRESH] retry: [RETRY] serial number: [SERIAL]
            where [ADMIN] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SOARecord.Administrator"/>
            and   [TTL] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SOARecord.DefaultTtl"/>
            and   [SERVER] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SOARecord.PrimaryServer"/>
            and   [REFRESH] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SOARecord.Refresh"/>
            and   [RETRY] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SOARecord.Retry"/>
            and   [SERIAL] = string representation of <see cref="F:JetBrains.Util.DnsAPI.SOARecord.SerialNo"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.SIGRecord">
            <summary>
            Represents a DNS Cryptographic signature record. (DNS_SIG_DATA)
            </summary>
            <remarks>
            The SIGRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.Signer">
            <summary>
            Gets or sets the signer.
            </summary>
            <remarks>
            Pointer to a string representing the name of the signer that 
            generated the record 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.TypeCovered">
            <summary>
            Gets or sets the type covered
            </summary>
            <remarks>
            Type of RR covered by the signature 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.Algorithm">
            <summary>
            Gets or sets the algorithm
            </summary>
            <remarks>
            Algorithm used with the key specified in the RR. The assigned values are shown in the following table. 
            
            <list type="table">
               <listheader>
                 <term>Value</term>
                 <description>Meaning</description>
               </listheader>
               <item>
                 <term>1</term>
                 <description>RSA/MD5 (RFC 2537)</description>
               </item>
               <item>
                 <term>2</term>
                 <description>Diffie-Hellman (RFC 2539)</description>
               </item>
               <item>
                 <term>3</term>
                 <description>DSA (RFC 2536)</description>
               </item>
               <item>
                 <term>4</term>
                 <description>Elliptic curve cryptography</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.LabelCount">
            <summary>
            Gets or sets the label count
            </summary>
            <remarks>
            Number of labels in the original signature RR owner name. The count does not include the NULL label for the root, nor any initial wildcards. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.OriginalTtl">
            <summary>
            Gets or sets the original ttl
            </summary>
            <remarks>
            TTL value of the RR set signed by the signature RR. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.Expiration">
            <summary>
            Gets or sets the expiration
            </summary>
            <remarks>
            Expiration date, expressed in seconds since the beginning of January 1, 1970, Greenwich Mean Time (GMT), excluding leap seconds. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.TimeSigned">
            <summary>
            Gets or sets the time signed
            </summary>
            <remarks>
            Date and time at which the signature becomes valid, expressed in seconds since the beginning of January 1, 1970, Greenwich Mean Time (GMT), excluding leap seconds. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.KeyTag">
            <summary>
            Gets or sets the key tag
            </summary>
            <remarks>
            Method used to choose a key that verifies a signature. See RFC 2535, Appendix C for the method used to calculate a KeyTag.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.Pad">
            <summary>
            Reserved.
            </summary>
            <remarks>
            Reserved. Used to keep byte field aligned. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.SIGRecord.Signature">
            <summary>
            Gets or sets the signature
            </summary>
            <remarks>
            Signature, represented in base 64, formatted as defined in RFC 2535, Appendix A. 
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.PTRRecord">
            <summary>
            Represents the DNS pointer record (DNS_PTR_DATA)
            </summary>
            <remarks>
            The PTRRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.PTRRecord.HostName">
            <summary>
            Gets or sets the hostname of the record.
            </summary>
            <remarks>
            Pointer to a string representing the pointer (PTR) record data.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.PTRRecord.ToString">
            <summary>
            Returns a string representation of the pointer record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            Hostname: [HOST]
            where [HOST] = string representation of <see cref="F:JetBrains.Util.DnsAPI.PTRRecord.HostName"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.NXTRecord">
            <summary>
            Represents the DNS Next record. (DNS_NXT_DATA)
            </summary>
            <remarks>
            The NXTRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.NXTRecord.NameNext">
            <summary>
            Gets or sets the name.
            </summary>
            <remarks>
            Pointer to a string representing the name of the next domain. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.NXTRecord.TypeBitMap">
            <summary>
            Gets or sets the type bit map
            </summary>
            <remarks>
            Number of elements in the wTypes array. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.NXTRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            next: [NAME] type bitmap: [BITMAP]
            where [NAME] = string representation of <see cref="F:JetBrains.Util.DnsAPI.NXTRecord.NameNext"/>
            and   [BITMAP] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.NXTRecord.TypeBitMap"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.NULLRecord">
            <summary>
            Represents NULL data for a DNS resource record. (DNS_NULL_DATA)
            </summary>
            <remarks>
            The NULLRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.NULLRecord.ByteCount">
            <summary>
            Gets or sets the byte count.
            </summary>
            <remarks>
            Number of bytes represented in Data. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.NULLRecord.Data">
            <summary>
            Gets or sets the data.
            </summary>
            <remarks>
            Null data.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.NULLRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            byte count: [BYTECT] data: [DATA]
            where [BYTECT] = string representation of <see cref="F:JetBrains.Util.DnsAPI.NULLRecord.ByteCount"/>
            and   [DATA] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.NULLRecord.Data"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.MXRecord">
            <summary>
            Represents a DNS Mail Exchange record (DNS_MX_DATA).
            </summary>
            <remarks>
            The MXRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.MXRecord.Exchange">
            <summary>
            Gets or sets the exchange's host name
            </summary>
            <remarks>
            Pointer to a string representing the fully qualified domain name 
            (FQDN) of the host willing to act as a mail exchange. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.MXRecord.Preference">
            <summary>
            Gets or sets the preference of the exchange.
            </summary>
            <remarks>
            Preference given to this resource record among others at the same 
            owner. Lower values are preferred. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.MXRecord.Pad">
            <summary>
            Reserved.
            </summary>
            <remarks>
            Reserved. Used to keep pointers DWORD aligned. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.MXRecord.ToString">
            <summary>
            Returns a string representation of this mail exchange.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            exchange (preference): [EXCH] ([PREF])
            where [EXCH] = string representation of <see cref="F:JetBrains.Util.DnsAPI.MXRecord.Exchange"/>
            and   [PREF] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.MXRecord.Preference"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.MINFORecord">
            <summary>
            Represents a DNS mail information (MINFO) record (DNS_MINFO_DATA)
            </summary>
            <remarks>
            The MINFORecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.MINFORecord.Mailbox">
            <summary>
            Gets or sets the mailbox name
            </summary>
            <remarks>
            Pointer to a string representing the fully qualified domain name 
            (FQDN) of the mailbox responsible for the mailing list or mailbox 
            specified in the record's owner name. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.MINFORecord.ErrorsMailbox">
            <summary>
            Gets or sets the error mailbox name
            </summary>
            <remarks>
            Pointer to a string representing the FQDN of the mailbox to receive 
            error messages related to the mailing list. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.MINFORecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            mailbox: [MAILBOX] error mailbox: [ERRMAILBOX]
            where [MAILBOX] = string representation of <see cref="F:JetBrains.Util.DnsAPI.MINFORecord.Mailbox"/>
            and   [ERRMAILBOX] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.MINFORecord.ErrorsMailbox"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.LOCRecord">
            <summary>
            Represents a DNS Location record (DNS_LOC_DATA)
            </summary>
            <remarks>
            <para>
            The LOCRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </para>
            <para>
            For <see cref="F:JetBrains.Util.DnsAPI.LOCRecord.Altitude"/>, altitude above or 
            below sea level may be used as an approximation of altitude 
            relative to the [WGS 84] spheroid, however, there will be 
            differences due to the Earth's surface not being a perfect 
            spheroid. For example, the geoid (which sea level approximates) 
            for the continental US ranges from 10 meters to 50 meters below 
            the [WGS 84] spheroid. Adjustments to <see cref="F:JetBrains.Util.DnsAPI.LOCRecord.Altitude"/> 
            and/or <see cref="F:JetBrains.Util.DnsAPI.LOCRecord.VerPrec"/> will be necessary in most cases. 
            The Defense Mapping Agency publishes geoid height values relative 
            to the [WGS 84] ellipsoid.
            </para>
            <para>
            For more information about the LOC RR, see RFC 1876.
            </para>
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.Version">
            <summary>
            Gets or sets the version
            </summary>
            <remarks>
            Version number of the representation. Must be zero. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.Size">
            <summary>
            Gets or sets the size
            </summary>
            <remarks>
            Diameter of a sphere enclosing the described entity, in centimeters, 
            expressed as a pair of four-bit unsigned integers, each ranging from 
            zero to nine, with the most significant four bits representing the base 
            and the second number representing the power of ten by which to multiply 
            the base. This format allows sizes from 0e0 (&lt;1cm) to 9e9 (90,000km) 
            to be expressed. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.HorPrec">
            <summary>
            Gets or sets the horizontal precision
            </summary>
            <remarks>
            Horizontal precision of the data, in centimeters, expressed using the 
            same representation as wSize. This is the diameter of the horizontal 
            circle of error, rather than a plus or minus value. Matches the 
            interpretation of wSize; to get a plus or minus value, divide by 2. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.VerPrec">
            <summary>
            Gets or sets the vertical precision
            </summary>
            <remarks>
            Vertical precision of the data, in centimeters, expressed using the 
            same representation as wSize. This value represents the total potential 
            vertical error, rather than a plus or minus value. Matches the 
            interpretation of wSize; to get a plus or minus value, divide by 2. 
            If altitude above or below sea level is used as an approximation for 
            altitude relative to the [WGS 84] ellipsoid, the precision value should 
            be adjusted.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.Latitude">
            <summary>
            Gets or sets the latitude of the location
            </summary>
            <remarks>
            Latitude of the center of the sphere described by wSize, expressed as a 
            32-bit integer, with the most significant octet first (network standard 
            byte order), in thousandths of a second of arc. 2^31 represents the 
            equator, larger numbers are north latitude. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.Longitude">
            <summary>
            Gets or sets the longitude of the location
            </summary>
            <remarks>
            Longitude of the center of the sphere described by wSize, expressed as a 
            32-bit integer, most significant octet first (network standard byte order),
            in thousandths of a second of arc, rounded away from the prime meridian. 
            2^31 represents the prime meridian, larger numbers are east longitude.. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.LOCRecord.Altitude">
            <summary>
            Gets or sets the altitude of the location
            </summary>
            <remarks>
            Altitude of the center of the sphere described by wSize, expressed as a 
            32-bit integer, most significant octet first (network standard byte order),
            in centimeters, from a base of 100,000m below the [WGS 84] reference 
            spheroid used by GPS (semimajor axis a=6378137.0, reciprocal flattening 
            rf=298.257223563). See Remarks for more information. 
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.KEYRecord">
            <summary>
            Represents a Public key DNS record (DNS_KEY_DATA)
            </summary>
            <remarks>
            The KEYRecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.KEYRecord.Flags">
            <summary>
            Gets or sets the flags
            </summary>
            <remarks>
            Flags used to specify mapping, as described in IETF RFC 2535. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.KEYRecord.Protocol">
            <summary>
            Gets or sets the protocol
            </summary>
            <remarks>
            Protocol for which the key specified in the resource record can be used. The assigned values are shown in the following table. 
            
            <list type="table">
               <listheader>
                 <term>Value</term>
                 <description>Meaning</description>
               </listheader>
               <item>
                 <term>1</term>
                 <description>TLS</description>
               </item>
               <item>
                 <term>2</term>
                 <description>E-Mail</description>
               </item>
               <item>
                 <term>3</term>
                 <description>DNSSEC</description>
               </item>
               <item>
                 <term>4</term>
                 <description>IPSec</description>
               </item>
               <item>
                 <term>255</term>
                 <description>All protocols</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.KEYRecord.Algorithm">
            <summary>
            Gets or sets the algorithm
            </summary>
            <remarks>
            Algorithm used with the key specified in the resource record. The assigned values are shown in the following table. 
            
            <list type="table">
               <listheader>
                 <term>Value</term>
                 <description>Meaning</description>
               </listheader>
               <item>
                 <term>1</term>
                 <description>RSA/MD5 (RFC 2537)</description>
               </item>
               <item>
                 <term>2</term>
                 <description>Diffie-Hellman (RFC 2539)</description>
               </item>
               <item>
                 <term>3</term>
                 <description>DSA (RFC 2536)</description>
               </item>
               <item>
                 <term>4</term>
                 <description>Elliptic curve cryptography</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.KEYRecord.Key">
            <summary>
            Gets or sets the key
            </summary>
            <remarks>
            Public key, represented in base 64 as described in Appendix A of RFC 2535.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.KEYRecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            flags: [FLAGS] protocol: [PROTO] algorithm: [ALGOR] key: [KEY]
            where [FLAGS] = string representation of <see cref="F:JetBrains.Util.DnsAPI.KEYRecord.Flags"/>
            and   [PROTO] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.KEYRecord.Protocol"/>
            and   [ALGOR] = string representation of <see cref="F:JetBrains.Util.DnsAPI.KEYRecord.Algorithm"/>
            and   [KEY] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.KEYRecord.Key"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.ARecord">
            <summary>
            Represents a DNS Address record (DNS_A_DATA)
            </summary>
            <remarks>
            The ARecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.ARecord.Address">
            <summary>
            Gets or sets the ip address.
            </summary>
            <remarks>
            IPv4 address, in the form of an uint datatype. 
            <see cref="P:System.Net.IPAddress.Address"/> could be 
            used to fill this property.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.ARecord.ToString">
            <summary>
            Returns a string representation of the A Record
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            ip address: [ADDRESS]
            where [ADDRESS] = <see cref="M:System.Net.IPAddress.ToString"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.AAAARecord">
            <summary>
            Represents a IPv6 Address record (DNS_AAAA_DATA)
            </summary>
            <remarks>
            The AAAARecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.AAAARecord.Address">
            <summary>
            Gets or sets the ip6 address
            </summary>
            <remarks>
            IPv6 address, in the form of an <see cref="T:JetBrains.Util.DnsAPI.IP6Address"/> structure. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.AAAARecord.ToString">
            <summary>
            returns a string representation of this AAAA record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            Address: [ADDRESS]
            where [ADDRESS] = <see cref="M:JetBrains.Util.DnsAPI.IP6Address.ToString"/>
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DnsAPI.ATMARecord">
            <summary>
            Represents a DNS ATM address (ATMA) record (DNS_ATMA_DATA)
            </summary>
            <remarks>
            The ATMARecord structure is used in conjunction with 
            the <see cref="T:JetBrains.Util.DnsAPI.DnsRequest"/> and <see cref="T:JetBrains.Util.DnsAPI.DnsResponse"/> 
            classes to programmatically manage DNS entries.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.ATMARecord.AddressType">
            <summary>
            Gets or sets the address type
            </summary>
            <remarks>
            ATM address format. Two possible values are DNS_ATMA_FORMAT_E164 or DNS_ATMA_FORMAT_AESA. 
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DnsAPI.ATMARecord.Address">
            <summary>
            Gets or sets the address
            </summary>
            <remarks>
            ATM address. For E164, represents a NULL-terminated string of less than DNS_ATMA_MAX_ADDR_LENGTH. For AESA, its length is exactly DNS_ATMA_AESA_ADDR_LENGTH. 
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DnsAPI.ATMARecord.ToString">
            <summary>
            Returns a string representation of this record.
            </summary>
            <returns></returns>
            <remarks>
            The string returned looks like:
            <code>
            address type: [TYPE] address: [ADDRESS]
            where [TYPE] = hexadecimal representation of <see cref="F:JetBrains.Util.DnsAPI.ATMARecord.AddressType"/>
            and   [ADDRESS] = string representation of <see cref="F:JetBrains.Util.DnsAPI.ATMARecord.Address"/>
            </code>
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteIfNeeded(System.Object)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteIfNeeded(System.Threading.Thread)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteIfNeededCore(System.Object)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteListIfNeeded(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeeded(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, sorted lexicographically, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeeded``1(JetBrains.Util.dataStructures.Sources.CollectionSource{``0})">
            <summary>
            Writes the number of items and a comma-separated list of the items, sorted lexicographically, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeeded``1(JetBrains.Util.dataStructures.FrugalLocalList{``0})">
            <summary>
            Writes the number of items and a comma-separated list of the items, sorted lexicographically, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteListIfNeededCore(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, quoting each item if it contains spaces.
            The order of items is preserved.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeededCore(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, quoting each item if it contains spaces.
            The items are sorted lexicographically.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.WithNotNull``1(``0,System.Action{``0})">
            <summary>
            Executes <paramref name="F"/> on the <paramref name="item"/>, if the <paramref name="item"/> is not <c>Null</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.WeakHolder`1">
            <summary>
            Represents a typed weak reference which can be compared by target
            </summary>
        </member>
        <member name="M:JetBrains.Util.WeakHashSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakHashSet`1.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakHashSet`1.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:JetBrains.Util.WeakHashSet`1.Entry.PrevEntryIndex">
            <summary>
            Index of previous entry in the chain of keys with the same hashcodes (modulo size), -1 means first
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.FixedBuffer">
            <summary>
            Manages an unmanaged buffer with a fixed address in the memory.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.FixedBuffer.bInFinalizationQueue">
            <summary>
            GC can add to final-queue more than once, so track the state. 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.FixedBuffer.#ctor">
            <summary>
            Constructs the object without any allocated memory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.FixedBuffer.#ctor(System.Int32)">
            <summary>
            Constructs the object and allocates the desired length.
            The object must then be disposed of, to free the memory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.FixedBuffer.Allocate(System.Int32)">
            <summary>
            Allocates or reallocates the buffer to fit the length specified.
            No attempts are currently made to minimize the number of resizes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.FixedBuffer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.Interop.FixedBuffer.Address">
            <summary>
            Gets the fixed address of the allocated buffer (safe for passing into unmanaged funcs), throws if not allocated yet.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.FixedBuffer.IsAllocated">
            <summary>
            Gets whether the buffer has been allocated, and its <see cref="P:JetBrains.Util.Interop.FixedBuffer.Length"/> and <see cref="P:JetBrains.Util.Interop.FixedBuffer.Address"/> properties can be accessed.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Interop.FixedBuffer.Length">
            <summary>
            Gets the length of the allocated buffer, throws if not allocated yet.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.ImportAddressTableHook">
            <summary>
            Provides for hooking into the Import Address Table (IAT) of a DLL.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.ImportAddressTableHook.IterationLimit">
            <summary>
            Limits the number or items in the list to guard off infinite loops.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.ImportAddressTableHook.Install(System.String,System.String,System.Void*,System.Delegate)">
            <summary>
            Installs an Import Address Table (IAT) hook.
            You choose a function (<paramref name="sFuncMod"/>, <paramref name="sFuncName"/>) whose entry will be replaced in the IAT of the specified module (<paramref name="hCallingMod"/>) to point to your own implementation (<see cref="!:pNewFunction"/>) instead.
            </summary>
            <param name="sFuncMod">Name of the module in which the function-to-be-hooked is defined. Example: <c>USER32.DLL</c>.</param>
            <param name="sFuncName">Name of the function to be hooked. Example: <c>SystemParametersInfoW</c>. Note that for the functions that have separate ANSI and Wide versions you must include a suffix in the function name. Must have the <c>stdcall</c> (<c>WINAPI</c>, <c>PASCAL</c>) calling convention.</param>
            <param name="hCallingMod">The module whose IAT is to be patched. Its calls to the Function will be intercepted.</param>
            <param name="pNewFunction">The new implementation to replace the Function, in view of <paramref name="hCallingMod"/>. The hook will hold a reference on the delegate. Note that it's up to you to provide the appropriate signature of the delegate, which must match the one of the Function. Pay attention to the charset and bitness issues.</param>
        </member>
        <member name="M:JetBrains.Util.Interop.ImportAddressTableHook.Install(System.String,System.String,System.String,System.Delegate)">
            <summary>
            Installs an Import Address Table (IAT) hook.
            You choose a function (<paramref name="sFuncMod"/>, <paramref name="sFuncName"/>) whose entry will be replaced in the IAT of the specified module (<paramref name="sCallingMod"/>) to point to your own implementation (<see cref="!:pNewFunction"/>) instead.
            </summary>
            <param name="sFuncMod">Name of the module in which the function-to-be-hooked is defined. Example: <c>USER32.DLL</c>.</param>
            <param name="sFuncName">Name of the function to be hooked. Example: <c>SystemParametersInfoW</c>. Note that for the functions that have separate ANSI and Wide versions you must include a suffix in the function name. Must have the <c>stdcall</c> (<c>WINAPI</c>, <c>PASCAL</c>) calling convention.</param>
            <param name="sCallingMod">The module whose IAT is to be patched. Its calls to the Function will be intercepted. Must be loadable with <c>LoadLibrary</c> (or already loaded).</param>
            <param name="pNewFunction">The new implementation to replace the Function, in view of <paramref name="sCallingMod"/>. The hook will hold a reference on the delegate. Note that it's up to you to provide the appropriate signature of the delegate, which must match the one of the Function. Pay attention to the charset and bitness issues.</param>
        </member>
        <member name="M:JetBrains.Util.Interop.ImportAddressTableHook.InstallCore(System.String,System.String,System.Void*,System.String,System.Delegate)">
            <summary>
            Impl for the <c>Install</c> family functions. <paramref name="hCallingMod"/> MUST be specified, while its name <paramref name="sCallingMod"/> is optional (for diag).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.ImportAddressTableHook.AssertNoWin32Error">
            <summary>
            Throw on GetLastError.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.ImportAddressTableHook.DelegateAddRef(System.Delegate)">
            <summary>
            Ensures the delegate would not be ever collected.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.ImportAddressTableHook.UnsafeNativeMethods">
            <summary>
            Personal declarations for the WinAPI calls.
            Not shared with WinAPI.Interop, as there're pointers where applicable instead of intptrs.
            Was written to be compatible with ANSI/Wide charsets and 32/64 bit systems.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.ImportAddressTableHook.UnsafeNativeMethods.IMAGE_THUNK_DATA">
            <summary>
            It's DWORD in 32bit and ULONGLONG in 64bit, so use void* for both.
            Yes, there's only one field unioned in there.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.Modules.ControlPaint">
            <summary>
            Encapsulates the utility classes for painting the controls.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.DebugOutputLogEventListener">
            <summary>
            Listens for the <see cref="T:JetBrains.Util.Logging.Logger"/> events and reports them into the Debug stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.DebugOutputLogEventListener.#ctor(System.String)">
            <summary>
            Constructs the listener.
            </summary>
            <param name="prefix">A prefix that will be prepended to each of the output lines.</param>
        </member>
        <member name="F:JetBrains.Util.Logging.DebugOutputLogEventListener.OptionDontWriteDebugStream">
            <summary>
            Helper flag to prevent the logger messages from being emitted as traces when it's known that the message will get into the traces with some other means.
            Eg when capturing Trace::WriteLine into the Logger, the logger should be prevented from emitting it to the Debug stream, as it will be a duplicate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.DebugOutputLogEventListener.WriteDebugStream(System.String,System.String)">
            <summary>
            Writes a <paramref name="body"/> string to the Debug output stream.
            Appends the <paramref name="prefix"/> to the beginning of each line for the filtering needs.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.DebugOutputLogEventListener.CombinePrefices(System.String)">
            <summary>
            Combines the predefined object prefix with the given prefix. Both might be empty.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Logger.LogFileNamePrefix">
            <summary>
            Prefix of the log file name, in case it's generated automatically.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Logger.LogsSubfolderName">
            <summary>
            Subfolder inside the user's temp where the log files are stored.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Annotate(System.Action,System.Action{System.Exception})">
            <summary>
            <para>Executes the <paramref name="F">nested action</paramref>.</para>
            <para>If the action fails with an exception, allows to annotate the exception with additional context info in <paramref name="FCommentException"/>.</para>
            <para>The choices for the annotation are:</para>
            <list type="numbered">
            <item><description>To refine the context information, call the <see cref="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})"/> fluent method on the exception object you're given.</description></item>
            <item><description>To add one more level of context, throw a new exception nesting the orignial one as an <see cref="P:System.Exception.InnerException"/>.</description></item>
            </list>
            </summary>
            <param name="F">The worker code whose exceptions will be annotated.</param>
            <param name="FCommentException">Called only when the <paramref name="F">worker code</paramref> throws an exception. Allows to add context-related information to the exception.</param>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Assert(System.Boolean,System.String)">
            <summary>
            Invokes <see cref="M:JetBrains.Util.Logging.Logger.Fail(System.String)"/> if the <paramref name="condition"/> is <c>False</c>.
            This method do not break the execution flow, use Assertion::Assert if that is what's intended.
            </summary>
            <remarks>
            DO NOT ANNOTATE THIS METHOD WITH [AssertionMethod] OR [ContractAnnotation("bool-&gt;halt")].
            DON'T DO THIS. PLEASE. THIS IS WRONG. THIS METHOD DO NOT BREAK THE EXECUTION FLOW.
            PLEASE, FOR THE LOVE OF THE UNIVERSE, STOP DOING THIS. PLEASE, USE ASSERTION.ASSERT.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Assert(System.Boolean,System.String,System.Object[])">
            <summary>
            Invokes <see cref="M:JetBrains.Util.Logging.Logger.Fail(System.String)"/> if the <paramref name="condition"/> is <c>False</c>.
            This method do not break the execution flow, use Assertion::Assert if that is what's intended.
            </summary>
            <remarks>
            DO NOT ANNOTATE THIS METHOD WITH [AssertionMethod] OR [ContractAnnotation("bool-&gt;halt")].
            DON'T DO THIS. PLEASE. THIS IS WRONG. THIS METHOD DO NOT BREAK THE EXECUTION FLOW.
            PLEASE, FOR THE LOVE OF THE UNIVERSE, STOP DOING THIS. PLEASE, USE ASSERTION.ASSERT.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch(System.Action)">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch(System.Action,System.Action)">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="func"/> and returns its result or default value if exception happens.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch``1(System.String,System.Func{``0})">
            <summary>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch(System.String,System.Action)">
            <summary>
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnore(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnore``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="F"/>. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchSilent(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all of the exceptions, suppresses them (logs silently), and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchSilent``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="func"/>. Catches all of the exceptions, reports them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchSilent``2(``0,System.Func{``0,``1})">
            <summary>
            Executes the <paramref name="func"/>. Catches all of the exceptions, reports them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnoreException``2(System.Func{``0})">
            <summary>
            Executes the <paramref name="F"/>. Catches all exceptions except the ones that should be ignored
            (ProcessCancelledException for instance, these are silently suppressed), logs them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnoreException``1(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all exceptions except the ones that should be ignored
            (ProcessCancelledException for instance, these are silently suppressed), logs them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchButProcessCancelledException``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="f"/>. Catches all exceptions, but rethrow ProcessCancelledException
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchButProcessCancelledException(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all exceptions, but rethrow ProcessCancelledException
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CleanupOldLogFiles">
            <summary>
            Logs are stored for a week. Old log files are deleted by this function.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.DropException(System.Exception)">
            <summary>
            Drops the exception by doing nothing with it, not even logging it silently (unlike <see cref="M:JetBrains.Util.Logging.Logger.LogExceptionSilently(System.Exception)"/>).
            Use it to:
            (1) Stub catch-alls to avoid "empty general catch clause" warnings.
            (2) Explicitly mark such exception-hiding places for the later reviewing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Fail(System.String)">
            <summary>
            Logs the exception made from <paramref name="messageText"/>, as <see cref="!:LogExceptionEx"/> would do.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Fail(System.String,System.Object[])">
            <summary>
            Logs the exception made from <paramref name="format"/>, as <see cref="!:LogExceptionEx"/> would do.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.FormatStringSafe(System.String,System.Object[])">
            <summary>
            Invokes <see cref="M:System.String.Format(System.String,System.Object[])"/>, if it throws, falls back to appending the args as strings.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogError(System.String)">
            <summary>
            Invokes all the listeners for logging the message as an error.
            Then constructs an exception and logs it (again invoking the listeners, but for logging an exception this time).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogError(System.String,System.Object[])">
            <summary>
            Invokes all the listeners for logging the message as an error.
            Then constructs an exception and logs it (again invoking the listeners, but for logging an exception this time).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogException(System.Exception)">
            <summary>
            Writes the exception to the log and notifies the listeners about it.
            The executing stack trace is also written (see <see cref="!:LogExceptionEx"/> for suppressing).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogException(System.String,System.Exception)">
            <summary>
            Writes the exception to the log and notifies the listeners about it.
            The executing stack trace is also written (see <see cref="!:LogExceptionEx"/> for suppressing).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogExceptionSilently(System.Exception)">
            <summary>
            Logs the exception without notifying the registered listeners about it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(JetBrains.Util.LoggingLevel,System.String)">
            <summary>
            Logs a message if it is not too verbose.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(JetBrains.Util.LoggingLevel,System.String,System.Object[])">
            <summary>
            Logs a message if it is not too verbose.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(System.String)">
            <summary>
            Logs a message if it is not <see cref="F:JetBrains.Util.LoggingLevel.VERBOSE"/>.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(System.String,System.Object[])">
            <summary>
            Logs a message if it is not <see cref="F:JetBrains.Util.LoggingLevel.INFO"/>.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Logger.Interface">
            <summary>
            Gets this logger as an interface.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Logging.Logger.FileLoggingLevel">
            <summary>
            Defines the minimum level for the messages from <see cref="M:JetBrains.Util.Logging.Logger.LogMessage(System.String)"/>-family to be logged into the log file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.OFF">
            <summary>
            Do not use it in logging. Only in config to disable logging.
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.FATAL">
            <summary>
            For errors that are 
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.ERROR">
            <summary>
            For errors that must be shown in Exception Browser
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.WARN">
            <summary>
            Suspicious situations but not errors
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.INFO">
            <summary>
            Regular level for important events
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.VERBOSE">
            <summary>
            Additional info for debbuging
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.TRACE">
            <summary>
            Methods &amp; callstacks tracing, more than verbose
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcherActionException">
            <summary>
            An exception that reports a failure in the inner (deferred) task.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherActionException.#ctor(JetBrains.Threading.JetDispatcher,System.String,System.Exception)">
            <summary>
            Ctor.
            </summary>
            <param name="dispatcher">The dispatcher that tried to execute the faulty action.</param>
            <param name="name">Dispatcher action name, included in the exception message.</param>
            <param name="ex">Original exception message, included in the exception message, passed to the base.</param>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcherActionException.Dispatcher">
            <summary>
            Gets the dispatcher that tried to execute the faulty action.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcherActionException.Name">
            <summary>
            Gets the name of the action that failed.
            </summary>
        </member>
        <member name="T:JetBrains.Util.MessageBox">
            <summary>
            Shows a system Message Box.
            Supplies it automatically with icons, main window ownership, and product name in the title.
            Note: you should be using this class wherever possible instead of the system one, as it provides for consistent look.
            </summary>
        </member>
        <member name="F:JetBrains.Util.MessageBox.MessageBoxHandlers">
            <summary>
            Holds the stack of the message box handlers, the last one is executed when a message box is attempted to be shown.
            A handler has the same prototype as <see cref="M:JetBrains.Util.MessageBox.ShowCore(System.IntPtr,System.String,System.String,JetBrains.Interop.WinApi.MessageBoxFlags)"/>, but returns <c>Null</c> if it does not want to handle the message.
            By default, the message is displayed in a system message box.
            Should be modified in the Primary thread only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowCore(System.IntPtr,System.String,System.String,JetBrains.Interop.WinApi.MessageBoxFlags)">
            <summary>
            Shows a message box, owned by the specific window.
            </summary>
            <param name="window">Handle to the message box owner window, or <c>Null</c> to use the main window of the current application, if available.</param>
            <param name="text">Body text.</param>
            <param name="caption">Optional message box caption, an empty string to use the product name by default. Otherwise, the product name will be prepended to the provided caption text.</param>
            <param name="flags">Flags.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowError(System.String,System.String)">
            <summary>
            Shows a message box with an error message.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowError(System.String,System.String,System.IntPtr)">
            <summary>
            Shows a message box with an error message.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowExclamation(System.String,System.String)">
            <summary>
            Shows a message box with an exclamation message.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowExclamation(System.String,System.String,System.IntPtr)">
            <summary>
            Shows a message box with an exclamation message.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowInfo(System.String,System.String)">
            <summary>
            Shows a message box with an information message.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowInfo(System.String,System.String,System.IntPtr)">
            <summary>
            Shows a message box with an information message.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowMessageBox(System.String,System.String,System.IntPtr,JetBrains.Util.MbButton,JetBrains.Util.MbIcon)">
            <summary>
            Shows a message box, owned by the main window.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
            <param name="button">Buttons to use.</param>
            <param name="icon">Icon to use.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowMessageBox(System.String,System.String,JetBrains.Util.MbButton,JetBrains.Util.MbIcon)">
            <summary>
            Shows a message box, owned by the main window.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="button">Buttons to use.</param>
            <param name="icon">Icon to use.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowMessageBox(System.String,JetBrains.Util.MbButton,JetBrains.Util.MbIcon)">
            <summary>
            Shows a message box, owned by the main window.
            Product name is used for the title.
            </summary>
            <param name="text">Message body text.</param>
            <param name="button">Buttons to use.</param>
            <param name="icon">Icon to use.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowYesNo(System.String,System.String)">
            <summary>
            Shows a Yes/No question message box. Returns whether the answer was Yes.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowYesNo(System.String,System.String,System.IntPtr)">
            <summary>
            Shows a Yes/No question message box. Returns whether the answer was Yes.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowYesNo(System.String,System.String,System.IntPtr,System.Boolean)">
            <summary>
            Shows a Yes/No question message box. Returns whether the answer was Yes.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
            <param name="defaultButton">true - YES button selected by default, false - NO</param>>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowOKCancel(System.String,System.String)">
            <summary>
            Shows a OK/Cancel question message box. Returns whether the answer was Yes.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowOKCancel(System.String,System.String,System.IntPtr)">
            <summary>
            Shows a Yes/Cancel question message box. Returns whether the answer was Yes.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowOKCancel(System.String,System.String,System.IntPtr,System.Boolean)">
            <summary>
            Shows a OK/Cancel question message box. Returns whether the answer was Yes.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
            <param name="defaultButton">true - OK button selected by default, false - Cancel</param>>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowYesNoCancel(System.String,System.String)">
            <summary>
            Shows a Yes/No/Cancel question message box. Returns whether the answer was Yes or No, <c>Null</c> for Cancel.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowYesNoCancel(System.String,System.String,System.IntPtr)">
            <summary>
            Shows a Yes/No/Cancel question message box. Returns whether the answer was Yes or No, <c>Null</c> for Cancel.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
        </member>
        <member name="M:JetBrains.Util.MessageBox.ShowYesNoCancel(System.String,System.String,System.IntPtr,System.Nullable{System.Boolean})">
            <summary>
            Shows a Yes/No/Cancel question message box. Returns whether the answer was Yes or No, <c>Null</c> for Cancel.
            </summary>
            <param name="text">Message body text.</param>
            <param name="caption">Not recommended. Text to append to the default caption, which is the product name. In most cases, keep empty to have just the product name.</param>
            <param name="window">Not recommended. Owner window for the message box. Use only in dialogs when the default (app main window) could be inappropriate.</param>
            <param name="defaultButton">true - YES button selected by default, false - NO, null - CANCEL</param>>
        </member>
        <member name="M:JetBrains.Util.MessageBox.SimpleSystemMessageBoxHandler(System.IntPtr,System.String,System.String,JetBrains.Interop.WinApi.MessageBoxFlags)">
            <summary>
            Default implementation.
            Displays the system MessageBox, cannot provide main window ownership and product name.
            </summary>
        </member>
        <member name="T:JetBrains.Util.MbButton">
            <summary>
            Buttons layout selection for the message box.
            </summary>
            <remarks>
            Note: we're not using either WinForms or Avalon constants for this thing, because they're causing conflicting namespace imports into the code that calls the message box. For instance, importing the <c>System.Windows.Forms</c> namespace in an Avalon component brings much of similarly-named constants into visibility, with the need to qualify names.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.MbIcon">
            <summary>
            Icon selection for the message box.
            </summary>
            <remarks>
            Note: we're not using either WinForms or Avalon constants for this thing, because they're causing conflicting namespace imports into the code that calls the message box. For instance, importing the <c>System.Windows.Forms</c> namespace in an Avalon component brings much of similarly-named constants into visibility, with the need to qualify names.
            </remarks>
        </member>
        <member name="M:JetBrains.NumberUtil.FloatingToStringRoundtrip``1(``0)">
            <summary>
            Converts the value to a string.
            If it's of a floating-point format, applies round-trip conversion to avoid losing precision.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ProcessUtil.GetChildren(System.Diagnostics.Process)">
            <summary>
            Tries to get all of the child processes for a given process.
            Might accidentally mix processes up if the parent process terminates and its ID is reused.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ProcessUtil.Is64BitProcess(System.Diagnostics.Process)">
            <summary>
            Indicates if the process is 32 or 64 bit.
            </summary>
            <param name="process">process to query</param>
            <returns>true: process is 64 bit; false: process is 32 bit</returns>
            <exception cref="T:System.ComponentModel.Win32Exception">e.g. Access denied</exception>
        </member>
        <member name="M:JetBrains.Util.ProcessUtil.GetParent(System.Diagnostics.Process)">
            <summary>
            Tries to get the parent process for a given process.
            Might accidentally mix processes up if the parent process terminates and its ID is reused.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ProcessUtil.ShutdownGracefully(System.Diagnostics.Process,JetBrains.Util.ProcessUtil.ShutdownFlags,System.TimeSpan)">
            <summary>
            Initiates the process graceful shutdown by closing its main window.
            Optionally, kills the process abruptly if the shutdown fails to complete as the timeout expires.
            </summary>
            <param name="process">The process to kill. Could be own process.</param>
            <param name="flags">Behavior flags.</param>
            <param name="timeout">The timeout to wait for the process to shutdown gracefully (before exiting or killing the process). Ignored in some <paramref name="flags" /> combinations.</param>
            <returns>Whether the process has exited.</returns>
        </member>
        <member name="M:JetBrains.Util.ProcessUtil.IsRunningElevated">
            <summary>
            Gets whether the process is currently running elevated, i.e. with full administrator privileges. A <c>False</c> return value means either a LUA or an admin-approval mode.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.ProcessUtil.NativeWaitHandle">
            <summary>
            Allows to guise a native HANDLE as a netfx waitable handle.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ProcessUtil.ShutdownFlags">
            <summary>
            <see cref="M:JetBrains.Util.ProcessUtil.ShutdownGracefully(System.Diagnostics.Process,JetBrains.Util.ProcessUtil.ShutdownFlags,System.TimeSpan)"/> flags.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.ShutdownFlags.WaitSynchronously">
            <summary>
            After sending the shutdown control, does not return from the method until either the timeout expires or the process exits.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.ShutdownFlags.KillAfterTimeout">
            <summary>
            If the process fails to exit within the timeout, the process is killed.
            If <see cref="F:JetBrains.Util.ProcessUtil.ShutdownFlags.WaitSynchronously"/>, this method performs a non-pumping wait; otherwise, a timer is used to wait async.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsCreateNewProcessGroup">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.Constants.CreationFlags.CREATE_NEW_PROCESS_GROUP"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsCreateNoWindow">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.Constants.CreationFlags.CREATE_NO_WINDOW"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsDetachedProcess">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.Constants.CreationFlags.DETACHED_PROCESS"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsDontInhetitHandles">
            <summary>
            Passes <c>False</c> to <c>bInheritHandles</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsRedirectStdErr">
            <summary>
            Creates a custom pipe for the stream, gives the reader pipe end handle in <see cref="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.BeforeProcessRuns"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsRedirectStdIn">
            <summary>
            Creates a custom pipe for the stream, gives the reader pipe end handle in <see cref="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.BeforeProcessRuns"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.IsRedirectStdOut">
            <summary>
            Creates a custom pipe for the stream, gives the writer pipe end handle in <see cref="F:JetBrains.Util.ProcessUtil.CreateProcessInfo`1.BeforeProcessRuns"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ProcessUtil.Pipes">
            <summary>
            Handles to the standard streams of the child proecss, whichever were requested to be piped, others are NULL.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Colors.ColorManagement">
            <summary>
            Color Management routines.
            Contains a few simple static functions for working with RGB, BGR and HLS colors.
            Based in parts on ancient MSDN C++ samples (HLS-RGB conversion).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorManagement.LumaRed">
            <summary>
            Grayscale coefficients for HDTV luma from ITU-R BT.709: 0.2126, 0.7152, and 0.0722
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorManagement.LumaGreen">
            <summary>
            Grayscale coefficients for HDTV luma from ITU-R BT.709: 0.2126, 0.7152, and 0.0722
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorManagement.LumaBlue">
            <summary>
            Grayscale coefficients for HDTV luma from ITU-R BT.709: 0.2126, 0.7152, and 0.0722
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorManagement.c_nMaxHLS">
            <summary>
            Background for MaxHLS.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorManagement.c_nMaxRGB">
            <summary>
            Background for MaxRGB.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Colors.ColorManagement.c_nUndefinedHue">
            <summary>
            Background for UndefinedHue.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.RGBtoHLS(System.UInt32,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            RGBtoHLS() takes a DWORD RGB value and translates it to HLS BYTEs.
            
            A point of reference for the algorithms is Foley and Van Dam, "Fundamentals of Interactive Computer Graphics," Pages 618-19. Their algorithm is in floating point. CHART implements a less general (hardwired ranges) integral algorithm.
            
            There are potential round-off errors throughout this sample. ((0.5 + x)/y) without floating point is phrased ((x + (y/2))/y), yielding a very small round-off error. This makes many of the following divisions look strange. 
            </summary>
            <param name="lRGBColor">The source RGB color.</param>
            <param name="H">Resulting Hue value.</param>
            <param name="L">Resulting Luminance value.</param>
            <param name="S">Resulting Saturation value.</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.HueToRGB(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Utility routine for HLStoRGB.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.HLStoRGB(System.UInt16,System.UInt16,System.UInt16,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Converts an HLS color to an RGB color and returns three byte components.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.HLStoRGB(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Converts HLS to a <see cref="T:System.Drawing.Color"/> object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.HLStoBGR(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Works just like HLStoRGB, but reverses the return value (BGR DWORD instead of an RGB one).
            This is useful in case of Windows bitmaps which use BGR colors.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.Mix(System.UInt32,System.UInt32,System.Double)">
            <summary>
            Mixes two colors together in the proportion specified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.Mix(System.Drawing.Color,System.Drawing.Color,System.Double)">
            <summary>
            Mixes two colors together in the proportion specified.
            </summary>
            <param name="colorA">First color.</param>
            <param name="colorB">Second color.</param>
            <param name="proportion">A number in between <c>0.0</c> and <c>1.0</c>.</param>
            <returns>The new color.</returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.Mix(System.Windows.Media.Color,System.Windows.Media.Color,System.Double)">
            <summary>
            Mixes two colors together in the proportion specified.
            </summary>
            <param name="colorA">First color.</param>
            <param name="colorB">Second color.</param>
            <param name="proportion">A number in between <c>0.0</c> and <c>1.0</c>.</param>
            <returns>The new color.</returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.RGB2BGR(System.UInt32)">
            <summary>
            Converts a DWORD RGB color to BGR, or vice versa as it's symmetrical.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.BlendTwo(System.UInt32,System.UInt32)">
            <summary>
            Mixes two colors
            Does the same as Mix but for a fixed 1:1 proportion.
            </summary>
            <param name="rgbA"></param>
            <param name="rgbB"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetAlphaBlendedColor(System.Drawing.Color,System.Drawing.Color,System.Int32)">
            <summary>
            Blends two colors.
            </summary>
            <param name="g">Device context to get the nearest color from. May be <c>Null</c>, in which case the exact color is returned.</param>
            <param name="src">The first color.</param>
            <param name="dest">The second color.</param>
            <param name="alpha">The alpha value in the [0…FF] range.</param>
            <returns>The blended color, constrained to the device context or not.</returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetRValue(System.UInt32)">
            <summary>
            Extracts the R value from the RGB color (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetGValue(System.UInt32)">
            <summary>
            Extracts the G value from the RGB color (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetBValue(System.UInt32)">
            <summary>
            Extracts the B value from the RGB color (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.RGB(System.Byte,System.Byte,System.Byte)">
            <summary>
            Produces an RGB color out of R, G and B values (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.RGBA(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Produces an RGBA color out of R, G, B, and A values (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.RGB(System.Drawing.Color)">
            <summary>
            Produces an RGB color out of R, G and B values (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.RGB(System.Windows.Media.Color)">
            <summary>
            Produces an RGB color out of R, G and B values (R is less significant).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.ConstrainHls(System.Int32)">
            <summary>
            Constrains the integer value to the range of valid HLS values.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetContrastedForeground(System.Drawing.Color,System.Drawing.Color,System.Double,System.Double,System.Double)">
            <summary>
            Makes contrast foreground color (tries to preserve color and make well read foreground))
            </summary>
            <param name="background">Currently used background</param>
            <param name="foreground">Currently used foreground</param>
            <param name="contrast">Desired contrast, difference in lightness between background and foreground (value in range [0..1])</param>
            <param name="margin">Margin of lightness to avoid color missing, result's lightness will be in range [margin, 1-margin]</param>
            <param name="whiteBalance">Determine when we make darker and when lighter (must be in range from margin to 1 - margin)</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.MakeSimilarColor(System.Drawing.Color,System.Drawing.Color,System.Double,System.Double)">
            <summary>
            Makes a color similar to the pattern color in terms of brightness
            </summary>
            <param name="color">Base color</param>
            <param name="pattern">Pattern color</param>
            <param name="threshold">Differences [0..1] which is appropriate, base color returns in case of difference between base color and pattern less than the threshold</param>
            <param name="offset">Offset, required difference [0..1] from pattern lightness</param>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetSimilarForeground(System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Tries to correct suggested foreground color according to good one
            </summary>
            <param name="foreground"></param>
            <param name="goodForeground"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetDarkerColor(System.Drawing.Color,System.Double)">
            <summary>
            Makes darker color than the given one
            </summary>
            <param name="color">Base color</param>
            <param name="value">How darker it should be [0..1]</param>
            <returns>Darker color</returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.GetLighterColor(System.Drawing.Color,System.Double)">
            <summary>
            Makes lighter color than the given one
            </summary>
            <param name="color">Base color</param>
            <param name="value">How darker it should be [0..N] (for ex., value 0.2 is 20% lighter)</param>
            <returns>Darker color</returns>
        </member>
        <member name="M:JetBrains.Util.Colors.ColorManagement.BlendColors(System.Drawing.Color,System.Drawing.Color,System.Double)">
            <summary>
            Blend two colors
            </summary>
            <param name="a">Color a</param>
            <param name="b">Color b</param>
            <param name="proportion">How many of color 'a' in result blended color [0..1]</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorManagement.MaxHLS">
            <summary>
            H, L, and S vary over 0-c_nMaxHLS.
            Best if divisible by 6.
            Must fit in a System.Byte.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorManagement.MaxRGB">
            <summary>
            R, G, and B vary over 0-c_nMaxRGB.
            Must fit in a <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Colors.ColorManagement.UndefinedHue">
            <summary>
            Hue is undefined if Saturation is 0 (grey-scale). This value determines where the Hue scrollbar is initially set for achromatic colors.
            Set tot 2/3 of MaxHLS by default.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Src.Concurrency.ConcurrentFlag.#ctor">
            <summary>
            Creates a closed flag.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Console.ConsoleFlashMode">
            <summary>
            Summary description for ConsoleWriter.
            </summary>
            
        </member>
        <member name="T:JetBrains.Util.DataStructures.ChunkList`1">
            <summary>
            List splitted to chunks to avoid LOH
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.#ctor(System.Int32)">
            <summary>
            Create chunk array with pre-allocated given size
            </summary>
            <param name="initialSize"></param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.Compact">
            <summary>
            Resize last chunk to fit exact element number
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.BinarySearch(System.Func{`0,System.Int32})">
            <returns>found index. Less than 0 if not found</returns>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ChunkPackedIntArray">
            <summary>
             Presents <c>uint[]</c> (this) packed into <c>uint[][]</c> (myChunks). Each chunk is <c>UncheckedPackedIntArray</c> which supplies compression.
             Chunks are used to avoid LOH.
             
            To take <c>i</c>-th element of 'this', invoke <c>GetItem(i, valueBits, 0)</c>. You can also use <c>this[ith]</c> to get/set values with array of one element (in case
            of <c>valueBits</c> less than '32'.
            
            One can increase or reduce size of elem by invocation of <c>IncreaseValueBits(ChunkPackedIntArray oldArray, int newValueBits)</c>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkPackedIntArray.GetItem(System.Int32,System.Int32)">
            <summary>
            Returns the first element of <see cref="P:JetBrains.Util.DataStructures.ChunkPackedIntArray.Item(System.Int32)"/> array
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.CompactMapBase`4">
            <summary>
            Base for all space-optimized hash-maps with only 2 bits overhead for each entry. Implements so called "open-addressing" hash-maps.  
            </summary>
            <typeparam name="TKey">key class</typeparam>
            <typeparam name="TValue">value class</typeparam>
            <typeparam name="TStorage">Class of internal storage. Can be plain array of <c>TData</c> or e.g. packed array for memory optimization.</typeparam>
            <typeparam name="TData">Entry in storage.</typeparam>
        </member>
        <member name="T:JetBrains.Util.DataStructures.CompactSet`1">
            <summary>
            Collection of distinct (as per <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>) elements with <code>O(1+maxLoadFactor)</code>
            asymptotic time for item's addition, removal and searching and <code>O(1/maxLoadfactor)</code> space usage.
            Actual number of additional heap space for each element (not considering loadFactor's reseve) is 2 bits (comparing to 64 bits in <see cref="T:System.Collections.Generic.JetHashSet`1"/>).
            So for each element <see cref="T:JetBrains.Util.DataStructures.CompactSet`1"/> stores 32 bits for item's reference and 2 bits for state (OCCUPIED, FREE, REMOVED). This set is little bit slower than
            <see cref="T:System.Collections.Generic.JetHashSet`1"/>, so main use case is when you need to retain big set with small items (relative to number of bytes held by item) in memory for a long time 
            (e.g. caches) and you want to economize memory usage.
            </summary>
            <typeparam name="T">Type of item</typeparam>
        </member>
        <member name="M:JetBrains.Util.DataStructures.CompactOneToListMap`2.RemoveValues(`0,System.Collections.Generic.ICollection{`1})">
            <summary>
            Removes all specified values for given key. Effectivenes of removal depends of implementation of <see cref="!:valuesToRemove"/> - for hashset, time-complexity will be linear
            O(n), where n - number of values in map, corresponding to <see cref="!:key"/>.
            </summary>
            <param name="key"></param>
            <param name="valuesToRemove"></param>
        </member>
        <member name="T:JetBrains.Util.Locator`1">
            <summary>
            A delegate for a <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>-like method, but with the right side of the comparison assumed to be already known by the method. The item you get is the left side of the comparison.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Comparator`1">
            <summary>
            A delegate for a <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>-like method.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ListUtil.SubtractSortedInplace``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Subtracts the <paramref name="subtrahend"/> from the <paramref name="minuend"/>, the difference is written into the <see cref="!:minuend"/>, inplace, so that the original list is destoryed.
            </summary>
            <returns>The difference, in the <paramref name="minuend"/> instance.</returns>
        </member>
        <member name="T:JetBrains.Util.MultiTypeComparer.ComparerInvoker`1">
            <summary>
            Typed wrapper for delegate
            </summary>
            <typeparam name="T">Type of item to present</typeparam>
        </member>
        <member name="P:JetBrains.Util.OneToSetMap`2.Values">
            <summary>
            Gets the collection of values contained in all of the keys.
            Duplicates are preserved.
            All the operations are slow on this collection, especially including the <see cref="P:JetBrains.Util.OneToSetMap`2.ValuesCollection.Count"/> property.
            </summary>
        </member>
        <member name="T:JetBrains.Util.OneToSetMap`2.ValuesCollection">
            <summary>
            Exposes all of the values as a single collection.
            If some value is held by more than one key, it's returned twice.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.Add(`1)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only. </exception>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.Contains(`1)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific value.
            </summary>
            
            <returns>
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.CopyTo(`1[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or-arrayIndex is equal to or greater than the length of array.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from arrayIndex to the end of the destination array.-or-Type T cannot be cast automatically to the type of the destination array.</exception>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.Remove(`1)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if item is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.ValuesCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Util.OneToSetMap`2.ValuesCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
        </member>
        <member name="P:JetBrains.Util.OneToSetMap`2.ValuesCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.
            </returns>
            
        </member>
        <member name="M:JetBrains.Util.DataStructures.PrimeFinder.NextPrime(System.Int32)">
             Returns a prime number which is <code>&gt;= desiredCapacity</code>
             and very close to <code>desiredCapacity</code> (within 11% if
             <code>desiredCapacity &gt;= 1000</code>).
            
             @param desiredCapacity the capacity desired by the user.
             @return the capacity which should be used for a hashtable.
        </member>
        <member name="F:JetBrains.Util.DataStructures.PrimeFinder.Table">
            <summary>
            Table of prime numbers from 2 to 10000
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.ParseInvariantString(System.String,System.Type,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">String representation.</param>
            <param name="type">Desired type of the object to be restored from the string representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.ParseInvariantString``1(System.String,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <typeparam name="T">Desired type of the object to be restored from the string representation.</typeparam>
            <param name="value">String representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.ToInvariantString(System.Object,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">Value to be converted to a string.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetBaseClassesAndInterfaces(System.Type)">
            <summary>
            Performs a BFS for base classes and interfaces of a type, self not included.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetAllAssignableToTypes(System.Type)">
            <summary>
            Performs a BFS (I don't think so anymore) for base classes and interfaces of a type, self included.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
            </summary>
            <example>
            Class field declaration:
            <code>
            public class Class { public string Field; } 
            </code>
            Getting its name (“Field”):
            <code>ReflectionExtensions.GetInstanceMemberName&lt;Class&gt;(c=>c.Field)</code>
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetStaticMemberName(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
            </summary>
            <example>
            Class field declaration:
            <code>
            public class Class { public static string Field; }
            </code>
            Getting its name (“Field”):
            <code>ReflectionExtensions.GetStaticMemberName(()=>Class.Field)</code>
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMember``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and you'll get the member it's pointing to.</para>
            </summary>
            <example>
            See <see cref="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})"/>.
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetStaticMember(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and you'll get the member it's pointing to.</para>
            </summary>
            <example>
            See <see cref="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})"/>.
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
            <para>This overload has the member return value strongly typed, for use in accessor APIs where an expression returning <see cref="T:System.Object"/> is not applicable.</para>
            </summary>
            <example>
            Class field declaration:
            <code>
            public class Class { public string Field; } 
            </code>
            Getting its name (“Field”):
            <code>ReflectionExtensions.GetInstanceMemberName&lt;Class&gt;(c=&gt;c.Field)</code>
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName(System.Linq.Expressions.LambdaExpression)">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
            <para>This overload has the member return value strongly typed, for use in accessor APIs where an expression returning <see cref="T:System.Object"/> is not applicable.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and you'll get the member it's pointing to.</para>
            </summary>
            <example>
            See <see cref="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>.
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMembersChain(System.Linq.Expressions.Expression)">
            <summary>
            Gets the chain of member access based on the expression passed in, from outermost to innermost members.
            Could be used e.g. for creating Avalon early-bound data binding property path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TemporaryDirectoryCookie.CreateFolder(JetBrains.Util.FileSystemPath,System.String)">
            <summary>
            Creates temporary folder in specified parent folder. Parent folder must exist.
            If parent folder is omitted %temp% is used
            </summary>
        </member>
        <member name="M:JetBrains.Util.TemporaryDirectoryCookie.CreateFolderEx(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,System.String,System.Boolean)">
            <summary>
            Creates temporary folder in specified parent folder. Parent folder must exist.
            If parent folder is omitted %temp% is used
            </summary>
        </member>
        <member name="M:JetBrains.Util.TemporaryDirectoryCookie.CreateFolder(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,System.String,System.Boolean)">
            <summary>
            Creates temporary folder in specified parent folder. Parent folder must exist.
            If parent folder is omitted %temp% is used
            </summary>
        </member>
        <member name="M:JetBrains.Util.TemporaryDirectoryCookie.UseFolder(JetBrains.Util.FileSystemPath)">
            <summary>
            Use folder as temporary and  clean-up on dispose
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetFastSemiReenterableRWLock">
            <summary>
            ReaderWriter lock for relatively small critical sections. Uses spinwait locks and interlocked internally, so CPU do meanless job before lock acquiring (not event-based).
            
            In JET_MODE_ASSERT:
            If thread acquires write lock it can aquire this lock read and write fashion any number of times recursively afterwards. If thread acquires readlock - it can't acquire recursively read and write lock (on this lock) any more,
            so readlock isn't reenterable.
            
            In production configuration: breach of abovementioned items can lead to deadlock.
            
            Also, locks must be released in reversed order to order they were acquired (is controlled by assertions).
            <code>UsingReadLock()</code> and <code>UsingWriteLock()</code> methods helps to follow this pattern.  
            
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetFastSemiReenterableRWLock.myState">
            <summary>
            State of this RWLock. Can be presented as sum of following:
            1) <see cref="F:JetBrains.Threading.JetFastSemiReenterableRWLock.WriteLockFactor"/> * WriterThread.ManagedThreadId - if some writer've took write lock
            2) - <see cref="F:JetBrains.Threading.JetFastSemiReenterableRWLock.ReenterLockFactor"/> * number_of_times_this_writer_lock_was_taken_recursively_either_in_write_or_read_mode  - for reentrancy, excludes the first acquiring (it is counted in 1.)
            3) - number_of_threads_acquired_read_lock (sometimes in writer mode this parameter is still present, it introduced by readers that tried to acquire read lock but were overtaken by writer) 
            
            So if state is lower than zero it means that RWLock in Read mode
            If state is greater than zero - RWLock in Write mode
            If state is zero - RWLock is free
            </summary>   
            
            
            | 32 bits - managedThreadId | 8 bits - #times lock taken reenterant | 24 bits - number of readers that take lock |
        </member>
        <member name="F:JetBrains.Threading.JetFastSemiReenterableRWLock.myAwaitingWritersCount">
            <summary>
            Number of writers that are awaiting for releasing of read locks to aquire write lock. This field is introduced only to prevent writers starvation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Mmf.SharedMemoryMessageBase.DiagDecodeMessage(System.Byte[])">
            <summary>
              Call for diagnostic only, because it's not guaranteed to work for all messages. Set this to up-to-date message decoder when debugging.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter.myQueueUnsent">
            <summary>
              If there's no space for sending more messages, they can be stacked here.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter.SendMessage(System.Byte[])">
            <summary>
              Sends a message to the receiving party. If the buffer is currently full, stores it in queue and does not block.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter.EnsureSent">
            <summary>
              Makes sure all of the messages currently on the queue get sent out, synchronously.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.SynchronizedLifetime">
            <summary>
              <para>Synchronizes lifetime-driven activities on multiple threads.</para>
              <para>If you use your component lifetime directly, it might be terminated in the middle of some background activity.</para>
              <para>
                You should rather create this object on your home thread and use its <see cref="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteIfNotTerminated(System.Action)"/> to run background-thread activities (possibly on multiple threads). It is guaranteed that as the outer lifetime starts termination, this particular lifetime will live thru until your background action is completed.
              </para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.myDispatcher">
            <summary>
            Non-<c>Null</c> to specify the thread to which the object termination is affined.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.myLockSync">
            <summary>
              Terminates under a writer lock. All other activity goes under a reader lock.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.op_Implicit(JetBrains.Util.Threading.SynchronizedLifetime)~JetBrains.DataFlow.Lifetime">
            <summary>
              Gets the lifetime whose termination is synchronized by this object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteIfNotTerminated(System.Action)">
            <summary>
              <para>Executes the action unless the lifetime has already been terminated.</para>
              <para>Free-threaded <see cref="M:JetBrains.DataFlow.Lifetime.AddAction(System.Action)"/> calls are only safe within this method.</para>
            </summary>
            <param name="λ"></param>
            <returns>
              Whether the lifetime is still alive (action might be prevented, aborted or completed when <c>False</c>; it's definitely been completed if <c>True</c>).
            </returns>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteIfNotTerminated``1(System.Func{``0})">
            <summary>
              Executes the action unless the lifetime has already been terminated on the main thread.
            </summary>
            <param name="λ"></param>
            <returns>
              If the lifetime is still alive, executes the action and returns its result. Otherwise, returns null.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteSynchronizedWithTermination(System.Action)">
            <summary>
              <para>Synchronizes this action with lifetime termination on another thread.</para>
              <para>For terminations on the same thread, there're obviously no guarantees, as we cannot “wait” until it gets clear.</para>
              <para>But regarding termination on other threads, it's guaranteed the lifetime state is consistent and won't change within the duration of this action (either fully alive or fully terminated).</para>
            </summary>
            <param name="F"></param>
            <remarks>
            There's no flag to tell you if termination is in progress right now (but not yet complete). <see cref="P:JetBrains.Util.Threading.SynchronizedLifetime.IsTerminated"/> will be <c>True</c> when either termination is running or fully completed.
            If you need to allow some actions to execute within termination, but not with a fully dead lifetime — you must create a nested lifetime which will either be all good or all dead at that point, and use that for determination.
            </remarks>
        </member>
        <member name="P:JetBrains.Util.Threading.SynchronizedLifetime.IsTerminated">
            <summary>
            Works just like <see cref="P:JetBrains.Util.Threading.SynchronizedLifetime.Lifetime"/>'s flag, gets <c>True</c> when termination has just started.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.SynchronizedLifetime.Lifetime">
            <summary>
              <para>Gets the lifetime whose termination is synchronized by this object.</para>
              <para>It's not safe to call lifetime's scheduling methods unless you're running within some of the <c>Execute*</c> functions.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.TerminationThreadAffinity.Same">
            <summary>
            The outer (unsynchronized) lifetime must be terminated on the same thread as the object has been created.
            Use with component containers.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.TerminationThreadAffinity.Free">
            <summary>
            A fully free-threaded scenario, termination allowed on any thread.
            Note that in this case you MUST make sure the lifetime is not terminated while this object is still being created.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.MonitorReleaseCookie">
            <summary>
            Release monitor (must acquired previosly either with <see cref="M:System.Threading.Monitor.Enter(System.Object)"/> or <code>lock</code> statement) and then reacquires it in Dispose method.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ThreadManager.WaitingThreadsCookie">
            <summary>
            To envelop custom wait events
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Threading.ThreadManager.AllowStaExecutor(JetBrains.DataFlow.Lifetime)">
            <summary>
            This is to make sure no dispatchers are left behind and prevent appdomain from unloading.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="M:JetBrains.Threading.ThreadManager.RunSafe(System.Action)">
            <summary>
            Runs action on system thread pool (even in Tests) with guaranteed exception logging. 
            
            Use it for :
            1) IO-bound tasks if you can't rewrite them in async way (via TaskCompletionSource)
            2) You can't get access to IThreading.TaskHost.RunSafe method (e.g. in static methods)
            3) When you need guaranteed execution in async manner with no checks of lifetimes.
            </summary>
            <param name="action">action to run on System Pool Thread</param>
        </member>
        <member name="T:JetBrains.Util.DataStructures.UncheckedPackedIntArray">
            <summary>
            Presents <c>uint[]</c> (this) packed into another <c>uint[]</c> (myData). <c>valueBits</c> parameter for each method denotes size in bits of one element of 'this'
            Can be much or less than '32' bits, which is the size of myData element. No range checks are performed.
            
            To take <c>i</c>-th element of 'this', invoke <c>GetItem(i, valueBits, 0)</c>. You can also use <c>this[ith]</c> to get/set values with array of one element (in case
            of <c>valueBits</c> less than '32'.
            
            One can increase or reduce size of elem by invocation of <c>IncreaseValueBits(UncheckedPackedIntArray oldArray, int length, int oldValueBits, int newValueBits)</c>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.UncheckedPackedIntArray.GetItem(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates this[iSubItem]
            </summary>
        </member>
        <member name="T:JetBrains.Util.WeakCollection`1">
            <summary>
            Represents collection of items that doesn't strongly hold items
            </summary>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.Add(`0)">
            <summary>
            Adds an weak reference to item to the <see cref="T:JetBrains.Util.WeakCollection`1"></see>.
            </summary>
            <param name="item">The object to add to the <see cref="T:JetBrains.Util.WeakCollection`1"></see>.</param>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:JetBrains.Util.WeakCollection`1"></see>.
            </summary>
            <returns>
            true if item was successfully removed from the <see cref="T:JetBrains.Util.WeakCollection`1"></see>; otherwise, false. This method also returns false if item is not found in the original <see cref="T:JetBrains.Util.WeakCollection`1"></see>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:JetBrains.Util.WeakCollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:JetBrains.Util.WeakCollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:JetBrains.Util.WeakCollection`1"></see> contains a specific value.
            </summary>
            <returns>
            true if item is found in the <see cref="T:JetBrains.Util.WeakCollection`1"></see>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:JetBrains.Util.WeakCollection`1"></see>.</param>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.First">
            <summary>
            Returns the first live element from collection
            </summary>
            <returns>The first live element from collection</returns>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.First(System.Func{`0,System.Boolean})">
            <summary>
            Returns the first live element from collection that satisfies a specified condition
            </summary>
            <returns>The first live element from collection that satisfies a specified condition</returns>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.Last">
            <summary>
            Returns the last live element from collection
            </summary>
            <returns>The last live element from collection</returns>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.Last(System.Func{`0,System.Boolean})">
            <summary>
            Returns the last live element from collection that satisfies a specified condition
            </summary>
            <returns>The last live element from collection that satisfies a specified condition</returns>
        </member>
        <member name="M:JetBrains.Util.WeakCollection`1.Sweep">
            <summary>
            Removes garbage from the list
            </summary>
        </member>
        <member name="P:JetBrains.Util.WeakCollection`1.Capacity">
            <summary>
            Gets the approximate number of elements contained in the <see cref="T:JetBrains.Util.WeakCollection`1"></see>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.JetWeakReference`1">
            <summary>
            Represents a typed weak reference which can be compared by target
            </summary>
        </member>
        <member name="T:JetBrains.UI.IGraphicsContainer">
            <summary>
            An interface for a class that contains a device context.
            </summary>
        </member>
        <member name="P:JetBrains.UI.IGraphicsContainer.Graphics">
            <summary>
            Gets the device context.
            </summary>
        </member>
        <member name="T:JetBrains.UI.GraphicsContainer">
            <summary>
            The auto-container for a <see cref="T:System.Drawing.Graphics"/> device context that has several choices for where to create the graphics from.
            </summary>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromControl(System.Windows.Forms.Control)">
            <summary>
            If the control already exists with its handle, uses its DC, otherwise, a screen DC.
            </summary>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromGetDc(System.Void*)">
            <summary>
            Creates a generic device context from a window handle (<see cref="M:JetBrains.Interop.WinApi.User32Dll.GetDC(System.Void*)"/>).
            </summary>
            <param name="hwnd">The handle of the window to paint into.</param>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromGraphics(System.Drawing.Graphics)">
            <summary>
            Creates a generic device context from Graphics
            </summary>
            <param name="g">The DC to use if non-<c>Null</c>. May be <c>Null</c>.</param>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromGraphicsOrControl(System.Drawing.Graphics,System.Windows.Forms.Control)">
            <summary>
            If <paramref name="g"/> is non-<c>Null</c>, just uses it.
            Otherwise, works like <see cref="M:JetBrains.UI.GraphicsContainer.FromControl(System.Windows.Forms.Control)"/> over <paramref name="control"/>.
            </summary>
            <param name="g">The DC to use if non-<c>Null</c>. May be <c>Null</c>.</param>
            <param name="control">The control to use for fallback, must not be <c>Null</c>.</param>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromNothing">
            <summary>
            Creates a hollow container that ensures noone ever uses its <see cref="T:System.Drawing.Graphics"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromPainting(System.Windows.Forms.Control)">
            <summary>
            Creates a special painting device context from a control.
            Must be used within <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_PAINT"/> only.
            </summary>
            <param name="control">The control to paint into. Must exist.</param>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromPainting(System.IntPtr)">
            <summary>
            Creates a special painting device context from a window handle.
            Must be used within <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_PAINT"/> only.
            </summary>
            <param name="hwnd">The handle of the window to paint into.</param>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.FromScreen">
            <summary>
            Creates a screen device context.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.UI.GraphicsContainer.SetHighQuality(System.Drawing.Graphics)">
            <summary>
            Sets up the <see cref="T:System.Drawing.Graphics">graphics context</see> for high-quality rendering regardless of the screen settings.
            </summary>
        </member>
        <member name="T:JetBrains.UI.EmptyGraphicsContainer">
            <summary>
            A stub for non Windows Os.
            </summary>
        </member>
        <member name="T:JetBrains.UI.ScreenGraphics">
            <summary>
            A must-dispose class for creating a GDI+ graphics object associated with the screen device context.
            </summary>
        </member>
        <member name="M:JetBrains.UI.ScreenGraphics.#ctor">
            <summary>
            Initializes the object by attaching to the screen's device context.
            </summary>
        </member>
        <member name="M:JetBrains.UI.ScreenGraphics.#ctor(System.Windows.Forms.Control)">
            <summary>
            Attempts to create a graphics upon the control. If the control handle is not yet available, or the control has already been disposed, uses the screen device context.
            </summary>
        </member>
        <member name="M:JetBrains.UI.ScreenGraphics.op_Implicit(JetBrains.UI.ScreenGraphics)~System.Drawing.Graphics">
            <summary>
            Same as <see cref="P:JetBrains.UI.ScreenGraphics.Graphics"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.ScreenGraphics.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.ScreenGraphics.Graphics">
            <summary>
            Gets the <see cref="P:JetBrains.UI.ScreenGraphics.Graphics"/> object. Don't dispose, dispose the whole <see cref="T:JetBrains.UI.ScreenGraphics"/> instance instead.
            </summary>
        </member>
        <member name="T:JetBrains.UI.PaintGraphicsContainer">
            <summary>
            A must-dispose class for creating a GDI+ graphics object for painting a window in response to WM_PAINT.
            </summary>
        </member>
        <member name="M:JetBrains.UI.PaintGraphicsContainer.#ctor(System.Void*)">
            <summary>
            Creates a painting graphics object against some window.
            </summary>
            <param name="hwnd">Handle to the window we're currently painting.</param>
        </member>
        <member name="M:JetBrains.UI.PaintGraphicsContainer.op_Implicit(JetBrains.UI.PaintGraphicsContainer)~System.Drawing.Graphics">
            <summary>
            Same as <see cref="P:JetBrains.UI.PaintGraphicsContainer.Graphics"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.PaintGraphicsContainer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.PaintGraphicsContainer.Graphics">
            <summary>
            Gets the <see cref="P:JetBrains.UI.PaintGraphicsContainer.Graphics"/> object. Don't dispose, dispose the whole <see cref="T:JetBrains.UI.PaintGraphicsContainer"/> instance instead.
            </summary>
        </member>
        <member name="F:JetBrains.UI.ControlGraphicsContainer.myControl">
            <summary>
            The control to create the DC from. <c>Null</c> after dispose.
            </summary>
        </member>
        <member name="F:JetBrains.UI.ControlGraphicsContainer.myGraphics">
            <summary>
            The DC lazily-created from the control, or <c>Null</c> if not created yet.
            Should be disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.UI.ControlGraphicsContainer.#ctor(System.Windows.Forms.Control)">
            <summary>
            Creates an instance over the control.
            The graphics is not created until retrieved from the property for the first time.
            </summary>
            <param name="control">A non-<c>Null</c> control that must exist with its handle.</param>
        </member>
        <member name="M:JetBrains.UI.ControlGraphicsContainer.IsGoodControl(System.Windows.Forms.Control)">
            <summary>
            Checks whether it will work on the given control.
            </summary>
        </member>
        <member name="M:JetBrains.UI.ControlGraphicsContainer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.ControlGraphicsContainer.Graphics">
            <summary>
            Gets the device context.
            </summary>
        </member>
        <member name="T:JetBrains.UI.SimpleGraphicsContainer">
            <summary>
            Just holds the given DC, won't dispose of it.
            </summary>
        </member>
        <member name="M:JetBrains.UI.SimpleGraphicsContainer.#ctor(System.Drawing.Graphics)">
            <summary>
            Attaches to the given DC.
            </summary>
        </member>
        <member name="M:JetBrains.UI.SimpleGraphicsContainer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.SimpleGraphicsContainer.Graphics">
            <summary>
            Gets the device context.
            </summary>
        </member>
        <member name="T:JetBrains.UI.GetDcGraphicsContainer">
            <summary>
            Performs <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetDC(System.Void*)"/> on the given <c>HWND</c> and releases it at the end.
            </summary>
        </member>
        <member name="F:JetBrains.UI.GetDcGraphicsContainer.myGraphics">
            <summary>
            Lazy-init data.
            </summary>
        </member>
        <member name="F:JetBrains.UI.GetDcGraphicsContainer.myHdc">
            <summary>
            <c>HDC</c>, after one is lazy-created and before it is disposed of.
            </summary>
        </member>
        <member name="F:JetBrains.UI.GetDcGraphicsContainer.myHwnd">
            <summary>
            <c>HWND</c>, after the ctor and until the <c>HDC</c> is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.UI.GetDcGraphicsContainer.#ctor(System.Void*)">
            <summary>
            Creates a new container.
            The <c>HDC</c> is not created immediately; instead, it's constructed on the first <see cref="P:JetBrains.UI.GetDcGraphicsContainer.Graphics"/> use.
            </summary>
            <param name="hwnd">Handle to the window to which the device context should be created.</param>
        </member>
        <member name="M:JetBrains.UI.GetDcGraphicsContainer.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.GetDcGraphicsContainer.Graphics">
            <summary>
            Gets the device context.
            </summary>
        </member>
        <member name="T:JetBrains.UI.HollowGraphicsContainer">
            <summary>
            An intentionally hollow graphics container that can be passed as a normal one, but will throw if someone actually tries to extract <see cref="P:JetBrains.UI.IGraphicsContainer.Graphics"/> out of it.
            Can be used if you expect the callee to not use the parameter, but must pass it against the API.
            </summary>
        </member>
        <member name="M:JetBrains.UI.HollowGraphicsContainer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.HollowGraphicsContainer.Graphics">
            <summary>
            Gets the device context.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Helpers">
            <summary>
            Contains several interop helper functions
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.BitBlt(System.Void*,System.Drawing.Bitmap,System.Drawing.Point,System.Void*,System.Byte,System.Drawing.Rectangle[])">
            <summary>
            Blits a bitmap onto a GDI device context.
            </summary>
            <param name="hdcDestination">The target HDC.</param>
            <param name="bitmapSource">The bitmap to blit (the complete bitmap blits to the target).</param>
            <param name="ptDestinationLocation">Blit location coordinates on the target DC.</param>
            <param name="hdcIntermediate">A device context to be used as blitting source, pass a compatible HDC if you have one, or <c>Null</c> if it should be on-time-created.</param>
            <param name="nOpacity">Opacity vaue for blitting, 0x00 is completely transparent, 0xFF is opaque.</param>
            <param name="rectsSource">A collection of the rectangles to blit on the source bitmap. The relative location of these rectangles on the target DC corresponds to their source location. <c>Null</c> to blit the whole bitmap.</param>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.CanGlassify(System.IntPtr)">
            <summary>
            Performs all the checks of the <see cref="!:JetBrains.UI.Avalon.Helpers.Glassify(IntPtr,bool)"/> function, but does not actually apply the effect.
            Allows to tell with a high probability whether the <see cref="!:JetBrains.UI.Avalon.Helpers.Glassify(IntPtr,bool)"/> function will succeed.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.CreateBitmap(System.Int32[0:,0:])">
            <summary>
            Sets all the pixels in the bitmap to the given values.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.FlattenAlpha(System.Drawing.Image,System.Byte)">
            <summary>
            Flattens the alpha of the given bitmap using a threshold so that it becomes either 0x00 or 0xFF.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.GetWindowExStyle(System.IntPtr)">
            <summary>
            Gets the extended style of the specified window.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.GetWindowStyle(System.IntPtr)">
            <summary>
            Gets the style of the specified window.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.PaintWindowToBitmap(System.Windows.Forms.IWin32Window)">
            <summary>
            Paints an arbitrary window to a bitmap.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.RenderBuffered(JetBrains.UI.IGraphicsContainer,System.Drawing.Rectangle,System.Action{System.Drawing.Graphics},System.Boolean)">
            <summary>
            Renders to the given device context using an intermediate GDI backbuffer, which works around the ErrorStripeDisease™.
            Under terminal services, no backbuffer is used, just <paramref name="paint"/> is invoked.
            </summary>
            <param name="gc">The graphics device context container (must be disposed of by the caller, not before this method is called).</param>
            <param name="bounds">Size and location of the painting area in the device context coordinates. When painting, you should use the same coordinates as those in which the bounds are specified, don't use bounds-local coords.</param>
            <param name="paint">The function that would handle the rendering.</param>
            <param name="bSupportAlphaChannel">Whether the blitting of the back-buffer to the screen should support per-pixel alpha, or not. Note that when you turn this on, you must erase the whole area, and GDI text rendering will most likely fail to function properly.</param>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.RenderBuffered(System.Drawing.Graphics,System.Drawing.Rectangle,System.Action{System.Drawing.Graphics},System.Boolean)">
            <summary>
            Renders to the given device context using an intermediate GDI backbuffer, which works around the ErrorStripeDisease™.
            Under terminal services, no backbuffer is used, just <paramref name="FPaint"/> is invoked.
            </summary>
            <param name="g">The graphics device context.</param>
            <param name="bounds">Size and location of the painting area in the device context coordinates. When painting, you should use the same coordinates as those in which the bounds are specified, don't use bounds-local coords.</param>
            <param name="FPaint">The function that would handle the rendering.</param>
            <param name="bSupportAlphaChannel">Whether the blitting of the back-buffer to the screen should support per-pixel alpha, or not. Note that when you turn this on, you must erase the whole area, and GDI text rendering will most likely fail to function properly.</param>
        </member>
        <member name="M:JetBrains.UI.Interop.Helpers.ShowLayered(System.IntPtr,System.Drawing.Rectangle,System.Action{System.Drawing.Graphics})">
            <summary>
            Updates a layered window by displaying the given alpha-channel-aware bitmap at the specified location.
            The bitmap then persists until the window is killed or hidden, or another bitmap is displayed.
            </summary>
            <param name="hwnd">Handle to the window being updated.</param>
            <param name="area">The window area, in screen coordinates.</param>
            <param name="funcRender">The callback to perform the rendering.</param>
        </member>
        <member name="T:JetBrains.UI.RenderParams">
            <summary>
            Specifies rendering context for the <see cref="N:JetBrains.UI.RichText"/> and presentable item rederers.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RenderParams.myDefaultFont">
            <summary>
            <see cref="P:JetBrains.UI.RenderParams.DefaultFont"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RenderParams.myReadonly">
            <summary>
            <see cref="P:JetBrains.UI.RenderParams.Readonly"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RenderParams.myEmpty">
            <summary>
            <see cref="P:JetBrains.UI.RenderParams.Empty"/>, lazy-init.
            Let the defaults apply to all the static fields before we create an instance, so lazy-init on first use
            </summary>
        </member>
        <member name="F:JetBrains.UI.RenderParams.myDefaultTextRenderingMethod">
            <summary>
            <see cref="P:JetBrains.UI.RenderParams.DefaultTextRenderingMethod"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RenderParams.#ctor">
            <summary>
            Creates an empty instance initialized with the default values.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RenderParams.DumpToXaml(System.Xml.XmlWriter)">
            <summary>
            Dumps the object state in the XAML format.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RenderParams.ResetColors">
            <summary>
            Sets all the colors to be <see cref="F:System.Drawing.Color.Empty"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RenderParams.SetReadonly">
            <summary>
            Seals the instance by setting it into the read-only mode, see <see cref="P:JetBrains.UI.RenderParams.Readonly"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RenderParams.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Font">
            <summary>
            Gets or sets the font in which the text will be rendered.
            By default, specifies the <see cref="P:JetBrains.UI.RenderParams.DefaultFont"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.FontStyle">
            <summary>
            Gets or sets the font style for rendering the text.
            Overrides the local value unless <see cref="F:System.Drawing.FontStyle.Regular"/> is specified, in which case all the strings are rendered with their local font styles.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.NeutralForegroundColor">
            <summary>
            Gets or sets the  neutral foreground color setting. Does not override local colors, applies only to those strings whose color is set to <see cref="F:System.Drawing.Color.Empty"/>.
            May be <see cref="F:System.Drawing.Color.Empty"/>, in which case the renderer will choose the default color, most likely, <see cref="P:System.Drawing.SystemColors.ControlText"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.NeutralBackgroundColor">
            <summary>
            Gets or sets the neutral background color setting. Does not override local colors, applies only to those strings whose color is set to <see cref="F:System.Drawing.Color.Empty"/>.
            May be <see cref="F:System.Drawing.Color.Empty"/>, in which case the renderer will choose the default color, most likely, <see cref="P:System.Drawing.Color.Transparent"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.ExpectedBackgroundColorHint">
            <summary>
            <para>Gets or sets the hint for the expected background color under the transparently rendered rich text string.</para>
            <para>Unlike <see cref="P:JetBrains.UI.RenderParams.NeutralBackgroundColor"/> and <see cref="P:JetBrains.UI.RenderParams.OverrideBackgroundColor"/>, this color does not paint on screen as the opaque background under rich text. This is a hint for the engine which makes sure the foreground color is visible over the background color. When <see cref="P:JetBrains.UI.RenderParams.NeutralBackgroundColor"/> and <see cref="P:JetBrains.UI.RenderParams.OverrideBackgroundColor"/> are explicitly defined, they allow to adjust the foreground color as needed to be distinct. They don't apply when text has to be rendered over a transparent background (e.g. over a gradient or some image). If you know the approximate color of the background (e.g. gradient mid-color) and want the foreground color to be forced readable, but cannot set the text background to a flat value — assign the approximage color as the expected background color hint.</para>
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.ExpectedBackgroundColorHintMode">
            <summary>
            Gets or sets how to treat the hint for the expected background color
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Trimming">
            <summary>
            Gets or sets the string trimming to be used when rendering the string.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Mnemonics">
            <summary>
            Gets or sets the mnemonic treatment (ampersand characters) to be used when rendering the string.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Padding">
            <summary>
            Some queer stuff which misteriously appeared in this class in the years of its existence.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.OverrideForegroundColor">
            <summary>
            Gets or sets the color that overrides the local foreground color of all the strings, unless set to <see cref="F:System.Drawing.Color.Empty"/>.
            Takes precedence over <see cref="P:JetBrains.UI.RenderParams.NeutralForegroundColor"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.OverrideBackgroundColor">
            <summary>
            Gets or sets the color that overrides the local background color of all the strings, unless set to <see cref="F:System.Drawing.Color.Empty"/>.
            Takes precedence over <see cref="P:JetBrains.UI.RenderParams.NeutralBackgroundColor"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Effect">
            <summary>
            Gets or sets the effect style that overrides the local settings of the strings, unless set to <see cref="F:JetBrains.UI.RichText.TextStyle.EffectStyle.None"/>, in which case the local on the strings settings are used.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.EffectColor">
            <summary>
            Gets or sets the effect color that overrides the local setting on the strings, unless set to <see cref="F:System.Drawing.Color.Empty"/>.
            Works independently of <see cref="P:JetBrains.UI.RenderParams.Effect"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.TextRenderingMethod">
            <summary>
            Gets or sets a flag that defines the rendering engine to be used by text renderers.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Empty">
            <summary>
            Gets the empty rendering parameters that do not override anything and supply the default UI font.
            This instance is read-only and cannot be modified.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.DefaultFont">
            <summary>
            Gets the default UI font, a single instance shared by default between all the instances of <see cref="T:JetBrains.UI.RenderParams"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.DefaultTextRenderingMethod">
            <summary>
            Gets the default text rendering method.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RenderParams.Readonly">
            <summary>
            Gets whether the instance is readonly and its fields cannot be changed.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.FontCache">
            <summary>
            Cache for fonts.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.FontCache.GetHFont(System.Drawing.Font)">
            <summary>
            Gets a cached GDI handle to a font.
            The returned value should not be disposed of.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichString">
            <summary>
            Represents a formatted string that is a part of <see cref="P:JetBrains.UI.RichText.RichString.RichText"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.WaveLength">
            <summary>
            Wave length for weavy underlining.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.FontCache">
            <summary>
            Caches the fonts per-font-face and per-text-style.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.AugmentGdiPlusContext">
            <summary>
            Allows to fix the text-rendering-hint, but ruins ClearType … So, just a queer mode, after all.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.myOffset">
            <summary>
            Starting offset of the corresponding string part.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.myLength">
            <summary>
            Length of the corresponding string part.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.myRichText">
            <summary>
            The text which the part is belonging to.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.#ctor(System.Int32,System.Int32,JetBrains.UI.RichText.TextStyle,JetBrains.UI.RichText.RichText)">
            <summary>
            Creates a new <see cref="T:JetBrains.UI.RichText.RichString"/> instance.
            </summary>
            <param name="offset">String part offset.</param>    
            <param name="length">String part length.</param>
            <param name="style">The style.</param>
            <param name="richtext">The parent richtext block.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="richtext"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The range specified by <paramref name="offset"/> and <paramref name="length"/> does not fall within the parent <paramref name="richtext"/> string.</exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.GetSize(System.Drawing.Graphics,JetBrains.UI.RenderParams)">
            <summary>
            Gets size of the string in the given graphics
            </summary>
            <param name="g">The device context to calculate size in.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <returns>Size of the string when drawn in a given graphics.</returns>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.GetIndexFromPoint(System.Drawing.Graphics,JetBrains.UI.RenderParams,System.Int32)">
            <summary>
            Gets the local index of the character at the given point, or <c>-1</c> if none hit.
            </summary>
            <param name="g">The device context for measuring the chars.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <param name="x">X-coordinate of the point relative to the substring start.</param>
            <returns>Local zero-based index of the character at the given point, or <c>-1</c> if no character is hit.</returns>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.Measure(System.Drawing.Graphics,System.String,System.Drawing.SizeF,JetBrains.UI.RenderParams,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Measures the string rendering size under the given conditions.
            Does not augment the Graphics context for better fitting of the text, so the results most probably won't agree to the <see cref="M:JetBrains.UI.RichText.RichString.GetSize(System.Drawing.Graphics,JetBrains.UI.RenderParams)"/>'s ones.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.Draw(System.Drawing.Graphics,System.Drawing.Rectangle,JetBrains.UI.RenderParams)">
            <summary>
            Draws the formatted string on a given graphics.
            </summary>
            <param name="g">The GDI+ device context to draw the string in.</param>
            <param name="rectClip">Clipping rectangle to paint the text within.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.GetParameterizedFormat_Gdi(JetBrains.UI.RenderParams)">
            <summary>
            Produces a <see cref="T:System.Windows.Forms.TextFormatFlags"/> flag combination filled in a way standard for JetRichText rendering.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.GetParameterizedFormat_GdiPlus(JetBrains.UI.RenderParams)">
            <summary>
            Produces a <see cref="T:System.Drawing.StringFormat"/> structure filled in a way standard for JetRichText rendering.
            You must not alter the instance returned.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.GetParametrizedFont(JetBrains.UI.RenderParams,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Returns a parametrized font from the cache. 
            The returned value should not be disposed of.
            </summary>
            <param name="renderParams">Defines the rendering aspects.</param>
            <param name="localStyle">The local style to be overridden by the styles from <paramref name="renderParams"/>.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.OverrideTextStyle(JetBrains.UI.RenderParams,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Overrides the local text style with those properties of the <paramref name="renderParams"/>' text style that are set to override.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.OverrideFontStyle(JetBrains.UI.RenderParams,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Overrides the local font style with settings from the rendering aspect.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.AssertValid">
            <summary>
            Checks whether the rich text substring settings are valid against the parent rich text object.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.Dump(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.UnderlineStraight(System.Drawing.Graphics,System.Drawing.RectangleF,System.Drawing.Color)">
            <summary>
            Underlines text with text style color using straight line.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.UnderlineWeavy(System.Drawing.Graphics,System.Drawing.RectangleF,System.Drawing.Color)">
            <summary>
            Underlines text with text style color using weavy line.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.StrikeOut(System.Drawing.Graphics,System.Drawing.RectangleF,System.Drawing.Color)">
            <summary>
            Strikes out text with text style color using weavy line.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.RichText.RichString.Text">
            <summary>
            Gets the text of this part.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichString.Style">
            <summary>
            Gets or sets the string style
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichString.Offset">
            <summary>
            Gets or sets the starting offset.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichString.Length">
            <summary>
            Gets or sets the length.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichString.RichText">
            <summary>
            Gets the parent text.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichString.AugmentGraphics">
            <summary>
            Augments the <see cref="T:System.Drawing.Graphics"/> device context, as required for the GDI+ rendering of the text.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.AugmentGraphics.#ctor(System.Drawing.Graphics,JetBrains.UI.RenderParams)">
            <summary>
            Inits the instance and does the augmenting.
            </summary>
            <param name="graphics">The graphics to augment in ctor and de-augment in <see cref="M:JetBrains.UI.RichText.RichString.AugmentGraphics.Dispose"/>.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.AugmentGraphics.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.UI.RichText.RichString.AugmentGraphics.Augment">
            <summary>
            Does the thing.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichString.FormatFlags">
            <summary>
            Formatting flags that deifne the text rendering style.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.FormatFlags.None">
            <summary>
            No flags set.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.FormatFlags.EndEllipsis">
            <summary>
            Render the ellipsis character when the string gets truncated.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.FormatFlags.ShowMnemonics">
            <summary>
            Render the mnemonic by underlining the next character after the “&amp;” char.
            If not set, the ampersands are rendered “as is”.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichString.FormatFlags.Mask">
            <summary>
            All the flags.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichText">
            <summary>
            Represents a formatted text block (i.e., actually, sequence of <see cref="T:JetBrains.UI.RichText.RichString"/> instances).
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.OptionTrace">
            <summary>
            Verbose trace.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.ourPaintCounter">
            <summary>
            Verbose trace counter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.myParts">
            <summary>
            Formatting for the text parts. Must not be <c>Null</c>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.mySize">
            <summary>
            The cached size value.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.mySizeIsValid">
            <summary>
            Whether the cached size value can be trusted.
            Must be used in conjunction with <see cref="F:JetBrains.UI.RichText.RichText.mySizeParametersHash"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.mySizeParametersHash">
            <summary>
            A hash for the <see cref="T:JetBrains.UI.RenderParams"/> for which the <see cref="F:JetBrains.UI.RichText.RichText.mySize"/> is valid.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichText.myString">
            <summary>
            Plain text of the rich text. Must not be <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.#ctor(System.String,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Creates a new rich text string.
            </summary>
            <param name="text">Text content.</param>
            <param name="style">The style to apply to the plain text.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.#ctor(System.String)">
            <summary>
            Creates a new rich text string.
            Does not apply any <see cref="T:JetBrains.UI.RichText.TextStyle"/> formatting to the plain text, uses the <see cref="P:JetBrains.UI.RichText.TextStyle.Default"/> value.
            </summary>
            <param name="text">Text content.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.#ctor">
            <summary>
            Creates a new empty non-styled rich text string.
            Same as <see cref="P:JetBrains.UI.RichText.RichText.Empty"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.#ctor(System.String,System.Collections.Generic.ICollection{JetBrains.UI.RichText.RichString})">
            <summary>
            The internal cloning ctor.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.IsNullOrEmpty(JetBrains.UI.RichText.RichText)">
            <summary>
            Checks whether the given rich text instance is null or represents an empty string.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Append(System.String,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Appends a part with a custom style to the text.
            </summary>
            <param name="s">The part to add.</param>
            <param name="style">The style of the part to add.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Append(System.String)">
            <summary>
            Appends a string to the text.
            Uses the style of the trailing character.
            </summary>
            <param name="s">The part to add.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Append(JetBrains.UI.RichText.RichText)">
            <summary>
            Appends some rich text to the current one.
            </summary>
            <param name="richText">The rich text to append.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.AssertValid">
            <summary>
            Performs consistency checks over the rich text.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Clear">
            <summary>
            Clears the rich text string.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Draw(System.Drawing.Graphics,System.Drawing.Rectangle,JetBrains.UI.RenderParams)">
            <summary>
            Draws the formatted string on a given graphics.
            </summary>
            <param name="g">The GDI+ device context to draw the string into.</param>
            <param name="bounds">The rectangle where the string is drawn.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="g"/> is <c>Null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="renderParams"/> is <c>Null</c>.</exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.DumpToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.DumpToXaml(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.GetFormattedParts">
            <summary>
            Gets a readonly collection of the <see cref="T:JetBrains.UI.RichText.RichText"/> formatting elements.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.GetIndexFromPoint(System.Drawing.Graphics,JetBrains.UI.RenderParams,System.Int32)">
            <summary>
            Gets the index of a character with the given local x-coordinate, or <c>-1</c> if none.
            </summary>
            <param name="g">The GDI+ device context to draw the string into.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <param name="x">The richtext-local x-coordinate to lookup the character by.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.GetIndexFromPoint(System.Drawing.Graphics,JetBrains.UI.RenderParams,System.Drawing.Point)">
            <summary>
            Gets the index of a character with the given local x-coordinate, or <c>-1</c> if none.
            The y-coordinate is checked for hitting the richtext-global bounding rect only.
            </summary>
            <param name="g">The GDI+ device context to draw the string into.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <param name="point">The richtext-local coordinates to lookup the character by.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.GetSize(System.Drawing.Graphics,JetBrains.UI.RenderParams)">
            <summary>
            Calculates the rich text bounding rectangle against the given device context.
            Caches the previously-calculated value.
            </summary>
            <param name="g">The GDI+ device context to draw the string into.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="g"/> is <c>Null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="renderParams"/> is <c>Null</c>.</exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.GetSizeF(System.Drawing.Graphics,JetBrains.UI.RenderParams)">
            <summary>
            Calculates the rich text bounding rectangle against the given device context.
            Caches the previously-calculated value.
            </summary>
            <param name="g">The GDI+ device context to draw the string into.</param>
            <param name="renderParams">Defines the rendering aspects.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="g"/> is <c>Null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="renderParams"/> is <c>Null</c>.</exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Prepend(System.String,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Prepends a part with a custom style to the text.
            </summary>
            <param name="s">The part to add.</param>
            <param name="style">The style of the part to add.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Prepend(System.String)">
            <summary>
            Prepends a string to the text.
            Uses the style of the leading character.
            </summary>
            <param name="s">The part to add.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Prepend(JetBrains.UI.RichText.RichText)">
            <summary>
            Appends one rich text to another
            </summary>
            <param name="richText">The rich text to append</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetBackColor(System.Drawing.Color,System.Int32,System.Int32)">
            <summary>
            Sets the new background color for the given range.
            Don't set background color to <see cref="P:System.Drawing.Color.Transparent"/> because it would prevent painters from providing the neutral color.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetBackColor(System.Drawing.Color)">
            <summary>
            Sets the new background color for the whole text.
            Don't set background color to <see cref="P:System.Drawing.Color.Transparent"/> because it would prevent painters from providing the neutral color.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetColors(System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Sets new colors for the whole text.
            Don't set background color to <see cref="P:System.Drawing.Color.Transparent"/> because it would prevent painters from providing the neutral color.
            </summary>
            <param name="foreColor">Foreground color to set.</param>
            <param name="backColor">Background color to set.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetColors(System.Drawing.Color,System.Drawing.Color,System.Int32,System.Int32)">
            <summary>
            Sets the new foreground and background colors for the given range.
            Don't set background color to <see cref="P:System.Drawing.Color.Transparent"/> because it would prevent painters from providing the neutral color.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetForeColor(System.Drawing.Color)">
            <summary>
            Sets the new foreground color for the whole text.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetForeColor(System.Drawing.Color,System.Int32,System.Int32)">
            <summary>
            Sets the new foreground color for the given range.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetStyle(JetBrains.UI.RichText.TextStyle,System.Int32,System.Int32)">
            <summary>
            Sets new style to a specified part of the text
            </summary>
            <param name="style">The style to set</param>
            <param name="startOffset">Start offset of the block</param>
            <param name="length">Block length</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startOffset</i> is invalid in current string</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>length</i> is invalid starting with specified <i>startOffset</i></exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetStyle(System.Drawing.FontStyle,System.Int32,System.Int32)">
            <summary>
            Sets new font style to a specified part of the text
            </summary>
            <param name="style">The font style to set</param>
            <param name="startOffset">Start offset of the block</param>
            <param name="length">Block length</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startOffset</i> is invalid in current string</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>length</i> is invalid starting with specified <i>startOffset</i></exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetStyle(JetBrains.UI.RichText.TextStyle)">
            <summary>
            Applies a new <see cref="T:JetBrains.UI.RichText.TextStyle"/> (font style and colors) to the whole rich text string.
            </summary>
            <param name="style">The style to apply.</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetStyle(JetBrains.UI.RichText.TextStyle.EffectStyle,System.Drawing.Color,System.Int32,System.Int32)">
            <summary>
            Sets new effect to a specified part of the text
            </summary>
            <param name="effect">The effect style to set</param>
            <param name="effectColor">The effect color to set</param>
            <param name="startOffset">Start offset of the block</param>
            <param name="length">Block length</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startOffset</i> is invalid in current string</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>length</i> is invalid starting with specified <i>startOffset</i></exception>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.SetStyle(JetBrains.UI.RichText.TextStyle.EffectStyle,System.Drawing.Color)">
            <summary>
            Sets new effect to a specified part of the text
            </summary>
            <param name="effect">The effect style to set</param>
            <param name="effectColor">The effect color to set</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Split(System.Int32)">
            <summary>
            Splits rich text before the specified offset so that the first part's length is equal to the <paramref name="offset"/>.
            </summary>
            <param name="offset">The offset to split the text at.</param>
            <returns>An array conssiting of the two resulting parts. The array length is always equal to <c>2</c>, even if either part is empty.</returns>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Trim(System.Char[])">
            <summary>
            Trims the leading and trailing characters from the rich text string.
            Warning: a constant function, would not modify the instance!
            </summary>
            <param name="trimChars">An array of Unicode characters to remove or <c>Null</c>. </param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.TrimEnd(System.Char[])">
            <summary>
            Trims the trailing characters from the rich text string.
            Warning: a constant function, would not modify the instance!
            </summary>
            <param name="trimChars">An array of Unicode characters to remove or <c>Null</c>. </param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.TrimStart(System.Char[])">
            <summary>
            Trims the leading characters from the rich text string.
            Warning: a constant function, would not modify the instance!
            </summary>
            <param name="trimChars">An array of Unicode characters to remove or <c>Null</c>. </param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.BreakString(JetBrains.UI.RichText.RichString,System.Int32,System.Boolean)">
            <summary>
            Breaks a part into two parts at the given local offset, which is relative to the part.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.Replace(System.Char,System.Char)">
            <summary>
            Replaces char a with b without formatting loose
            </summary>
            <param name="a">Char</param>
            <param name="b">Char</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.GetPartsFromRangeAndSplit(System.Int32,System.Int32)">
            <summary>
            Gets the lsit of parts that fall within the given range.
            The rich strings on the range boundaries are splitted, if needed.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.ToString(System.Boolean)">
            <summary>
            Gets plain string representation of rich text, plus string part marks.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichText.ToString">
            <summary>
            Gets plain string representation of rich text, plus string part marks.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichText.Empty">
            <summary>
            Gets an empty rich text string.
            Same as <see cref="M:JetBrains.UI.RichText.RichText.#ctor"/>
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichText.BackgroundColor">
            <summary>
            Returns common background color. If colors are different in different parts returns <see cref="F:System.Drawing.Color.Empty"/>
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichText.ForegroundColor">
            <summary>
            Returns common foreground color. If colors are different in different parts returns <see cref="F:System.Drawing.Color.Empty"/>
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichText.IsEmpty">
            <summary>
            Gets whether the string contained in this rich text is empty.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichText.Length">
            <summary>
            Gets total length of the text in characters.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichText.Text">
            <summary>
            Gets or sets the underlying text as an unformatted string.
            In the latter case the current RichText formatting is inherited.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichText.TextRangeDataRecord">
            <summary>
            Describes user data attached to a range within the text.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.TextRenderingMethod">
            <summary>
            Defines the possible rendering methods to be used when rendering text strings.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextRenderingMethod.GdiPlus">
            <summary>
            Use GDI+ rendering via the <see cref="T:System.Drawing.Graphics"/> class (.NET default).
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextRenderingMethod.Gdi">
            <summary>
            Use GDI rendering via the HDC device contexts and <see cref="!:User32Dll.DrawText"/> function calls.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichTextParameters">
            <summary>
            Contains parameters for a whole rich text block
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextParameters.#ctor">
            <summary>
            Creates new rich text parameters
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextParameters.#ctor(System.Drawing.Font)">
            <summary>
            Creates new rich text parameters
            </summary>
            <param name="font">Font to use</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextParameters.#ctor(System.Drawing.Font,JetBrains.UI.RichText.TextStyle)">
            <summary>
            Creates new rich text parameters
            </summary>
            <param name="font">Font to use</param>
            <param name="style">Default text style</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextParameters.#ctor(System.Drawing.Font,JetBrains.UI.RichText.TextStyle,System.Boolean)">
            <summary>
            Creates new rich text parameters
            </summary>
            <param name="font">Font to use</param>
            <param name="style">Default text style</param>
            <param name="drawEllipsis">Default draw ellipsis flag</param>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextParameters.Dump(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextParameters.DrawEllipsis">
            <summary>
            If to draw ellipsis if the text doesn't fit the given rectangle
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextParameters.Font">
            <summary>
            Gets or sets used font
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextParameters.Style">
            <summary>
            Gets or sets default text style
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichTextBlock">
            <summary>
            Represents a block (possibly multiline) of rich text.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichTextBlock.myLines">
            <summary>
            Lines of rich text block
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichTextBlock.myParameters">
            <summary>
            Rich text block parameters
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlock.DumpToXaml(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlock.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlock.Lines">
            <summary>
            Gets the rich text lines of the block.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlock.Parameters">
            <summary>
            Gets or sets the parameters.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlock.RichText">
            <summary>
            Gets or sets the rich text block as a whole rich text fragment.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlock.Text">
            <summary>
            Gets or sets the plaintext representation of the rich text block.
            The setter creates a number of unformatted rich text lines.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichTextBlockParameters">
            <summary>
            Structure for setting parameters for rich text blocks
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockParameters.DumpToXaml(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockParameters.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:JetBrains.UI.RichText.RichTextBlockPresenter.myDesiredSize">
            <summary>
            See <see cref="P:JetBrains.UI.RichText.RichTextBlockPresenter.DesiredSize"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.RichTextBlockPresenter.mySize">
            <summary>
            The current externally assigned size.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockPresenter.GetConstrainedSize(System.Drawing.Graphics,System.Drawing.Size)">
            <summary>
            Measures the content desired size against the given constraints.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockPresenter.SetContent(System.Drawing.Graphics,JetBrains.UI.RichText.RichTextBlock)">
            <summary>
            The parametersized setter for the <see cref="P:JetBrains.UI.RichText.RichTextBlockPresenter.Content"/> property.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockPresenter.SetSize(System.Drawing.Graphics,System.Drawing.Size)">
            <summary>
            The parametersized setter for the <see cref="P:JetBrains.UI.RichText.RichTextBlockPresenter.Size"/> property.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockPresenter.PerformLayout(System.Drawing.Graphics)">
            <summary>
            Reformats to accommodate for the current size.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlockPresenter.Content">
            <summary>
            Gets the multiline rich text content of the presenter.
            To set the content, use the parameterized <see cref="M:JetBrains.UI.RichText.RichTextBlockPresenter.SetContent(System.Drawing.Graphics,JetBrains.UI.RichText.RichTextBlock)"/> setter.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlockPresenter.DesiredSize">
            <summary>
            Gets the desired size as if there were no external limits.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlockPresenter.RenderParams">
            <summary>
            Gets or sets the rendering aspect of the presenter.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlockPresenter.Size">
            <summary>
            Gets the explicit forced size of the presenter.
            To set the size, use the parameterized <see cref="M:JetBrains.UI.RichText.RichTextBlockPresenter.SetSize(System.Drawing.Graphics,System.Drawing.Size)"/> setter.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.RichTextBlockPresenter.ReflowedContent">
            <summary>
            Gets the rich text block that is the result of reflowing the original <see cref="P:JetBrains.UI.RichText.RichTextBlockPresenter.Content"/> so that it fit the width of the given <see cref="P:JetBrains.UI.RichText.RichTextBlockPresenter.Size"/>.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.RichTextBlockFormatter">
            <summary>
            Reflows a rich text block 
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockFormatter.Format(JetBrains.UI.RichText.RichTextBlock,System.Int32,System.Drawing.Graphics,JetBrains.UI.RenderParams)">
            <summary>
            Reflows the set of <see cref="T:JetBrains.UI.RichText.RichText"/> strings so that they fit the width specified.
            The existing line breaks are kept, new ones are added as needed.
            </summary>
            <param name="block">The source lines of text.</param>
            <param name="width">The maximum width.</param>
            <param name="g">The device context for measuring the text against.</param>
            <param name="renderParams">The rendering aspect.</param>
            <returns>The formatted rich text with new line breaks.</returns>
        </member>
        <member name="M:JetBrains.UI.RichText.RichTextBlockFormatter.Format(JetBrains.UI.RichText.RichText,System.Int32,System.Drawing.Graphics,JetBrains.UI.RenderParams)">
            <summary>
            Reflows the single line of <see cref="T:JetBrains.UI.RichText.RichText"/> so that it fits the width specified.
            The line breaks are added as needed.
            </summary>
            <param name="text">The source line of text.</param>
            <param name="width">The maximum width.</param>
            <param name="g">The device context for measuring the text against.</param>
            <param name="renderParams">The rendering aspect.</param>
            <returns>The formatted rich text with new line breaks.</returns>
        </member>
        <member name="T:JetBrains.UI.RichText.TextStyle">
            <summary>
            Represents style of text block
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.myFontStyle">
            <summary>
            Font style
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.myForegroundColor">
            <summary>
            Foreground color
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.myBackgroundColor">
            <summary>
            Background color
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.myEffect">
            <summary>
            Effect to use
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.myEffectColor">
            <summary>
            Effect color
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.#ctor(System.Drawing.FontStyle,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Defines a text style.
            </summary>
            <remarks>
            This contructor defines style with no effects.
            </remarks>
            <param name="fontStyle">The font style to use</param>
            <param name="foregroundColor">Foreground color</param>
            <param name="backgroundColor">Background clor</param>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.#ctor(System.Drawing.FontStyle,System.Drawing.Color)">
            <summary>
            Defines a text style.
            </summary>
            <remarks>
            This contructor defines style with no effects.
            </remarks>
            <param name="fontStyle">The font style to use</param>
            <param name="foregroundColor">Foreground color</param>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.#ctor(System.Drawing.FontStyle,System.Drawing.Color,System.Drawing.Color,JetBrains.UI.RichText.TextStyle.EffectStyle,System.Drawing.Color)">
            <summary>
            Defines a text style.
            </summary>
            <param name="fontStyle">The font style to use</param>
            <param name="foregroundColor">Foreground color</param>
            <param name="backgroundColor">Background clor</param>
            <param name="effect">Effect to use</param>
            <param name="effectColor">Effect color to use</param>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.#ctor(System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Defines a text style.
            </summary>
            <remarks>
            This contructor defines style with no effects and regular style of the text.
            </remarks>
            <param name="foregroundColor">Foreground color</param>
            <param name="backgroundColor">Background clor</param>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.FromBackColor(System.Drawing.Color)">
            <summary>
            Creates a style that has only background color specified.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.FromForeColor(System.Drawing.Color)">
            <summary>
            Creates a style that has only foreground color specified.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.ourDefaultStyle">
            <summary>
            The default text style.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.ourHiddenStyle">
            <summary>
            The hidden text style.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.Dump(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="M:JetBrains.UI.RichText.TextStyle.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.FontStyle">
            <summary>
            Gets or sets font style
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.ForegroundColor">
            <summary>
            Gets or sets the foreground color.
            <see cref="F:System.Drawing.Color.Empty"/> means “Don't care, renderer should specify, if not, use <see cref="P:JetBrains.UI.RichText.TextStyle.DefaultForegroundColor"/>”.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.BackgroundColor">
            <summary>
            Gets or sets the background color.
            <see cref="F:System.Drawing.Color.Empty"/> means “Don't care, renderer should specify, if not, use <see cref="P:JetBrains.UI.RichText.TextStyle.DefaultBackgroundColor"/>”.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.Effect">
            <summary>
            Gets or sets used effect
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.EffectColor">
            <summary>
            Gets or sets the effect color.
            <see cref="F:System.Drawing.Color.Empty"/> means the <see cref="P:JetBrains.UI.RichText.TextStyle.DefaultEffectColor"/> will be used.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.Default">
            <summary>
            Gets the default text style.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.Hidden">
            <summary>
            Gets the hidden text style.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.DefaultForegroundColor">
            <summary>
            See <see cref="P:JetBrains.UI.RichText.TextStyle.ForegroundColor"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.DefaultBackgroundColor">
            <summary>
            See <see cref="P:JetBrains.UI.RichText.TextStyle.BackgroundColor"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.RichText.TextStyle.DefaultEffectColor">
            <summary>
            See <see cref="P:JetBrains.UI.RichText.TextStyle.EffectColor"/>.
            </summary>
        </member>
        <member name="T:JetBrains.UI.RichText.TextStyle.EffectStyle">
            <summary>
            Enumerates different text drawing effects
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.EffectStyle.None">
            <summary>
            No effects.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.EffectStyle.StraightUnderline">
            <summary>
            Underline with a straight line.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.EffectStyle.WeavyUnderline">
            <summary>
            Underline with a gay line.
            </summary>
        </member>
        <member name="F:JetBrains.UI.RichText.TextStyle.EffectStyle.StrikeOut">
            <summary>
            Strike out with a straight line.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.NativeEvent">
            <summary>
              This class just uses WaitForSingleObject directly to work around unwanted consequences of
              message pumping that may happen while doing WaitHandle.WaitOne. It is not intended to implement
              all the functionality that WaitHandle possess.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.WaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET
            </summary>
            <return>true if event was SET, false if timeout expired</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.MsgWaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET or new message is appeared in queue
            </summary>
            <return>true if event was SET, false if timeout expired, null if new message is appeared in queue</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.WaitOne">
            <summary>
              Waiting for event to be SET
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.MsgWaitOne">
            <summary>
              <return>true if event was SET, false if new message is appeared in queue</return>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.WaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET
            </summary>
            <return>true if event was SET, false if timeout expired</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.MsgWaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET or new message is appeared in queue
            </summary>
            <return>true if event was SET, false if timeout expired, null if new message is appeared in queue</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.WaitOne">
            <summary>
              Waiting for event to be SET
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.MsgWaitOne">
            <summary>
              <return>true if event was SET, false if new message is appeared in queue</return>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.NativeManualEvent">
            <summary>
              External API for events, named NativeManualEvent for compat. reasons
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.NativeAutoEvent">
            <summary>
              External API for events, named NativeAutoEvent for compat. reasons
            </summary>
        </member>
        <member name="M:JetBrains.Text.ArrayBuffer.AssertOffsetAndLength(System.Int32,System.Int32)">
            <summary>
            Assertion method to avoid creating closure objects when no exceptions are thrown
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:JetBrains.Util.BidirectionalMap`2">
            <summary>
            Mapping from one family of objects into another and vice versa.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BidirectionalMap`2.Add(`0,`1)">
            <summary>
            Adds a new mapping to the map. Both ends must be unique in their maps.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BidirectionalMap`2.SetMapping(`0,`1,System.Boolean)">
            <summary>
            Adds a new mapping to the map. You should use <see cref="M:JetBrains.Util.BidirectionalMap`2.Add(`0,`1)"/> whenever possible, as it throws on dpulicate keys.
            </summary>
            <param name="left">Left key.</param>
            <param name="right">Right key.</param>
            <param name="bIgnoreConflicts">Whether to ignore duplicate keys in left and right collections silently. Not recommended. The conflicting mappings will be dropped.</param>
        </member>
        <member name="P:JetBrains.Util.BidirectionalMap`2.Count">
            <summary>
            Get the number of mappings.
            As we implement the identity mapping, the number of items on both sides is always in sync.
            </summary>
        </member>
        <member name="T:JetBrains.Util.LocalHashSet`1">
            <summary>
            Lazily instantiates the hash set.
            Just FrugalLocalLazy{JetHashSet}.
            Use FrugalLocalHashSet for better GC optimisation.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.Char)">
            <summary>
            Reports the index of the first occurrence of the specified UTF-16LE character in result string.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.Char,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified UTF-16LE character in result string. The search starts at a specified character position.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or specifies a position beyond the end of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified character in this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> + <paramref name="startIndex"/> specifies a position beyond the end of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String)">
            <summary>
            Reports the index of the first occurrence of the specified <see cref="T:System.String"/> in this instance.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
            <param name="value">The <see cref="T:System.String"/> to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified <see cref="T:System.String"/> in this instance. The search starts at a specified character position.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative.-or- <paramref name="startIndex"/> specifies a position not within this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified <see cref="T:System.String"/> in this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> plus <paramref name="startIndex"/> specify a position not within this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in the current <see cref="T:System.String"/> object. A parameter specifies the type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in the current <see cref="T:System.String"/> object. Parameters specify the starting search position in the current string and the type of search to use for the specified string.
            </summary>
            
            <returns>
            The zero-based index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative, or specifies a position that is not within this instance. </exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in the current <see cref="T:System.String"/> object. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.
            </summary>
            
            <returns>
            The zero-based index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param><param name="startIndex">The search starting position. </param><param name="count">The number of character positions to examine. </param><param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param><exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> plus <paramref name="startIndex"/> specify a position that is not within this instance. </exception><exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOfAny(System.Char[])">
            <summary>
            Reports the index of the first occurrence in this instance of any character in a specified array of UTF-16LE characters.
            </summary>
            
            <returns>
            The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOfAny(System.Char[],System.Int32)">
            <summary>
            Reports the index of the first occurrence in this instance of any character in a specified array of UTF-16LE characters. The search starts at a specified character position.
            </summary>
            
            <returns>
            The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative.-or- <paramref name="startIndex"/> is greater than the number of characters in this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reports the index of the first occurrence in this instance of any character in a specified array of UTF-16LE characters. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> + <paramref name="startIndex"/> is greater than the number of characters in this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.Char)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.Char,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance. The search starts at a specified character position.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero or greater than the length of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of the specified UTF-16LE character in a substring within this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param>
            <param name="count">The number of character positions to examine. </param><exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero, or greater than or equal to the length of this instance.-or-<paramref name="startIndex"/> + 1 - <paramref name="count"/> is less than zero.</exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param><exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance. The search starts at a specified character position.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero or greater than the length of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of the specified UTF-16LE character in a substring within this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param><param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero, or greater than or equal to the length of this instance.-or-<paramref name="startIndex"/> + 1 - <paramref name="count"/> is less than zero.</exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.StringComparison)">
            <summary>
            Reports the index of the last occurrence of a specified string within the current <see cref="T:System.String"/> object. A parameter specifies the type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is the last index position in this instance.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the last occurrence of a specified string within the current <see cref="T:System.String"/> object. Parameters specify the starting search position in the current string, and type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero or specifies a position that is not within this instance. </exception><exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Reports the index position of the last occurrence of a specified <see cref="T:System.String"/> object within this instance. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="startIndex"/> is greater than the length of this instance.-or-<paramref name="startIndex"/> + 1 - <paramref name="count"/> specifies a position that is not within this instance. </exception><exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOfAny(System.Char[])">
            <summary>
            Reports the index position of the last occurrence in this instance of one or more characters specified in a UTF-16LE array.
            </summary>
            
            <returns>
            The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOfAny(System.Char[],System.Int32)">
            <summary>
            Reports the index position of the last occurrence in this instance of one or more characters specified in a UTF-16LE array. The search starts at a specified character position.
            </summary>
            
            <returns>
            The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> specifies a position not within this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reports the index position of the last occurrence in this instance of one or more characters specified in a UTF-16LE array. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; -1 if no character in <paramref name="anyOf"/> was found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/>, and <paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> minus <paramref name="count"/> specifies a position that is not within this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position.
            </summary>
            
            <returns>
            A <see cref="T:JetBrains.Util.StringSlice"/> object equivalent to the substring that begins at <paramref name="startIndex"/> in this instance, or <see cref="F:System.String.Empty"/> if <paramref name="startIndex"/> is equal to the length of this instance.
            </returns>
            <param name="startIndex">The zero-based starting character position of a substring in this instance. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or greater than the length of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Substring(System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.
            </summary>
            
            <returns>
            A <see cref="T:JetBrains.Util.StringSlice"/> equivalent to the substring of length <paramref name="length"/> that begins at <paramref name="startIndex"/> in this instance, or <see cref="F:System.String.Empty"/> if <paramref name="startIndex"/> is equal to the length of this instance and <paramref name="length"/> is zero.
            </returns>
            <param name="startIndex">The zero-based starting character position of a substring in this instance. </param>
            <param name="length">The number of characters in the substring. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> plus <paramref name="length"/> indicates a position not within this instance.-or- <paramref name="startIndex"/> or <paramref name="length"/> is less than zero. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Contains(System.String)">
            <summary>
            Returns a value indicating whether the specified <see cref="T:System.String"/> object occurs within this string.
            </summary>
            
            <returns>
            true if the <paramref name="value"/> parameter occurs within this string, or if <paramref name="value"/> is the empty string (""); otherwise, false.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param><exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split(System.Char[])">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array. 
            </summary>
            
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator"/>.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split2(System.Char[])">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split(System.Char[],System.StringSplitOptions)">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array. 
            Parameter specify whether to return empty array elements.
            </summary>
            
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator"/>.
            </returns>
            <param name="separator">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries"/> to omit empty array elements from the array returned, 
            or <see cref="F:System.StringSplitOptions.None"/> to include empty array elements in the array returned. </param>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split2(System.Char[],System.StringSplitOptions)">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            Parameter specify whether to return empty array elements.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.
            </returns>
            <param name="separator">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned,
            or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Equals(System.String)">
            <summary>
            Indicates whether the current substing is equal to another string.
            </summary>
            <param name="otherString">A string to compare with this substring.</param>
            <returns>
            true if the current string is equal to the <paramref name="otherString"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Equals(System.String,System.StringComparison)">
            <summary>
            Indicates whether the current substing is equal to another string.
            </summary>
            <param name="otherString">A string to compare with this substring.</param>
            <param name="comparisonRule">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>
            true if the current string is equal to the <paramref name="otherString"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.CompareTo(System.String)">
            <summary>
            Compares the current substing with string.
            </summary>
            <param name="otherString">An other string to compare with this substring.</param>
            <returns>
            A value that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            - Value Meaning Less than zero This object is less than the <paramref name="otherString"/> parameter;
            - Zero This object is equal to <paramref name="otherString"/>;
            - Greater than zero This object is greater than <paramref name="otherString"/>. 
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.CompareTo(System.String,System.StringComparison)">
            <summary>
            Compares the current substing with string.
            </summary>
            <param name="otherString">An other string to compare with this substring.</param>
            <param name="comparisonRule">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>
            A value that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            - Value Meaning Less than zero This object is less than the <paramref name="otherString"/> parameter;
            - Zero This object is equal to <paramref name="otherString"/>;
            - Greater than zero This object is greater than <paramref name="otherString"/>. 
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.ProcessString``2(``0,JetBrains.Util.StringSlice.ProcessStringDelegate{``0,``1})">
            <summary>
            Processes a string as a fixed pointer to the char array.
            This char array is NOT zero-terminated!! It MUST NOT be modified. It's a subrange of some other runtime string object.
            </summary>
            <typeparam name="TContext">A user-defined context which allows to use non-closure lambdas.</typeparam>
            <typeparam name="TResult">Processing result.</typeparam>
            <param name="context">A user-defined context which allows to use non-closure lambdas.</param>
            <param name="λ"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.StringSlice.Length">
            <summary>
            String length
            </summary>
        </member>
        <member name="P:JetBrains.Util.StringSlice.Item(System.Int32)">
            <summary>
            Char in result string
            </summary>
            <param name="i"> index in result string</param>
            <returns>Char at pos <see cref="!:i"/> in result string</returns>
        </member>
        <member name="T:JetBrains.Util.StringSlice.LowLevelAccess">
            <summary>
            Optimization methods without which you can semantically do, but which can speed up hot tracks in the code.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LowLevelAccess.IsWholeString(JetBrains.Util.StringSlice)">
            <summary>
            Gets whether this slice covers the whole underlying managed string object, so calling <see cref="M:JetBrains.Util.StringSlice.ToString"/> won't make an allocation.
            </summary>
            <param name="stringSlice"></param>
        </member>
        <member name="T:JetBrains.Util.Diff.DiffFragment">
            <summary>
            Single frame after diffing two entities
            </summary>
        </member>
        <member name="T:JetBrains.Util.Diff.DiffFragmentType">
            <summary>
            Type of the single diff frame
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray`1">
            <summary>
            Reuses the single instance of an empty array (one per type). If possible, prefer <see cref="F:JetBrains.Util.EmptyList`1.InstanceList"/>
            because each time you enumerate empty array, new <see cref="!:Array.SZArrayEnumerator"/> class instance is being created.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray">
            <summary>
            Reuses the single instance of an empty array (one per type).
            This class is preferrable over <see cref="T:JetBrains.Util.EmptyList`1"/> when you'd like to use SmartCompletion for completing the array type.
            </summary>
        </member>
        <member name="M:JetBrains.Util.EmptyArray.GetInstance``1">
            <summary>Synonym for <see cref="F:JetBrains.Util.EmptyArray`1.Instance"/></summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Peek``1(System.Collections.Generic.IList{``0})">
            <summary>Stack-like peek operation for lists.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Pop``1(System.Collections.Generic.IList{``0})">
            <summary>Stack-like pop operation for lists.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Push``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Stack-like push operation for lists.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AssertEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},JetBrains.Util.OnError)">
            <summary>
            Asserts the collections have the same set of items (in any order).
            Similar to NUnit's <c>CollectionAssert.AreEquivalent</c>, but shows some readable output (the former would just dump both collections, and go guess the diff).
            </summary>
            <param name="enumerable">The collection to validate.</param>
            <param name="expected">The expected set of items.</param>
            <param name="onError">Throw, collect, etc.</param>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Equivalent means distinct collections (discarding duplicates) are equals as sets (disregarding order)
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EqualItemsContainedIn``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            This method is dangerous in two ways:
            * Quadratic complexity if <paramref name="set2"/> instance do not implements fast <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
              operation. Only ISet instance are safe to be passed as <paramref name="set2"/> argument.
            * Only checks that all <paramref name="set1"/> items are contained in <paramref name="set2"/>, but not the other way around.
              Yes, 'new[] { 1, 1 }.EqualItemsContainedIn(new[] { 1, 2 })' returns 'true'.
            </summary>
            <remarks>Generally, you should use <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/> instead of this method.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EqualItemsContainedInReadOnly``1(System.Collections.Generic.IReadOnlyCollection{``0},System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>
            This method is dangerous in two ways:
            * Quadratic complexity if <paramref name="set2"/> instance do not implements fast <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
              operation. Only ISet instance are safe to be passed as <paramref name="set2"/> argument.
            * Only checks that all <paramref name="set1"/> items are contained in <paramref name="set2"/>, but not the other way around.
              Yes, 'new[] { 1, 1 }.EqualItemsContainedInReadOnly(new[] { 1, 2 })' returns 'true'.
            </summary>
            <remarks>Generally, you should use <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/> instead of this method.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Tries to determine the number of elements in <paramref name="enumerable"/> in <c>O(1)</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast(System.Collections.ICollection)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast(System.String)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if length of <paramref name="enumerable"/> can be checked fast and this check gives <c>0</c>.
            Otherwise returns <c>false</c> (it does not necessarily mean that <paramref name="enumerable"/> is not empty)
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast(System.Collections.ICollection)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast(System.String)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if length of <paramref name="enumerable"/> can be checked fast and this check does not give <c>0</c>.
            Otherwise return <c>false</c> (it does not necessarily mean that <paramref name="enumerable"/> is empty!)
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast``1(System.Collections.Generic.ICollection{``0})">
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast(System.Collections.ICollection)">
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast(System.String)">
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> is empty (has no elements).
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(JetBrains.Util.LocalList{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.Stack{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.Queue{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> is empty (has no elements).
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(JetBrains.Util.LocalList{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.Stack{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.Queue{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsSingle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has exactly 1 element.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsSingle``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has exactly 1 element.
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasAtLeast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has <paramref name="minimumCount"/> elements or more.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasAtLeast``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has <paramref name="minimumCount"/> elements or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasAtLeast(System.String,System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="str"/> has <paramref name="minimumCount"/> characters or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMultiple``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has 2 elements or more.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMultiple``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has 2 elements or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMultiple(System.String)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="str"/> has 2 characters or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMoreThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has more than <paramref name="exclusiveLowerBound"/> elements.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMoreThan``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has more than <paramref name="exclusiveLowerBound"/> elements.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMoreThan(System.String,System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="str"/> has more than <paramref name="exclusiveLowerBound"/> characters.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CountIs``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CountIs(System.String,System.Int32)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.FirstNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns first not null element. If collection is empty or all elements are null, returns null
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.FirstNotNull``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
            Returns first not null element. If collection is empty or all elements are null, returns null
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SingleItem``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns element of the single-item sequence or default(T) value otherwise.
            Just like .SingleOrDefault(), but doesn't throws when sequence contains multiple items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SingleItem``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns element of the single-item list or default(T) value otherwise.
            Just like .SingleOrDefault(), but doesn't throws when list contains multiple items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SingleItem``1(``0[])">
            <summary>
            Returns element of the single-item array or default(T) value otherwise.
            Just like .SingleOrDefault(), but doesn't throws when array contains multiple items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SelectNotNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Projects each element of a sequence into a new form of a nullable value type,
            and yields the values out of those nullables which are not <c>NULL</c>.
            </summary>
            <remarks>Once this used to return still a nullable type, but it's logical to coerce
            to the real value type if we're throwing away NULLs, and inspecting usages confirmed this.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AddRangeFluent``2(``1,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fluent <c>AddRange</c>, returns the collection, can be used in chains and in field initializers.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.RemoveRange``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Removes given elements from collection using <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/> method.
            For source collection implemented as list time will be O(n*m), for hashset - O(m)
            where n - number of elements in source collection, m - number of elements in remove-list.
            </summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TSource"></typeparam>
            <param name="collection"></param>
            <param name="items"></param>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AsReadOnly``1(JetBrains.Util.JetReadOnlyCollection{``0})">
            <summary>Static overload to prevent runtime type checks.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AsReadOnly``2(System.Collections.ObjectModel.ReadOnlyDictionary{``0,``1})">
            <summary>Static overload to prevent runtime type checks.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Sort``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            WARNING: Sometimes it sorts collection in-place
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EnumerateRecursivelyDfs``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerates the tree structure recursively. The tree includes the root element <paramref name="root"/> itself,
            its children, as gotten from <paramref name="getChildren"/>, and the children of those children, and so on.
            The walk uses Depth-First Search, does not use additional memory, but puts a strain on the call stack.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EnumerateRecursivelyBfs``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerates the tree structure recursively. The tree includes the root element <paramref name="root"/> itself,
            its children, as gotten from <paramref name="getChildren"/>, and the children of those children, and so on.
            The walk uses Breadth-First Search, does not use call stack, but allocates some additional memory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EnumerateRecursivelyBfsDistinct``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerates the tree structure recursively. The tree includes the root element <paramref name="root"/> itself,
            its children, as gotten from <paramref name="getChildren"/>, and the children of those children, and so on.
            The walk uses Breadth-First Search, does not use call stack, but allocates some additional memory.
            The results are collected in a hash set, so infinite recursion is processed correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that silently returns <c>null</c>
            when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetValueNullable``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that silently returns <c>null</c>
            when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.String)">
            <summary>
            A <see cref="!:IDictionary&lt;TKey,TValue&gt;.Item"/> version that throws the explicit <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            exception text when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetValue``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.String,``2)">
            <summary>
            A <see cref="!:IDictionary&lt;TKey,TValue&gt;.Item"/> version that throws the explicit <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            exception text when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that adds a new entry the <paramref name="key"/>
            is not present in the <paramref name="dictionary"/>. The new value is given by <paramref name="factory"/> in this case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that adds a new entry the <paramref name="key"/>
            is not present in the <paramref name="dictionary"/>. The new value is given by <paramref name="factory"/> in this case.
            </summary>
            <remarks>
            This version takes a function of the key to allow caching the value-creation delegate without creating a new closure each time,
            as <see cref="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})"/> would do.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that adds a new entry the <paramref name="key"/>
            is not present in the <paramref name="dictionary"/>. The new value is given as <paramref name="altValue"/> in this case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``2(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.Func{System.Text.StringBuilder,``1})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``2(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.Func{System.Text.StringBuilder,``1})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.Text.StringBuilder,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``2(System.Collections.Generic.IEnumerable{``0},System.Text.StringBuilder,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.Func{System.Text.StringBuilder,``1})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayUnion``1(``0[],``0)">
            <summary>
            <para>Creates a new array that is the old array plus one new item.</para>
            <para>If the item is already present in the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="array">Original array (will not be modified).</param>
            <param name="item">The item to add.</param>
            <returns>The new array, if item added; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayUnion``1(``0[],``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            <para>Creates a new array that is the old array plus one new item.</para>
            <para>If the item is already present in the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="array">Original array (will not be modified).</param>
            <param name="item">The item to add.</param>
            <param name="comparer">Item equality.</param>
            <returns>The new array, if item added; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayExcept``1(``0[],``0)">
            <summary>
            <para>Creates a new array that is the old array except the given item.</para>
            <para>If the item is not on the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="thіs">Original array (will not be modified).</param>
            <param name="item">The item to remove.</param>
            <returns>The new array, if item removed; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayExcept``1(``0[],``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            <para>Creates a new array that is the old array except the given item.</para>
            <para>If the item is not on the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="array">Original array (will not be modified).</param>
            <param name="item">The item to remove.</param>
            <param name="comparer">Item equality.</param>
            <returns>The new array, if item removed; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Add``1(System.Collections.Generic.ICollection{``0},JetBrains.DataFlow.Lifetime,``0)">
            <summary>
            Temporarily adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>,
            for the period of time defined by the <paramref name="lifetime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AddRange``1(System.Collections.Generic.ICollection{``0},JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Temporarily adds the elements of the specified collection to the end of the <see cref="T:System.Collections.Generic.ICollection`1"/>,
            for the period of time defined by the <paramref name="lifetime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
            <summary>
            A helper for quickly implementing <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/> on a collection class which already can do enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SafeOfType``1(System.Collections.IEnumerable)">
            <summary>
            <para>A less-throwing version of <see cref="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)"/>.</para>
            <para>Accepts <c>Null</c> input, yielding an empty collection.</para>
            <para>Drops exceptions in <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>.</para>
            <para>Does not mitigate exceptions in <see cref="M:System.Collections.IEnumerator.MoveNext"/> / <see cref="P:System.Collections.IEnumerator.Current"/>, though.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
             <summary>
             This extension method sucks in many ways:
            
             * We all familiar with C# statements like 'foreach', 'using', 'if' and other. If you are dealing with booleans,
               why would you define If(() => condition, () => then, () => else) method? Typical 'foreach' loops are no different,
               we already have a language construct to do the iteration and there is no real need to "virtualize" the language.
            
             * '.ForEach()' is easier to type than the 'foreach' statement - this is no longer true thanks to '.foreach' postfix
               template available in ReSharper out-of-box. Also, generally it's not a good idea to do _imperative_ '.ForEach()' loop
               in the end of multi-line _declarative_ LINQ query. Having separate variable for LINQ sequence + imperative 'foreach'
               loop below is a better choice and a bit easier to debug (you can see the sequence contents).
            
             * Inside imperative loops C-like languages do supports 'continue;' and 'break;' statements we all familiar with. Well,
               '.ForEach()' extension kinda supports 'continue;' too, but it is represented with 'return;' inside lambda expression -
               not very clear, right? This also means you can't do 'return' from containing method out of '.ForEach()' loop.
            
             * You just can't do enumeration with '.ForEach()' over all the things C#'s 'foreach' statement can enumerate,
               including our LocalList{T} collection or old non-generic collections.
            
             And if performance matters for you, avoiding '.ForEach()' is even more solid choice:
            
             * Usages of '.ForEach()' method often produce unnecessary closures (since to do something useful inside a loop
               you have to capture something in lambda). Closures introduce additional GC preassure just to do such a basic task
               of iterating over the enumerable sequence.
            
             * With '.ForEach()' method you are basically throwing away all the optimizations C# 'foreach' statement performs
               for popular collection types like List{T}. Ordinary 'foreach' over List{T} would not allocate heap memory AT ALL +
               most of List{T}.Enumerator member invocations would be inlined. For contrast, '.ForEach()' call would normally make
               1 allocation for delegate instance + 1 allocation for closure class + 1 allocation of IEnumerator{T} instance + ~n*2
               interface calls via IEnumerator{T} interface.
            
             * CLR performs "inline caching" technique to perform fast(er) calls of iterface members. If some 'foreach' loop iterates
               over IEnumerable{T}s that are always List{T} instances at runtime, the inline cache for method containing this 'foreach'
               loop will take advantage of this invariant and would produce faster MoveNext()/Current calls.
            
             </summary>
             <remarks>You can use "To foreach statement" context action to rewrite usages of this method into 'foreach' statement.</remarks>
        </member>
        <member name="T:JetBrains.Util.Console.MyConsole">
            <summary>
            Extended console for both Windows and Console Applications.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Initialize">
            <summary>
            Initializes WinConsole -- should be called at the start of the program using it
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Beep">
            <summary>
            Produces a simple beep.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Flash(System.Boolean)">
            <summary>
            Flashes the console window
            </summary>
            <param name="once">if off, flashes repeated until the user makes the console foreground</param>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Clear">
            <summary>
            Clear the console window
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.RedirectDebugOutput(System.Boolean,JetBrains.Util.Console.ConsoleColor,System.Boolean)">
            <summary>
            Redirects debug output to the console
            </summary>
            <param name="clear">clear all other listeners first</param>
            <param name="color">color to use for display debug output</param>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.RedirectTraceOutput(System.Boolean,JetBrains.Util.Console.ConsoleColor)">
            <summary>
            Redirects trace output to the console
            </summary>
            <param name="clear">clear all other listeners first</param>
            <param name="color">color to use for display trace output</param>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.GetWindowPosition(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Gets the Console Window location and size in pixels
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.SetWindowPosition(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the console window location and size in pixels
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.OpenStandardInput">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.OpenStandardInput(System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.OpenStandardError">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.OpenStandardError(System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.OpenStandardOutput">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.OpenStandardOutput(System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.SetIn(System.IO.TextReader)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.SetOut(System.IO.TextWriter)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.SetError(System.IO.TextWriter)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Read">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.ReadLine">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Boolean)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Char)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Char[])">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Char[],System.Int32,System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Decimal)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Double)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Single)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.UInt32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Int64)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.UInt64)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.String)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.String,System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.String,System.Object,System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.String,System.Object,System.Object,System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.WriteLine(System.String,System.Object[])">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.String,System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.String,System.Object,System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.String,System.Object,System.Object,System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.String,System.Object[])">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Boolean)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Char)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Char[])">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Double)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Decimal)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Single)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Int32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.UInt32)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Int64)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.UInt64)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.Object)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="M:JetBrains.Util.Console.MyConsole.Write(System.String)">
            <summary>
            Same as the Console counterpart
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Visible">
            <summary>
            Specifies whether the console window should be visible or hidden
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Title">
            <summary>
            Gets or sets the title of the console window
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Handle">
            <summary>
            Get the HWND of the console window
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.ParentHandle">
            <summary>
            Gets and sets a new parent hwnd to the console window
            </summary>
            <param name="window"></param>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Buffer">
            <summary>
            Get the current Win32 buffer handle
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.CursorPosition">
            <summary>
            Get the current position of the cursor
            </summary>
            
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.ScreenSize">
            <summary>
            Returns a coordinates of visible window of the buffer
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.BufferSize">
            <summary>
            Returns the size of buffer
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.MaximumScreenSize">
            <summary>
            Returns the maximum size of the screen given the desktop dimensions
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Info">
            <summary>
            Returns various information about the screen buffer
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Color">
            <summary>
            Gets or sets the current color and attributes of text 
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.CtrlBreakPressed">
            <summary>
            Returns true if Ctrl-C or Ctrl-Break was hit since the last time this property
            was called. The value of this property is set to false after each request.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Error">
            <summary>
            Returns the error stream (same as Console.Error)
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.In">
            <summary>
            Returns the input stream (same as Console.In)
            </summary>
        </member>
        <member name="P:JetBrains.Util.Console.MyConsole.Out">
            <summary>
            Returns the output stream (same as Console.Out)
            </summary>
        </member>
        <member name="T:JetBrains.Util.Rects">
            <summary>
            A helper class for carrying out advanced operations over rectangles.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.AbsMaximum(System.Drawing.Size)">
            <summary>
            Returns the maximum of the size dimensions absolute values.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignWithin(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Makes sure one rectangle is wholy located within the other, preferring to keep its size if possible and executing minimal moves.
            </summary>
            <param name="source">The rectangle to align.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignWithinUsingMinSize(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Try to make sure one rectangle is located within the other, preferring to keep its size if possible and executing minimal moves.
            If source rectangle is bigger than the bounds, ensure its left top corner is within the bounds.
            </summary>
            <param name="source">The rectangle to align.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
            <param name="minSize">The rectangle minimal size.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenter(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Centers one rectangle within another.
            </summary>
            <param name="source">The rectangle to align. The returned value will have the same size.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenter(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Centers one rectangle within another.
            </summary>
            <param name="source">The rectangle to align. The returned value will have the same size.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenter(System.Drawing.Size,System.Drawing.Rectangle)">
            <summary>
            Centers one rectangle within another.
            </summary>
            <param name="source">The size of the rectangle to align. The returned value will have the same size.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenter(System.Windows.Size,System.Windows.Rect)">
            <summary>
            Centers one rectangle within another.
            </summary>
            <param name="source">The size of the rectangle to align. The returned value will have the same size.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenterAndCrop(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Centers one rectangle within another and crops down as needed.
            </summary>
            <param name="source">The rectangle to align. The returned value may be cropped down by the <paramref name="bounds"/>.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenterAndCrop(System.Drawing.Size,System.Drawing.Rectangle)">
            <summary>
            Centers one rectangle within another and crops down as needed.
            </summary>
            <param name="source">The size of the rectangle to align. The returned value may be cropped down by the <paramref name="bounds"/>.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenterAndDownscale(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Centers one rectangle within another. If the <paramref name="source"/> does not fit into <paramref name="bounds"/>, it's downscaled proportionally.
            </summary>
            <param name="source">The rectangle to align. The returned value may be downscaled.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenterAndDownscale(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Centers one rectangle within another. If the <paramref name="source"/> does not fit into <paramref name="bounds"/>, it's downscaled proportionally.
            </summary>
            <param name="source">The rectangle to align. The returned value may be downscaled.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenterAndDownscale(System.Drawing.Size,System.Drawing.Rectangle)">
            <summary>
            Centers one rectangle within another. If the <paramref name="source"/> does not fit into <paramref name="bounds"/>, it's downscaled proportionally.
            </summary>
            <param name="source">The size of the rectangle to align. The returned value may be downscaled.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AlignCenterAndDownscale(System.Windows.Size,System.Windows.Rect)">
            <summary>
            Centers one rectangle within another. If the <paramref name="source"/> does not fit into <paramref name="bounds"/>, it's downscaled proportionally.
            </summary>
            <param name="source">The size of the rectangle to align. The returned value may be downscaled.</param>
            <param name="bounds">The bounds to align the <paramref name="source"/> within, may be smaller than <paramref name="source"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.Attach(System.Drawing.Rectangle@,System.Windows.Forms.DockStyle,System.Int32)">
            <summary>
            Returns a non-collapsed rectangle attached outside the <paramref name="anchor"/> rectangle.
            </summary>
            <param name="anchor">The attachment anchor. Increased to include the newly-attached rectangle on exit, so that to attach multiple rects in sequence.</param>
            <param name="dockstyle">The docking style, which can be a side-dock only.</param>
            <param name="size">The characteristic size of the side-attached rectangle (only either width or height, whichever is not defined by the attachment process).</param>
            <returns>The rectangle attached at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Attach(System.Drawing.Rectangle@,System.Windows.Forms.DockStyle,System.Drawing.Size)">
            <summary>
            Returns a non-collapsed rectangle attached outside the <paramref name="anchor"/> rectangle.
            </summary>
            <param name="anchor">The attachment anchor. Increased to include the newly-attached rectangle on exit, so that to attach multiple rects in sequence.</param>
            <param name="dockstyle">The docking style, which can be a side-dock only.</param>
            <param name="size">The characteristic size of the side-attached rectangle (only either width or height is used, whichever is not defined by the attachment process).</param>
            <returns>The rectangle attached at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Attach(System.Drawing.Rectangle,System.Windows.Forms.DockStyle,System.Int32)">
            <summary>
            Returns a non-collapsed rectangle attached outside the <paramref name="anchor"/> rectangle.
            </summary>
            <param name="anchor">The attachment anchor.</param>
            <param name="dockstyle">The docking style, which can be a side-dock only.</param>
            <param name="size">The characteristic size of the side-attached rectangle (only either width or height, whichever is not defined by the attachment process).</param>
            <returns>The rectangle attached at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Attach(System.Drawing.Rectangle,System.Windows.Forms.DockStyle,System.Drawing.Size)">
            <summary>
            Returns a non-collapsed rectangle attached outside the <paramref name="anchor"/> rectangle.
            </summary>
            <param name="anchor">The attachment anchor.</param>
            <param name="dockstyle">The docking style, which can be a side-dock only.</param>
            <param name="size">The characteristic size of the side-attached rectangle (only either width or height is used, whichever is not defined by the attachment process).</param>
            <returns>The rectangle attached at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.ClipSmart(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Performs the smart clipping that returns a non-all-zeros rectangle even if there is no intersection.
            Ie, when the <paramref name="source"/> rect lays outside the <paramref name="bounds"/> over some side, the result is a zero-thick projection on that side.
            </summary>
            <param name="source"></param>
            <param name="bounds"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Rects.ClipSmart(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Performs the smart clipping that returns a non-all-zeros rectangle even if there is no intersection.
            Ie, when the <paramref name="source"/> rect lays outside the <paramref name="bounds"/> over some side, the result is a zero-thick projection on that side.
            </summary>
            <param name="source"></param>
            <param name="bounds"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Collapse(System.Drawing.Rectangle,JetBrains.UI.Anchoring2D)">
            <summary>
            Collapses a rectangle down to a point.
            The inside modes are located on the inner sides of the rectangle, and outside ones are one point outside.
            The bottom-right sides are not included within the rectangle area.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Collapse(System.Windows.Rect,JetBrains.UI.Anchoring2D)">
            <summary>
            Collapses a rectangle down to a point.
            The inside modes are located on the inner sides of the rectangle, and outside ones are one point outside.
            The bottom-right sides are not included within the rectangle area.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Constrain(System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Constrains the <paramref name="source"/> size by the <paramref name="limit"/>.
            </summary>
            <param name="source">The source size to be limited. May be non-normalized.</param>
            <param name="limit">The limiting size. Must be normalized.</param>
            <returns>The constrainted <paramref name="source"/>, guaranteed to be normalized.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Constrain(System.Windows.Size,System.Windows.Size)">
            <summary>
            Constrains the <paramref name="source"/> size by the <paramref name="limit"/>.
            </summary>
            <param name="source">The source size to be limited. May be non-normalized.</param>
            <param name="limit">The limiting size. Must be normalized.</param>
            <returns>The constrainted <paramref name="source"/>, guaranteed to be normalized.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Deflate(System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Deflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will shrink.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Deflate(System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Deflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will shrink.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Deflate(System.Windows.Rect,System.Windows.Size)">
            <summary>
            Deflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will shrink.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Deflate(System.Drawing.Rectangle,System.Windows.Forms.Padding)">
            <summary>
            Deflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will shrink.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Deflate(System.Windows.Rect,System.Windows.Thickness)">
            <summary>
            Deflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will shrink.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Drawing.Rectangle@,System.Windows.Forms.DockStyle,System.Int32)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space. Decreased to exclude the newly-docked rectangle on exit, so that to dock multiple rects in sequence.</param>
            <param name="dockstyle">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (either width or height, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Windows.Rect@,System.Nullable{System.Windows.Controls.Dock},System.Double)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space. Decreased to exclude the newly-docked rectangle on exit, so that to dock multiple rects in sequence.</param>
            <param name="dock">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (either width or height, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Drawing.Rectangle@,System.Windows.Forms.DockStyle,System.Drawing.Size)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space. Decreased to exclude the newly-docked rectangle on exit, so that to dock multiple rects in sequence.</param>
            <param name="dockstyle">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (only either width or height is used, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Windows.Rect@,System.Nullable{System.Windows.Controls.Dock},System.Windows.Size)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space. Decreased to exclude the newly-docked rectangle on exit, so that to dock multiple rects in sequence.</param>
            <param name="dock">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (only either width or height is used, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Drawing.Rectangle,System.Windows.Forms.DockStyle,System.Int32)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space.</param>
            <param name="dockstyle">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (either width or height, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Windows.Rect,System.Nullable{System.Windows.Controls.Dock},System.Double)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space.</param>
            <param name="dock">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (either width or height, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Drawing.Rectangle,System.Windows.Forms.DockStyle,System.Drawing.Size)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space.</param>
            <param name="dockstyle">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (only either width or height is used, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Dock(System.Windows.Rect,System.Nullable{System.Windows.Controls.Dock},System.Windows.Size)">
            <summary>
            Returns a non-collapsed rectangle docked within the <paramref name="space"/> rectangle.
            </summary>
            <param name="space">The docking space.</param>
            <param name="dock">The docking style, which can be either any side or fill.</param>
            <param name="size">The characteristic size of the side-docked rectangle (only either width or height is used, whichever is not defined by the docking process). In the <see cref="F:System.Windows.Forms.DockStyle.Fill"/> case, this parameter is ignored.</param>
            <returns>The rectangle docked at the given side.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.EnsureEmptySize(System.Drawing.Size)">
            <summary>
            Returns <see cref="F:System.Drawing.Size.Empty"/> if the given <paramref name="size"/> is "enhanced-empty", that is, either it's <see cref="P:System.Drawing.Size.IsEmpty"/>, or one of its dimensions is zero. Otherwise, returns the original size.
            Curcumvents the fact that <see cref="P:System.Drawing.Size.IsEmpty"/> requires both dimensions to be simultaneousely zero.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.FromLtrbNonnegative(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle in a way similar to <see cref="M:System.Drawing.Rectangle.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)"/>, but ensures that no dimension is negative.
            If near is less than far, they're both set to the middle value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.FromLtrbNonnegative(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a rectangle in a way similar to <see cref="M:System.Drawing.Rectangle.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)"/>, but ensures that no dimension is negative.
            If near is less than far, they're both set to the middle value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.GetBorder(System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Gets a set of non-overlapping rectangles forming a border just inside the given rect, of the thickness specified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.GetCenter(System.Drawing.Rectangle)">
            <summary>
            Gets a point that is the center of the rectangle.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.GetCenter(System.Windows.Rect)">
            <summary>
            Gets a point that is the center of the rectangle.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.GetCenter(JetBrains.Interop.WinApi.RECT)">
            <summary>
            Gets a point that is the center of the rectangle.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Inflate(System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Inflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will grow.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Inflate(System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Inflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will grow.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Inflate(System.Drawing.Rectangle,System.Windows.Forms.Padding)">
            <summary>
            Inflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will grow.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Inflate(System.Windows.Rect,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Inflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will grow.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Inflate(System.Windows.Rect,System.Windows.Size)">
            <summary>
            Inflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will grow.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Inflate(System.Windows.Rect,System.Windows.Thickness)">
            <summary>
            Inflates all the rectangle's sides by the given amount. If the numbers are positive, the rectangle will grow.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsCollapsed(System.Drawing.Size)">
            <summary>
            Gets whether the given size is collapsed, that is, has a zero or negative dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsCollapsed(System.Windows.Size)">
            <summary>
            Gets whether the given size is collapsed, that is, has a zero or negative dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsCollapsed(System.Drawing.Rectangle)">
            <summary>
            Gets whether the given rectangle is collapsed, that is, has a zero or negative dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsCollapsed(System.Windows.Rect)">
            <summary>
            Gets whether the given rectangle is collapsed, that is, has a zero or negative dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsCollapsed(System.Nullable{System.Windows.Rect})">
            <summary>
            Gets whether the given rectangle is collapsed, that is, has a zero or negative dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsConstrained(System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Checks whether the <paramref name="source"/> size satisfies the <paramref name="limit"/>, in terms of the <see cref="M:JetBrains.Util.Rects.Constrain(System.Drawing.Size,System.Drawing.Size)"/> function.
            </summary>
            <param name="source">The source size to be limited. May be non-normalized.</param>
            <param name="limit">The limiting size. Must be normalized.</param>
            <returns>Whether executing <see cref="M:JetBrains.Util.Rects.Constrain(System.Drawing.Size,System.Drawing.Size)"/> over <paramref name="source"/> and <paramref name="limit"/> won't change the <paramref name="source"/>.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.IsConstrained(System.Windows.Size,System.Windows.Size)">
            <summary>
            Checks whether the <paramref name="source"/> size satisfies the <paramref name="limit"/>, in terms of the <see cref="M:JetBrains.Util.Rects.Constrain(System.Drawing.Size,System.Drawing.Size)"/> function.
            </summary>
            <param name="source">The source size to be limited. May be non-normalized.</param>
            <param name="limit">The limiting size. Must be normalized.</param>
            <returns>Whether executing <see cref="M:JetBrains.Util.Rects.Constrain(System.Drawing.Size,System.Drawing.Size)"/> over <paramref name="source"/> and <paramref name="limit"/> won't change the <paramref name="source"/>.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.IsEmptyArea(System.Drawing.Size)">
            <summary>
            Checks whether the size represents an empty area.
            Unlike <see cref="P:System.Drawing.Size.IsEmpty"/>, returns <c>True</c> if either of dimensions is empty (OR condition).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsEmptyArea(System.Drawing.Rectangle)">
            <summary>
            Checks whether the rectangle represents an empty area.
            Unlike <see cref="P:System.Drawing.Rectangle.IsEmpty"/>, returns <c>True</c> if either of dimensions is empty (OR condition), and ignores the <see cref="P:System.Drawing.Rectangle.Location"/> completely.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsInfinite(System.Drawing.Size)">
            <summary>
            Gets whether the given rectangle is close to maxvalues.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNanOrInf(System.Windows.Point)">
            <summary>
            Gets whether any of the coordinates are NAN or INF (<see cref="M:JetBrains.NumberUtil.IsNanOrInf(System.Double)"/>).
            </summary>
            <seealso cref="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Point,System.String)"/>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNanOrInf(System.Windows.Size)">
            <summary>
            Gets whether any of the coordinates are NAN or INF (<see cref="M:JetBrains.NumberUtil.IsNanOrInf(System.Double)"/>).
            </summary>
            <seealso cref="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Size,System.String)"/>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNanOrInf(System.Windows.Vector)">
            <summary>
            Gets whether any of the coordinates are NAN or INF (<see cref="M:JetBrains.NumberUtil.IsNanOrInf(System.Double)"/>).
            </summary>
            <seealso cref="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Size,System.String)"/>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNanOrInf(System.Windows.Rect)">
            <summary>
            Gets whether any of the coordinates are NAN or INF (<see cref="M:JetBrains.NumberUtil.IsNanOrInf(System.Double)"/>).
            </summary>
            <seealso cref="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Rect,System.String)"/>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNormalized(System.Drawing.Size)">
            <summary>
            Checks whether the size corresponds to a normalized rectangle.
            A normalized rectangle is such whose left coordinate is not greater than right, and top coordinate is not greater than bottom.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNormalized(System.Windows.Size)">
            <summary>
            Checks whether the size corresponds to a normalized rectangle.
            A normalized rectangle is such whose left coordinate is not greater than right, and top coordinate is not greater than bottom.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNormalized(System.Drawing.Rectangle)">
            <summary>
            Checks whether the rectangle is normalized.
            A normalized rectangle is such whose left coordinate is not greater than right, and top coordinate is not greater than bottom.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.IsNormalized(System.Windows.Rect)">
            <summary>
            Checks whether the rectangle is normalized.
            A normalized rectangle is such whose left coordinate is not greater than right, and top coordinate is not greater than bottom.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Max(System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Gets the normalized maximum of two sizes, max operation executed independently against both dimensions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Max(System.Windows.Size,System.Windows.Size)">
            <summary>
            Gets the normalized maximum of two sizes, max operation executed independently against both dimensions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Min(System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Gets the normalized minimum of two sizes, min operation executed independently against both dimensions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Min(System.Windows.Size,System.Windows.Size)">
            <summary>
            Gets the normalized minimum of two sizes, min operation executed independently against both dimensions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Normalize(System.Drawing.Rectangle)">
            <summary>
            Normalizes the rectangle so that it has non-negative <see cref="P:System.Drawing.Rectangle.Width"/> and <see cref="P:System.Drawing.Rectangle.Height"/>, and passes the <see cref="M:JetBrains.Util.Rects.IsNormalized(System.Drawing.Rectangle)"/> with <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Normalize(System.Windows.Rect)">
            <summary>
            Normalizes the rectangle so that it has non-negative <see cref="P:System.Drawing.Rectangle.Width"/> and <see cref="P:System.Drawing.Rectangle.Height"/>, and passes the <see cref="M:JetBrains.Util.Rects.IsNormalized(System.Drawing.Rectangle)"/> with <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Normalize(System.Drawing.Size)">
            <summary>
            Normalizes the size so that it <see cref="M:JetBrains.Util.Rects.IsNormalized(System.Drawing.Size)"/>. All the negative components are pulled up to become zero.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Offset(System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Offsets the rectangle location by the given amount.
            </summary>
            <param name="source">The source rectangle.</param>
            <param name="offset">The offset distance.</param>
            <returns>The resulting rectangle.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Offset(System.Drawing.Rectangle,System.Drawing.Point)">
            <summary>
            Offsets the rectangle location by the given amount.
            </summary>
            <param name="source">The source rectangle.</param>
            <param name="offset">The offset distance.</param>
            <returns>The resulting rectangle.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.SetBottom(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetBottom(System.Windows.Rect,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetBottom(System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetBottom(System.Windows.Rect@,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetLeft(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetLeft(System.Windows.Rect,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetLeft(System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetLeft(System.Windows.Rect@,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetRight(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetRight(System.Windows.Rect,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetRight(System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetRight(System.Windows.Rect@,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetTop(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetTop(System.Windows.Rect,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetTop(System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.SetTop(System.Windows.Rect@,System.Double)">
            <summary>
            Adjusts the rectangle so that only one of the Left, Top, Right, Bottom components changes. Width or Height are changed as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Size(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:System.Drawing.Size"/> object that is guaranteed to be normalized and, if at least one of its sides is empty, to be <see cref="P:System.Drawing.Size.IsEmpty"/>.
            </summary>
            <param name="width">The desired width.</param>
            <param name="height">The desired height.</param>
            <returns>A normalized size whose sides can only simultaneousely be <c>0</c>.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Size(System.Double,System.Double)">
            <summary>
            Creates a new <see cref="T:System.Drawing.Size"/> object that is guaranteed to be normalized and, if at least one of its sides is zero, to be all-zero.
            </summary>
            <param name="width">The desired width.</param>
            <param name="height">The desired height.</param>
            <returns>A normalized size whose sides can only simultaneousely be <c>0</c>.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Size(System.Drawing.Size)">
            <summary>
            Creates a new <see cref="T:System.Drawing.Size"/> object that is guaranteed to be normalized and, if at least one of its sides is empty, to be <see cref="P:System.Drawing.Size.IsEmpty"/>.
            </summary>
            <param name="size">The desired width and height.</param>
            <returns>A normalized size whose sides can only simultaneousely be <c>0</c>.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.StackHorizontally(System.Collections.Generic.IEnumerable{System.Drawing.Size},System.Int32)">
            <summary>
            Stacks a number of sizes horizontally and returns the resulting size.
            If a size in the list is collapsed, it's not included and the gaps for it are not added.
            </summary>
            <param name="sizes">The list of sizes to stack.</param>
            <param name="gap">The gap to insert between the adjacent stack-items.</param>
            <returns>The bounding rect of the result.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.StackHorizontally(System.Int32,System.Drawing.Size[])">
            <summary>
            Stacks a number of sizes horizontally and returns the resulting size.
            If a size in the list is collapsed, it's not included and the gaps for it are not added.
            </summary>
            <param name="sizes">The list of sizes to stack.</param>
            <param name="gap">The gap to insert between the adjacent stack-items.</param>
            <returns>The bounding rect of the result.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.StackVertically(System.Collections.Generic.IEnumerable{System.Drawing.Size},System.Int32)">
            <summary>
            Stacks a number of sizes vertically and returns the resulting size.
            If a size in the list is collapsed, it's not included and the gaps for it are not added.
            </summary>
            <param name="sizes">The list of sizes to stack.</param>
            <param name="gap">The gap to insert between the adjacent stack-items.</param>
            <returns>The bounding rect of the result.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.StackVertically(System.Int32,System.Drawing.Size[])">
            <summary>
            Stacks a number of sizes vertically and returns the resulting size.
            If a size in the list is collapsed, it's not included and the gaps for it are not added.
            </summary>
            <param name="sizes">The list of sizes to stack.</param>
            <param name="gap">The gap to insert between the adjacent stack-items.</param>
            <returns>The bounding rect of the result.</returns>
        </member>
        <member name="M:JetBrains.Util.Rects.Unite(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Unites the two rectangle and returns a rect that encompasses both.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.UniteHorizontally(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Unites the horizontal coordinates of the rectangles, and takes the y-coordinates solely from <paramref name="source"/>.
            </summary>
            <param name="source">The first rectangle, features the y-coordinates of the retval.</param>
            <param name="other">The second rectangle.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.UniteHorizontally(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Unites the horizontal coordinates of the rectangles, and takes the y-coordinates solely from <paramref name="source"/>.
            </summary>
            <param name="source">The first rectangle, features the y-coordinates of the retval.</param>
            <param name="other">The second rectangle.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.UniteVertically(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Unites the vertical coordinates of the rectangles, and takes the x-coordinates solely from <paramref name="source"/>.
            </summary>
            <param name="source">The first rectangle, features the x-coordinates of the retval.</param>
            <param name="other">The second rectangle.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.UniteVertically(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Unites the vertical coordinates of the rectangles, and takes the x-coordinates solely from <paramref name="source"/>.
            </summary>
            <param name="source">The first rectangle, features the x-coordinates of the retval.</param>
            <param name="other">The second rectangle.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Point,System.String)">
            <summary>
            Asserts that point coordinates are real numbers. Fluent.
            Throws on <see cref="F:System.Double.NaN"/>, <see cref="F:System.Double.PositiveInfinity"/>, <see cref="F:System.Double.NegativeInfinity"/>.
            </summary>
            <param name="pt">Point to test.</param>
            <param name="failmessage">Optional. Message to include in the failure exception.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Rect,System.String)">
            <summary>
            Asserts that rectangle coordinates are real numbers. Fluent.
            Throws on <see cref="F:System.Double.NaN"/>, <see cref="F:System.Double.PositiveInfinity"/>, <see cref="F:System.Double.NegativeInfinity"/>.
            </summary>
            <param name="rect">Point to test.</param>
            <param name="failmessage">Optional. Message to include in the failure exception.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.AssertIsReal(System.Windows.Size,System.String)">
            <summary>
            Asserts that size dimensions are real numbers. Fluent.
            Throws on <see cref="F:System.Double.NaN"/>, <see cref="F:System.Double.PositiveInfinity"/>, <see cref="F:System.Double.NegativeInfinity"/>.
            </summary>
            <param name="size">Point to test.</param>
            <param name="failmessage">Optional. Message to include in the failure exception.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.Collapse_Linear(System.Int32,System.Int32,JetBrains.UI.Anchoring)">
            <summary>
            A helper function for the <see cref="M:JetBrains.Util.Rects.Collapse(System.Drawing.Rectangle,JetBrains.UI.Anchoring2D)"/> func, handles one dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.Collapse_Linear(System.Double,System.Double,JetBrains.UI.Anchoring)">
            <summary>
            A helper function for the <see cref="M:JetBrains.Util.Rects.Collapse(System.Windows.Rect,JetBrains.UI.Anchoring2D)"/> func, handles one dimension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.StackImpl(System.Collections.Generic.IEnumerable{System.Drawing.Size},System.Int32,System.Boolean)">
            <summary>
            Implements the size-stacking.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Rects.MaxSize">
            <summary>
            Gets the size whose both components are <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Rects.RectsComparer">
            <summary>
            A comparer for the rectangles.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Rects.RectsComparer.Compare(System.Collections.Generic.IEnumerable{System.Drawing.Rectangle},System.Collections.Generic.IEnumerable{System.Drawing.Rectangle})">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            
            <returns>
            Value Condition Less than zerox is less than beta.Zerox equals beta.Greater than zerox is greater than beta.
            </returns>
            
            <param name="beta">The second object to compare.</param>
            <param name="alpha">The first object to compare.</param>
        </member>
        <member name="M:JetBrains.Util.Rects.RectsComparer.Compare(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            
            <returns>
            Value Condition Less than zerox is less than beta.Zerox equals beta.Greater than zerox is greater than beta.
            </returns>
            
            <param name="beta">The second object to compare.</param>
            <param name="alpha">The first object to compare.</param>
        </member>
        <member name="T:JetBrains.Util.TextRange">
            <summary>
            Represents a range in a plaintext document.
            </summary>
        </member>
        <member name="F:JetBrains.Util.TextRange.InvalidRange">
            <summary>
            Should be replaced with <see cref="T:System.Nullable`1"/> of <see cref="T:JetBrains.Util.TextRange"/> wherever possible.
            Avoid using in new code.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.FromLength(System.Int32,System.Int32)">
            <summary>
            Creates a new range from offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.FromLength(System.Int32)">
            <summary>
            Creates a new range from zero offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.FromUnorderedOffsets(System.Int32,System.Int32)">
            <summary>
            <para>Creates a range from two unordered offsets, i.e. when it's not known which of the offsets is the start and which one is the end.</para>
            <para>The resultant range is guaranteed to be normalized.</para>
            <para>DO NOT USE unless the source of your offset is unordered by its nature (eg if you select text with shift+left the offsets of
            the selection range will be inverted, so they're sometimes out of order by design). Usually you should know which offset is start
            and which is end, and failure to do so might indicate an error in preceding code.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.GetMinOffset">
            <summary>
            Gets the <see cref="P:JetBrains.Util.TextRange.StartOffset"/> or <see cref="P:JetBrains.Util.TextRange.EndOffset"/>, whichever is smaller.
            Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.GetMaxOffset">
            <summary>
            Gets the <see cref="P:JetBrains.Util.TextRange.StartOffset"/> or <see cref="P:JetBrains.Util.TextRange.EndOffset"/>, whichever is greater.
            Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.ContainedIn(JetBrains.Util.TextRange)">
            <summary>
            Gets whether this range is a subset of the <paramref name="textRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.StrictContainedIn(JetBrains.Util.TextRange)">
            <summary>
            Gets whether this range is a proper subset of the <paramref name="textRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.Contains(System.Int32)">
            <summary>
            Determines whether the offset falls within the range, start and end offsets included.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.ContainsCharIndex(System.Int32)">
            <summary>
            <para>Checks whether the character at the <paramref name="charindex">given index</paramref> falls within this range.</para>
            <para>Unlike <see cref="M:JetBrains.Util.TextRange.Contains(System.Int32)"/>, the right offset is not included, because the range ends before the character with such an index.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.AssertValid">
            <summary>
            Asserts that this range is valid, which means that it's not an <see cref="F:JetBrains.Util.TextRange.InvalidRange"/>.
            Throws in ASSERT mode only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.AssertNormalized">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.Util.TextRange.Length"/> is nonnegative.
            Includes <see cref="M:JetBrains.Util.TextRange.AssertValid"/>.
            Throws in ASSERT mode only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.Normalized">
            <summary>
            Returns a normalized version of the current text range (with a nonnegative length).
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.DistanceTo(System.Int32)">
            <summary>
            Returns the distance between the <paramref name="offset"/> and the nearest point that belongs to the range.
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.StartOffset">
            <summary>
            <para>The first offset (character position) of the range, inclusive.</para>
            <para>A character at this index is included with the range.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.EndOffset">
            <summary>
            <para>The last offset (character position) of the range, non-inclusive.</para>
            <para>A character at this index is not included with the range and goes right after the range end.</para>
            <para>An end offset could point at the end of the document, in which case there's no character at this position.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.Length">
            <summary>
            <para>The number of characters in the text range.</para>
            <para>As the end offset is non-inclusive, this is equal to <see cref="P:JetBrains.Util.TextRange.EndOffset"/> <c>–</c> <see cref="P:JetBrains.Util.TextRange.StartOffset"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.IsEmpty">
            <summary>
            <para>Whether the range is empty.</para>
            <para>The <see cref="P:JetBrains.Util.TextRange.Length"/> of an empty range is zero, and its <see cref="P:JetBrains.Util.TextRange.StartOffset"/> is the same as its <see cref="P:JetBrains.Util.TextRange.EndOffset"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.IsValid">
            <summary>
            Should be replaced with <see cref="T:System.Nullable`1"/> of <see cref="T:JetBrains.Util.TextRange"/> wherever possible.
            Avoid using in new code.
            Checks that the range is not the <see cref="F:JetBrains.Util.TextRange.InvalidRange"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.IsNormalized">
            <summary>
            Gets whether this range is normalized, which means that its <see cref="P:JetBrains.Util.TextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EnsureWritableResult">
            <summary>
            Represents the result of an attempt to make files writable
            </summary>
        </member>
        <member name="F:JetBrains.Util.EnsureWritableResult.SUCCESS">
            <summary>
            All files were successfully made writable
            </summary>
        </member>
        <member name="F:JetBrains.Util.EnsureWritableResult.FAILURE">
            <summary>
            The attempt failed for some files
            </summary>
        </member>
        <member name="F:JetBrains.Util.EnsureWritableResult.CHANGES_DETECTED">
            <summary>
            Some files were modified as a result of the attempt to make them writable
            </summary>
        </member>
        <member name="F:JetBrains.Util.EnsureWritableResult.CANCELLED">
            <summary>
            Cancelled by user
            </summary>
        </member>
        <member name="T:JetBrains.Util.Events.EventDispatcher">
            <summary>
            Helper class for dispatching pending events
            </summary>
        </member>
        <member name="F:JetBrains.Util.Events.EventDispatcher.myDispatchingListeners">
            <summary>
            The stack of listeners being dispatched
            </summary>
        </member>
        <member name="F:JetBrains.Util.Events.EventDispatcher.myListeners">
            <summary>
            List of listeners ordered by the time listener was added
            </summary>
        </member>
        <member name="F:JetBrains.Util.Events.EventDispatcher.myListenersMap">
            <summary>
            Maps listeners to "notified" flags
            </summary>
        </member>
        <member name="F:JetBrains.Util.Events.EventDispatcher.myLastArgs">
            <summary>
            The last call args
            </summary>
        </member>
        <member name="F:JetBrains.Util.Events.EventDispatcher.myListenersArray">
            <summary>
            Array of listeners
            </summary>
        </member>
        <member name="T:JetBrains.Util.IndexComparer`1">
            <summary>
            Compares elements by their positions in an ArrayList
            </summary>
        </member>
        <member name="M:JetBrains.Util.UserDataHolderExtensions.GetOrCreateData``2(JetBrains.Util.IUserDataHolder,JetBrains.Util.Key{``0},``1,System.Func{``1,``0})">
            <summary>
            Lambda-lifted overload: use a cached delegate instead of creating a new closure object on each call.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Key">
            <summary>
            Class to be used for keys in <see cref="T:JetBrains.Util.IUserDataHolder"/>.
            May also be used in other places where unique keys are needed.
            Instances of this class are constructed with String parameter
            but use it only to return in <see cref="!:Key.ToString()"/> method.
            This class does not override <see cref="M:System.Object.Equals(System.Object)"/> 
            and <see cref="M:System.Object.GetHashCode"/> and therefore all instances of 
            this class are considered to be different.
            <seealso cref="T:JetBrains.Util.IUserDataHolder"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Key`1">
            <summary>
            Strongly types key. <see cref="T:JetBrains.Util.Key"/>
            This class does not override <see cref="M:System.Object.Equals(System.Object)"/> 
            and <see cref="M:System.Object.GetHashCode"/> and therefore all instances of 
            this class are considered to be different.
            <seealso cref="T:JetBrains.Util.IUserDataHolder"/>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.ByteBufferUnderlohSize">
            <summary>
            Specifies the maximum optimal size of the byte buffer, such as for copying, which still fits into the regular heaps and does not fall off to LOH.
            Borrowed from System.Stream v4, which also recommends to have it a multiple of 4096 (page size?.. dunno).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.CopyMemoryPinvokeThreshold">
            <summary>
            If got at least this many bytes to copy, PInvoke for native impl. Otherwise, do a loop. PInvoke has a one-time call cost, but works more effectively than a loop.
            This value was researched with the <c>AssessPinvokeFallback</c> test.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.GetAvailablePhysicalMemory">
            <summary>
            Gets rhe amount of physical memory currently available, in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.GetTotalVirtualMemory">
            <summary>
            Gets the total amount of virtual memory available to the process.
            Caches the value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.GetMachinePhysicalMemory">
            <summary>
            Gets the total physical memory on this machine.
            Caches the value.
            </summary>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myTotalVirtualMemory">
            <summary>
            Caches the memory stats.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myMachinePhysicalMemory">
            <summary>
            Caches the memory stats.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.memcmp(System.Void*,System.UInt32,System.Void*,System.UInt32)">
            <summary>
            Compares two memory regions.
            </summary>
            <param name="p1">Pointer to the start of the region.</param>
            <param name="cb1">Length of the region, in bytes.</param>
            <param name="p2">Pointer to the start of the region.</param>
            <param name="cb2">Length of the region, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.ObjectGraphScanner.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
            
            <param name="y">The second object to compare.</param>
            <param name="x">The first object to compare.</param>
            <exception cref="T:System.ArgumentException">x and y are of different types and neither one can handle comparisons with the other.</exception>
        </member>
        <member name="T:JetBrains.Util.NamedAutoResetEvent">
            <summary>
            Event that can be used for cross-process synchronization
            </summary>
        </member>
        <member name="T:JetBrains.Util.RegistryUtil">
            <summary>
            This is a convenient wrapper around Registry API. It recognizes registry paths of the XPath syntax
            </summary>
        </member>
        <member name="M:JetBrains.Util.RegistryUtil.GetMimeType(System.String)">
            <summary>
            Gets the MIME type of the file by looking up Registry for its extension.
            </summary>
        </member>
        <member name="M:JetBrains.Util.UnixFileSystemInteraction.CalculatePerUserTempDir">
            For Unix (where temp is usually in /tmp) TEMP is per machine, so we need to carefully create
            our own folder (per user) in it
        </member>
        <member name="F:JetBrains.Util.StringUtil.ourRandom">
            <summary>
            In order to get varying results on adjacent calls, there must be a shared Random object.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StringUtil.ourRegexMacro">
            <summary>
            Caches the macro substitution regex.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.StartsWith(System.String,System.String,System.StringComparison)">
            <summary>
            Returns true if one qualified name starts with another.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Combine(System.String,System.String)">
            <summary>
            Concatenates two names into a qualified name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ShortName(System.String)">
            <summary>
            Gets a short name out of qualified name (does not take nested classes (+ sign) into account)
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.NextQualification(System.String,System.String)">
            <summary>
            Takes a start of a fully qualified name and adds next part of it, e.g.:
            NextQualification ("A.B", "A.B.D.D") results in "A.B.D".
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.SplitFQName(System.String)">
            <remarks> Splits fully qualified name of a class into name of the namespace and short name </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.MakeFQName(System.String,System.String)">
            <remarks> Concats namespace name and class name into fully qualified name </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Split(System.String,System.String,System.Boolean)">
            <remarks> Splits a string into tokens given the string of delimiter characters. The third argument
            tells whether it is necessary to retain empty strings in the array returned. This functions is not
            as efficient as it may be, so use it accurately.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GetCommon(System.String,System.String,System.Int32@)">
            <summary>
            Gets intersection of two qualified names
            </summary>
            <example>
            Calling it for "A.B.D.D" and "C.D.E.F" will return "C.D"
            </example>    
        </member>
        <member name="M:JetBrains.Util.StringUtil.SubstituteMacros(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            <para>Substs the macros in a string, throws if there are undefined macros.</para>
            <para>Does a one-stage replacement only, i.e. if some macro expands into another macro, this is not processed if the macro is known and not treated as an error if the macro is unknown.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName(System.Int32)">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName(System.Int32,System.Random)">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomNameForObject(System.Object)">
            <summary>
            Produces a stable human-readable random name for an object instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.IsEmpty(System.String)">
            <summary>
            Checks whether the string is an empty string or a <c>Null</c> reference.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToThreadString(System.Threading.Thread)">
            <summary>
            Formats the identity of a thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.FormatQuoted(System.String,System.Object[])">
            <summary>
            Works like <see cref="M:System.String.Format(System.String,System.Object[])"/>, but surrounds the space-containing arguments with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.QuoteIfNeeded(System.String)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToStringIfNonDefault(System.Object)">
            <summary>
            Returns the <paramref name="o"/>'s <see cref="M:System.Object.ToString"/> value, unless <paramref name="o"/> is <c>Null</c>, or its <see cref="M:System.Object.ToString"/> is the default implementation (just returns the type name).
            Could be used to prevent non-implemented strings from getting into the UI.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.DropMiddleIfLong(System.String,System.Int32)">
            <summary>
            Makes sure the return text is no longer than <paramref name="nMaxLen"/>. Drops some text from the middle, if needed, keeping the beginning and the end.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToHexString(System.IntPtr)">
            <summary>
            Renders the pointer-sized integer as the appropriate number of hex chars, with leading zeros.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToHexString(System.Void*)">
            <summary>
            Renders the pointer value as the appropriate number of hex chars, with leading zeros.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToHexString(System.UIntPtr)">
            <summary>
            Renders the pointer-sized integer as the appropriate number of hex chars, with leading zeros.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToStringWithLeading(System.Int32,System.Int32)">
            <summary>
            Formats the <paramref name="value"/> to a string, adding leading zeros so that all of the numbers up to <paramref name="maxvalue"/>, inclusively, had the same number of characters in their string representation when formatted thru this function.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.SplitByWords(System.String)">
            <summary>
            Gets the words.
            </summary>
            <param name="text">The text.</param>
        </member>
        <member name="M:JetBrains.Util.StringUtil.IsNullOrWhitespace(System.String)">
            <summary>
            Mimics the Netfx4 <c>String::IsNullOrWhiteSpace</c> method.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.MakeUpperCamelCaseName(System.String)">
            <summary>
            Changes the name from lowerCamelCase or MixedCAMELCase or
            dashed-words or underscored_words into the UpperCamelCase format.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GetPlatformIndependentHashCode(System.String,System.Boolean)">
            <summary>
            Platform independent hash code, can be used to persist records. <see cref="M:System.String.ToString"/> is different for x86 and x64, so it can't be used for serialization.
            </summary>
            <param name="s">source string</param>
            <param name="caseSensitive"> whether method should threat capital and smaller letters differently </param>
            <returns>hashcode</returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.UrlEncode(System.String)">
            <summary>
            Encodes a string for URI charset, assuming UTF-8 encoding for any non-ascii characters.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.StrFormatByteSize(System.Int64)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="nSize">Numeric value to be converted.</param>
            <returns>Returns the size string.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            Numeric value -> Text string
            532 532 -> bytes
            1340 -> 1.30KB
            23506 -> 22.9KB
            2400016 -> 2.29MB
            2400000000 -> 2.23GB
            
            Current implementation on Unix systems is much simplier (prints 'XXX bytes')
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CharUtil.IsUriSafeChar(System.Char)">
            <summary>
            Chars which can be used in an URI without escaping.
            RFC 1738.4, but don't include escape chars like '+'
            </summary>
        </member>
        <member name="F:JetBrains.Util.CharUtil.UriSafeAsciiChars">
            <summary>
            Chars which can be used in an URI without escaping.
            RFC 1738.4, but don't include escape chars like '+'
            </summary>
        </member>
        <member name="T:JetBrains.Util.TextStreamReader">
            <summary>Uses one character to represent new line.</summary>
        </member>
        <member name="T:JetBrains.Util.TextStringReader">
            <summary>Uses one character to represent new line.</summary>
        </member>
        <member name="T:JetBrains.Util.Uuid">
            <summary>
            Implementation of RFC 4122 - A Universally Unique Identifier (UUID) URN Namespace.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Uuid.NewUuid(System.Guid,System.String)">
            <summary>
            Creates a version 5 name-based UUID.
            </summary>
            <param name="namespaceGuid">The namespace UUID.</param>
            <param name="value">The value.</param>
            <returns>The UUID for the given namespace and value.</returns>
        </member>
        <member name="M:JetBrains.Util.Version2.ToVersion4WithMinusOnes">
            <summary>
            <see cref="P:System.Version.Major"/> and <see cref="P:System.Version.Minor"/> are taken from this version, and <see cref="P:System.Version.Build"/> and <see cref="P:System.Version.Revision"/> are set to <c>-1</c>. The resulting version object has only two components defined, and renders as <c>x.y</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Version2.ToVersion4WithZeros">
            <summary>
            <see cref="P:System.Version.Major"/> and <see cref="P:System.Version.Minor"/> are taken from this version, and <see cref="P:System.Version.Build"/> and <see cref="P:System.Version.Revision"/> are set to <c>0</c>. The resulting version object has all four components defined, and renders as <c>x.y.0.0</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.DeleteFile(JetBrains.Util.FileSystemPath)">
            <summary>
            Does not fail if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.Unblock(JetBrains.Util.FileSystemPath)">
            <summary>
            Remove NTFS stream with sandboxing data.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.DeleteFile(JetBrains.Util.FileSystemPath,System.Boolean@,System.Int32)">
            <summary>
            Does not fail if there is no such file.
            </summary>
            <param name="thіs"></param>
            <param name="isDirectory">return true if it is a directory</param>
            <param name="nAttempts"></param>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.DeleteDirectoryNonRecursive(JetBrains.Util.FileSystemPath,System.Int32,System.Exception@)">
            <summary>
            Deletes just an empty directory.
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetLongPath(JetBrains.Util.FileSystemPath)">
            <summary>
            Expands short name components in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetShortPath(JetBrains.Util.FileSystemPath)">
            <summary>
            Shrinks name components to their short form in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetExists(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets whether this path exists in the file system, and whether it is a directory or a file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetInfo(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets various information about file or directory in one system call. Throws on I/O errors.
            </summary>
            <returns>File/directory information if entity exists, null if not</returns>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileModificationTimeUtc(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the last write time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileCreationTimeUtc(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the creation time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileLastAccessedTimeUtc(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the last accessed time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileAccessPath(JetBrains.Util.FileSystemPath)">
            <summary>
            Special path for passing to Windows API functions
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemPathUtils.GetGuidVolumeRootPath(System.Char)">
            <summary>
            Where <paramref name="drive" /> is a drive letter, gets the volume GUID path for it, e.g. <c>\\?\Volume{DD6AB3D2-C882-4293-BC64-53BFCC07B2B4}</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.XmlHtmlNamedCharacterReferences">
            <summary>
            Lists XML Character Entity / HTML named characters. Includes known names from HTML 5.1 preview as of 2014-07-30, http://www.w3.org/html/wg/drafts/html/master/syntax.html#named-character-references.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlHtmlNamedCharacterReferences.EscapeXmlStandard">
            <summary>
            The chars usually escaped in generic XML/HTML.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlHtmlNamedCharacterReferences.EscapeXmlStandardAndControlChars">
            <summary>
            The chars usually escaped in generic XML/HTML, plus ASCII control characters [0..32).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferences.RenderHashTable">
            <summary>
            Called by hand to read the <see cref="M:JetBrains.Util.XmlHtmlNamedCharacterReferencesOriginalDictionary.CreateXmlHtmlNamedCharacterReferencesDictionary"/> dictionary (which is too heavy to make on startup).
            Produces the BLOBs for <see cref="T:JetBrains.Util.XmlHtmlNamedCharacterReferencesOriginalDictionary"/> out of it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferences.TryGetNamedReferenceBySingleChar(System.Char)">
            <summary>
            For entities which have a value fitting within a single UTF16 character, maps such characters to some of the alternative entity names.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferences.TryGetValueForCharacterReference(JetBrains.Util.dataStructures.Sources.StringSource,System.Char@,System.Char@)">
            <summary>
            Tries to look up a named reference by its name.
            </summary>
            <param name="name">Name.</param>
            <param name="ch1">The first char of the UTF-16LE value string, or NULL if not found.</param>
            <param name="ch2">The second char of the UTF-16LE value string, or NULL if not so long or not found.</param>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.AssertAtElement(System.Xml.XmlReader,System.String)">
            <summary>
            Asserts that the reader is currently at the element with the specific name. Advances before throwing to avoid endless child loops.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.KeepDepth(System.Xml.XmlReader,System.Action)">
            <summary>
            <para>Makes sure the reader is at the same node depth after executing the <paramref name="action">nested code</paramref> as before running it. Throws if the nested code pops out of the orignal level.</para>
            <para>Note: this is a lightweight alternative to <see cref="M:System.Xml.XmlReader.ReadSubtree"/>. Use the latter to get maximum stability.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.KeepParentDepth(System.Xml.XmlReader,System.Action)">
            <summary>
            <para>After executing the <paramref name="action">nested code</paramref>, makes sure the depth level is that of the parent of the orignial element (one depth level up). Throws if the nested code pops out of the limiting level.</para>
            <para>Note: this is a lightweight alternative to <see cref="M:System.Xml.XmlReader.ReadSubtree"/>. Use the latter to get maximum stability.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadElement(System.Xml.XmlReader,System.Action{System.Xml.XmlReader})">
            <summary>
            Creates a new reader that scopes the current element only. <paramref name="funcElem"/> cannot proceed past the current element on its reader, as the reader will report end-of-stream. After this function exits, the outer <paramref name="reader"/> is positioned on the next node after the element it was called on.
            The reader of the <paramref name="funcElem"/> is initially positioned on the same element.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadElementChildren(System.Xml.XmlReader,System.Action{System.Xml.XmlReader})">
            <summary>
            <para>Enters the current element, scans through all of its children, and calls <see cref="!:funcChild"/> for each of the first-level child elements.</para>
            <para>Must be called on an element (use <see cref="M:JetBrains.Util.XmlReaderEx.ReadToElementStart(System.Xml.XmlReader)"/> if needed).</para>
            <para><paramref name="funcChild"/> must do at least one read operation on the <see cref="!:reader"/>, otherwise the reader could enter an endless loop. It is not necessary to read all of the child content, or return to the original depth level.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadSiblingElements(System.Xml.XmlReader,System.Action{System.Xml.XmlReader})">
            <summary>
            <para>On the current depth level, scans through all of the elements, and calls <see cref="!:funcElem"/> for each of the same-level elements.</para>
            <para><paramref name="funcElem"/> must do at least one read operation on the <see cref="!:reader"/>, otherwise the reader could enter an endless loop. It is not necessary to read all of the element content, or return to the original depth level.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadToElementStart(System.Xml.XmlReader)">
            <summary>
            Reads up to the opening tag of an element on the same level as the current reader position. Returns whether such an element could be found.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadToElementStart(System.Xml.XmlReader,System.Int32)">
            <summary>
            Reads up to the opening tag of an element on the specified depth level. Returns whether such an element could be found.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.KeepReaderDepthCore(System.Xml.XmlReader,System.Action,System.Int32)">
            <summary>
            Impl for <see cref="M:JetBrains.Util.XmlReaderEx.KeepDepth(System.Xml.XmlReader,System.Action)"/> and <see cref="M:JetBrains.Util.XmlReaderEx.KeepParentDepth(System.Xml.XmlReader,System.Action)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadXml(System.IO.Stream,System.Action{System.Xml.XmlReader})">
            <summary>
            Creates a reader over the stream. Does not close the stream by default.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.ReadXml(System.IO.Stream,System.Xml.XmlReaderSettings,System.Action{System.Xml.XmlReader})">
            <summary>
            Creates a reader over the stream. Does not close the stream by default.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.AddLineColumnData(System.Xml.IXmlLineInfo,System.Exception)">
            <summary>
            Adds the current line-column of the XML parser position (if this information is available on the parser).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlReaderEx.AddLineColumnData(System.Xml.XmlReader,System.Exception)">
            <summary>
            Adds the current line-column of the XML parser position (if this information is available on the parser).
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeXmlStandard">
            <summary>
            The chars usually escaped in generic XML/HTML.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeXmlStandardAndControlChars">
            <summary>
            The chars usually escaped in generic XML/HTML, plus ASCII control characters [0..32).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.CreateAttributeWithNonEmptyValue(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            Creates attribute only if passed value is not empty
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.CreateAttributeWithNonEmptyValueFluent(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            A fluent version of <see cref="M:JetBrains.Util.XmlUtil.CreateAttributeWithNonEmptyValue(System.Xml.XmlElement,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.CreateAttributeWithValueFluent(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            A fluent version of <see cref="M:JetBrains.Util.XmlUtil.CreateAttributeWithValue(System.Xml.XmlElement,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,System.Char[])">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
            <param name="text">The text to test.</param>
            <param name="charsToEscape">The characters to be escaped. NULL to use the default set for XML escaping, or any custom collection.</param>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,JetBrains.Util.XmlUtil.EscapeChars)">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,JetBrains.Util.RangeTranslator@,System.Char[])">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
            <param name="text">The text to test.</param>
            <param name="charsToEscape">The characters to be escaped. NULL to use the default set for XML escaping, or any custom collection.</param>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,System.Boolean,JetBrains.Util.RangeTranslator@,JetBrains.Util.XmlUtil.EscapeChars)">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.ShouldEscape(System.String,System.Char[])">
            <summary>
            Checks if a string should be XML-escaped.
            </summary>
            <param name="text">The text to test.</param>
            <param name="charsToEscape">The characters to be escaped. NULL to use the default set for XML escaping, or any custom collection.</param>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.ShouldEscape(System.String,JetBrains.Util.XmlUtil.EscapeChars)">
            <summary>
            Checks if a string should be XML-escaped.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.UnescapeXmlString(JetBrains.Util.StringSlice)">
            <summary>
            Runs on a string slice, non-allocating if there're no actual unescapes to be made.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.UnescapeXmlStringDelegate">
            <summary>
            The unescaper string processing function, to be used with <see cref="M:JetBrains.Util.StringSlice.ProcessString(JetBrains.Util.StringSlice.ProcessStringDelegate)"/>.
            The context should hold a copy of the original string, for lookups.
            Returns a string builder with the new unescaped text, if unescaping were needed; or <c>NULL</c>, which means the original string should be presented as the unescaping result.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.OwnerDocumentNonNull(System.Xml.XmlNode)">
            <summary>
            Replaces <see cref="P:System.Xml.XmlNode.OwnerDocument"/>, always yields non-NULL, throws if NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.ParentNodeNonNull(System.Xml.XmlNode)">
            <summary>
            Replaces <see cref="P:System.Xml.XmlNode.ParentNode"/>, always yields non-NULL, throws if NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.OuterXmlIndented(System.Xml.XmlElement)">
            <summary>
            Gets the markup representing this node and all its child nodes, just like <see cref="P:System.Xml.XmlNode.OuterXml"/>, but with all the formatting and indenting of <see cref="P:JetBrains.Util.XmlWriterEx.WriterSettings"/> applied (<see cref="P:System.Xml.XmlNode.OuterXml"/> renders content as one line of text).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.GetChildElements(System.Xml.XmlNode)">
            <summary>
            Return all child <see cref="T:System.Xml.XmlElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.GetChildElements(System.Xml.XmlNode,System.String)">
            <summary>
            Return all child <see cref="T:System.Xml.XmlElement"/> with specified name.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeChars.CharsToEscape">
            <summary>
            The characters which explicitly should be escape.
            If you specify no characters, this list won't work, there's no fallback assumed here.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeChars.AllowedRangeMin">
            <summary>
            Allows to limit the charset. Set both ends to <c>0</c> to set no range limit.
            If nonzero, defines the lowest allowed UTF-16 char code, inclusively.
            Note that 
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeChars.AllowedRangeMax">
            <summary>
            Allows to limit the charset. Set both ends to <c>0</c> to set no range limit.
            If nonzero, defines the highest allowed UTF-16 char code, inclusively.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.CtxUnescape.OriginalText">
            <summary>
            A copy of the original text.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.CtxUnescape.UserDefinedOutputStringBuilder">
            <summary>
            If the user wants the output written into a string builder (regardless of whether there were escaping or not), pass it here.
            If <c>NULL</c>, a new one will be created on-demand and returned, or a <c>NULL</c> return value means that no escaping were needed.
            </summary>
        </member>
        <member name="T:JetBrains.Util.StringEncryption">
            <summary>
            StringEncryption is a wrapper of System.Security.Cryptography.SymmetricAlgorithm classes
            and simplifies the interface. It supports customized SymmetricAlgorithm as well.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringEncryption.#ctor(JetBrains.Util.StringEncryption.StringEncryptionMethod)">
            <remarks>
            Constructor for using an intrinsic .Net SymmetricAlgorithm class.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.StringEncryption.#ctor(System.Security.Cryptography.SymmetricAlgorithm)">
            <remarks>
            Constructor for using a customized SymmetricAlgorithm class.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.StringEncryption.GetLegalKey(System.String)">
            <remarks>
            Depending on the legal key size limitations of a specific CryptoService provider
            and length of the private key provided, padding the secret key with space character
            to meet the legal size of the algorithm.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.StringEncryption.StringEncryptionMethod">
            <remarks>
            Supported .Net intrinsic SymmetricAlgorithm classes.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.Attr``1(``0,System.String,System.Object)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.AttrNs``1(``0,System.String,System.String,System.Object)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.CreateWriter(System.IO.Stream)">
            <summary>
            Creates a writer over the stream with readability-friendly settings (<see cref="P:JetBrains.Util.XmlWriterEx.WriterSettings"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.Element(System.Xml.XmlWriter,System.String,System.String)">
            <summary>
            Writes an element string, mostly as <see cref="T:System.Xml.XmlWriter"/>, but supports special notation for <paramref name="name"/> to also specify the namespace in the form <c>xmlns::localname</c>, eg <c>"urn:shemas-jetbrains-com:all-assemblies-xml::AllAssemblies"</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.InElement(System.Xml.XmlWriter,System.String,System.Action,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            Supports special notation for <paramref name="name"/> to also specify the namespace in the form <c>xmlns::localname</c>, eg <c>"urn:shemas-jetbrains-com:all-assemblies-xml::AllAssemblies"</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.InElementNs(System.Xml.XmlWriter,System.String,System.String,System.Action,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.PushElement(System.Xml.XmlWriter,System.String,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.PushElementNs(System.Xml.XmlWriter,System.String,System.String,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.WriteXml(System.IO.Stream,System.Action{System.Xml.XmlWriter})">
            <summary>
            Creates a writer over the stream with readability-friendly settings (<see cref="T:System.Xml.XmlUtf8RawTextWriterIndent"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.WriteXml(System.IO.Stream,System.Xml.XmlWriterSettings,System.Action{System.Xml.XmlWriter})">
            <summary>
            Creates a writer over the stream with user-supplied settings.
            </summary>
        </member>
        <member name="P:JetBrains.Util.XmlWriterEx.WriterSettings">
            <summary>
            Default settings for an XML Writer.
            </summary>
        </member>
        <member name="T:JetBrains.Util.PlatformUtilUnix">
            <summary>
            A separate class so that JITting the main <see cref="T:JetBrains.Util.PlatformUtil"/> class does not cause actually trying to load types from the mono-posix assembly on winnt.
            </summary>
        </member>
        <member name="F:JetBrains.Util.WaveInfoEx.BaseMajorForWavedAssemblyVersion">
            <seealso cref="M:JetBrains.Util.WaveInfoEx.GetDefaultAssemblyVersion(JetBrains.Util.WaveInfo)"/>
        </member>
        <member name="M:JetBrains.Util.WaveInfoEx.GetDefaultAssemblyVersion(JetBrains.Util.WaveInfo)">
            <summary>
            The default assembly version for such assemblies that have not been assigned a manual version.
            (100 + wave number) in major, 0 in minor.
            </summary>
        </member>
    </members>
</doc>
