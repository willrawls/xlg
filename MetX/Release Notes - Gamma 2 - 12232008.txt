Gamma 2 is mostly just a clean up. 
   I'd recommend creating C:\data\code\xlg and getting the trunk to that folder. 
   If you put it somewhere else, let me know if anything breaks and what you did to correct it.

Then you can run the actual code generator "XLG Pipeliner" by running the shortcut:
    C:\data\code\xlg\MetX\XLG Pipeliner.lnk

Or directly by running the Debug version of XLG Pipeliner at:
   C:\data\code\xlg\bin\xlgPipeliner.exe

Create a new xlgs file (xlg settings file defining a series of code generation steps)
Click "Add Step" and enter the name of the connection you wish to generate a DAL for.
Note that the name you enter will become both the namespace for the entire DAL and the connectionString's "key" attribute from the web/app config.
By default it will assume you want to do a SqlClient gen, but you can change that after the step is added (there's a dropdown that controls what kind of meta data is being walked).
There are 6 providers. 3 data providers (SqlClient, Sybase.Data, and MySql.Data), and 3 "gather" providers.
All 3 data providers work, but if you're using a different version of one of the drivers you'll need to recompile the appropriate provider project with your updated driver.
The PowerShell gather provider isn't working right now (not coded except stubbed out).
The command line gather provider works great, but I need to do some more work on the interface to make it more intuitive.
Output goes to a new folder with the same name as the database connection key as a sub folder typically in 
     C:\data\code\xlg\DAL\

Once you're ready, click "Gen" and off it goes. If all goes well, you'll wind up with a compilable C# project in the DAL sub folder you selected and can begin exploring the layer of code generated for you. Each table and each index get objects and there is currently no built in support for relationship mapping. Technically it can be done with just a (significant) change to the C# DALXSL template.

--------------------------------------

Ok, so now you can open the generated project and compile. Note that when you Gen or Regen all the .Glove.cs files are overwritten. However, the csproj file will only be created once, so if you make changes to the project, they will NOT be overwritten (see the XSL template to see the custom xsl function(s) that make this possible as it's a taste of things to come).

So, let's say you've got a database connection named "FRED" and in that database you have a table name "People" with columns: FirstName, LastName, Address, City, State, Zip, DateCreated, DateModified, Comment. 

You'll wind up with the FRED namespace a People object (with one property per column), a PeopleCollection object, and a fair number of static methods delivering a wide variety of functionality. 

For instance, assuming all the columns in the People table are individually indexed (what I call uber indexing), then you can load all People records in New York with this line of code:

*FRED.PeopleCollection NewYorkers = Fred.People.Index.State.Select("NY");*

People.Index is a static object with one static sub object per table index (including multi-column indexes). 

Modifying the first new yorker is as simple as:

*FRED.People CurrItem = NewYorkers[0];*
*CurrItem.Comment = "Very easy";*

At this point you can either save the record at the record or collection of record level with either

*CurrItem.Save()*
  Or
*NewYorkers.SaveIfChanged()*

As its name implies SaveIfChanged() only saves records with at least one value changed.

I've written the templates so that if the table has a DateCreated and/or a DateModified date/time field then those values will authomatically be populated and maintained for you.
Likewise, if there's a CreatedBy and/or a ModifiedBy field, they will be automatically maintained with the value passed to any of the Save(UserName) or SaveIfChanged(UserName) methods.

I'm overly fond of XML(obviously) and XSL, which is of course, why I think a code generator based on open standards (XML and XSL) trumps any proprietary implementation.
Additionally, I've brought some interesting ideas to the DAL layer (perhaps too many, but too much code is a nice problem instead of not enough).

All of the objects can be serialized and deserialized to XML. 

For instance, you can get an XML node representing the new yorker above with:

*CurrItem.OuterXml()* returns a <People> node representing that record with one attribute per field.
Likewise a static method can be used to get a new instance of a People object from a <People /> node with
*CurrItem = FRED.People.FromXml("<People FirstName='John' />");*

Additionally, collections can be handled the same way:

*MessageBox.Show(NewYorkers.OuterXml())*

There are a lot of other useful methods like:

*People.Create*
*People.CreateAndSave*
*CurrItem.UpdateAndSave*
*CurrItem.Load* (for use with data readers and data sets)
*People.Columns*

Plus useful aggregation and filtering commands for Max, Min, Count, and
*FRED.PeopleCollection MatchingZip = NewYorkers.DistinctZip(zipFilter);*
*FRED.PeopleCollection ManhattenPeople = People.FindAllCity("NYC");*

And much more. 95%+ of the generated functions have XML comments, so exploring should be easy.

What if there's a function you want for each table (or field) or you just don't like the way I did something?
I've tried very hard to make 99%+ of the code actually generated controlled by the XSL template that drives a step and tried to put as much information about the structure of a database in the XML as I could.
The XML built up by the step is written to a file in the same folder as the code generated.

So if you don't like something or have a great new set of functions to add, you've got control and can modify the XSL templates to your heart's content.
Please share your changes by starting a discussion. (especially fixes, although there shouldn't be too many of those left as I've been using and honing these templates for a couple years now).

I have several more things to add to XLG over the next year or two. I hope you'll take it upon yourself to add some and share it with everyone, even a complete replacement XSL template would be VERY welcome.

In fact, I've included several working and several example templates in:
     C:\data\code\xlg\Support\

* CSharp DAL.xlg.xsl
** This is the XSLT that generates the DAL layer I described above. 

* CSharp DAL Project File.xlg.xsl
** Not used as it got merged into CSharp DAL.xlg.xsl (I wound up needing it all the time) but still an interesting example... Not saying it's good.

* Mail Log.xlg.xsl
** I needed to parse out the SQL Server 2005 Database Mail logs to do some analysis.
** So here's an example where I'm generating a web page from SQL XML.

** There's a whole line of things I want to do here, but more on that when I've actually done it.
** Still this should give you an idea of how flexible the pipeline generation concept is. 

* Simple ASPX Grid.xlg.xsl
** This is designed for use with a database like the DAL is except here we're generating "scaffolding" like shell web pages with simple grid access and a default page with links to all the grids (one grid per table).
** This concept could really be flushed out.
 
* Simple Web Page.xlg.xsl
** Also designed for use with database structure, this template generates a single HTML file creating a bulleted list of tables and field names.
** This could be significantly enhanced to basically document a database 
** Or with a new XML to XML XSLT this could funnel information as you want it into XML based UML or other systems.

* Simple File System.xlg.xsl
** This is for use with the *MetX.Gather.FileSystem* provider
** The FileSystem gather provider walks the folder specified in the Connection Name field,
** Outputs the result into the Target XML file,
** And then calls the XSL Template and outputs to the Output file.
** Simple File System just generates a quick HTML file and can be used as the basis for many templates (more once I add more xsl commands).

* Uber Indexing.xlg.xsl
** This is a database template that outputs T-SQL
** It simply walks through the database structure and outputs a CREATE NONCLUSTERED INDEX for each column that is not currently indexed.
** I did this because I wanted a quick way to be able to generated the static .Index classes (and I don't mind burning hard drive space).
** Obviously I don't recommend indexing every column in every table, but it's nice to again have too much code rather than not enough. 
** Each index is named according to my convention and it's way easier to let the computer type everything right rather than me.

I've taken pains to limit the exposure of the database drivers making it so that if you only use one database driver, you'll only need the one provider (which doubles in my DAL as both the database XML generator and the actual data provider at runtime).

One final thing. It's a whole subject unto itself, but you'll notice that there is a MetX.dll at the heart of everything. 
Code generated as it stands is highly dependent on this library. You can of course unmarry it with your own templates.

That said, MetX.dll has a host of features unto itself (including the heart of the code generator). But for this release, I'll just say that the XSL templates that generate code use XSL extensions.
These commands are implemented in the *MetX.Urn.xlgUrn* object and demonstrates a plethera of ways you can extend basic XSL 1.0 in the XSL templates.
Additionally, because I wanted a single XSL template to be able to generate many C# files, XLG uses the excellent open source *nxslt2.exe*, mostly to get access to it's <exsl:document /> tag. 

nxlst2 (a .net 2.0 command line utility and referencible library) is documented elsewhere on the web and offers it's own host of extention functions (not the least of which is the entire EXSLT library).
* http://www.xmllab.net/Products/nxslt2/tabid/73/Default.aspx

Everything inside the exsl:document tag is output to the file specified in the href attribute (which has a slightly special syntax):

<exsl:document href="{$AssemblyInfoFile}" method="text" omit-xml-declaration="yes">
...
</exsl:document>

Put that inside a <xsl:for-each> and you've got a great way to generate many files.

The XLG extension functions are more geared toward code generation and file modification tasks. 
Future versions of XLG will also allow direct user interaction.

The following few XSL lines show a few of the xlg: extension functions off, 
most notably xlg:CreateDirectory() and xlg:FileExists()

  <xsl:variable name="OutputFolder" select="/xlgDoc/@OutputFolder" />
	<xsl:variable name="ProjectFile"><xsl:value-of select="concat($OutputFolder,$Namespace)"/>.csproj</xsl:variable>
	<xsl:variable name="PropertiesFolder"><xsl:value-of select="$OutputFolder"/>Properties\</xsl:variable>
	<xsl:variable name="AssemblyInfoFile"><xsl:value-of select="$PropertiesFolder"/>AssemblyInfo.cs</xsl:variable>
	<xsl:value-of select="xlg:CreateDirectory($PropertiesFolder)" />
	<xsl:if test="not(xlg:FileExists($AssemblyInfoFile))">



Ok. That's way too much, but there was a lot to touch on and if you've gotten this far, then I look forward to possibly working with you to make XLG a new standard in cross-platform, open source code generation 
(I had it compiling in MONO, not sure if it still does).
I hope this has been helpful. 
Feel free to send me your questions, concerns, errors (make sure you give me enough detail and steps to reproduce), new templates, suggestions for template enhancements, etc.
