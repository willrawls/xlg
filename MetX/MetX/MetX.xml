<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MetX</name>
    </assembly>
    <members>
        <member name="T:MetX.Data.ActiveRecord">
            <summary>
            Base class for persisting objects. Follows the "Active Record Design Pattern".
            You can read more on this pattern at http://en.wikipedia.org/wiki/Active_Record
            </summary>
        </member>
        <member name="T:MetX.Data.Aggregate">
            <summary>
            Creates an aggregate function call for ANSI SQL
            </summary>
        </member>
        <member name="T:MetX.Data.AggregateFunction">
            <summary>
            Enum for General SQL Functions
            </summary>
        </member>
        <member name="T:MetX.Data.Comparison">
            <summary>
            SQL Comparison Operators
            </summary>
        </member>
        <member name="M:MetX.Data.DataProvider.ToXml(System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="sql">The SQL to convert to an xml string</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="M:MetX.Data.DataProviderCollection.Add(System.Configuration.Provider.ProviderBase)">
            <param name="provider">C#CD: </param>
        </member>
        <member name="M:MetX.Data.DataService.GetDataService(System.String)">
            <summary>
            Typically called from DAL code.
            </summary>
            <param name="connectionStringName"></param>
            <returns></returns>
        </member>
        <member name="M:MetX.Data.DataService.GetDataServiceManually(System.String,System.String,System.String)">
            <summary>
            Typically used to generate code when an app.config or web.config isn't available or desired.
            </summary>
            <param name="connectionStringName"></param>
            <param name="connectionString"></param>
            <param name="providerName"></param>
            <returns></returns>
        </member>
        <member name="M:MetX.Data.DataService.GetReader(MetX.Data.QueryCommand)">
            <summary>
            Returns an IDataReader using the passed-in command
            </summary>
            <param name="cmd">C#CD: </param>
            <returns>IDataReader</returns>
        </member>
        <member name="M:MetX.Data.DataService.GetStoredProcedureResult(MetX.Data.QueryCommand)">
            <summary>
            Returns an IDataReader using the passed-in command
            </summary>
            <param name="cmd">C#CD: </param>
            <returns>IDataReader</returns>
        </member>
        <member name="M:MetX.Data.DataService.ToDataSet(MetX.Data.QueryCommand)">
            <summary>
            Returns a DataSet based on the passed-in command
            </summary>
            <param name="cmd">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.ExecuteScalar(MetX.Data.QueryCommand)">
            <summary>
            Returns a scalar object based on the passed-in command
            </summary>
            <param name="cmd">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.ExecuteQuery(MetX.Data.QueryCommand)">
            <summary>
            Executes a pass-through query on the DB
            </summary>
            <param name="cmd">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetTableSchema(System.String)">
            <param name="tableName">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetTables">
            <returns>C#CD: Returns a sorted list of tables</returns>
        </member>
        <member name="M:MetX.Data.DataService.GetSpList">
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetForeignKeyTableName(System.String)">
            <param name="fkColumn">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetSpParams(System.String)">
            <param name="spName">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetDbType(System.String)">
            <param name="dataType">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetClientType">
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.DataService.GetIDbCommand(MetX.Data.QueryCommand)">
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="T:MetX.Data.Factory.SqlDataProvider">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.ExecuteQuery(MetX.Data.QueryCommand)">
            <summary>C#CD: </summary>
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.ExecuteScalar(MetX.Data.QueryCommand)">
            <summary>C#CD: </summary>
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetCommand(MetX.Data.QueryCommand)">
            <summary>C#CD: </summary>
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetDbType(System.String)">
            <summary>C#CD: </summary>
            <param name="sqlType">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetForeignKeyTableName(System.String)">
            <summary>C#CD: </summary>
            <param name="fkColumnName">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetReader(MetX.Data.QueryCommand)">
            <summary>C#CD: </summary>
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetSpList">
            <summary>C#CD: </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetSpParams(System.String)">
            <summary>C#CD: </summary>
            <param name="spName">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetStoredProcedureResult(MetX.Data.QueryCommand)">
            <summary>C#CD: </summary>
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetTableList">
            <summary>C#CD: </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.GetTableSchema(System.String)">
            <summary>C#CD: </summary>
            <param name="tableName">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.OuterXml(System.Text.StringBuilder,System.String,System.String,System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="output">The StringBuilder to output xml into</param>
            <param name="tagName">The element name to wrap the returned xml element(s). If null or blank, no tag wraps the returned xml string</param>
            <param name="tagAttributes">The attributes to add to the TagName element</param>
            <param name="sql">The SQL to convert to an xml string</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.ToDataSet(MetX.Data.QueryCommand)">
            <summary>C#CD: </summary>
            <param name="qry">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Factory.SqlDataProvider.ToXml(System.String,System.String,System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="tagName">The element name to wrap the returned xml element(s). If null or blank, no tag wraps the returned xml string</param>
            <param name="tagAttributes">The attributes to add to the TagName element</param>
            <param name="sql">The SQL to convert to an xml string</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="T:MetX.Data.OrderBy">
            <summary>
            Creates an ORDER BY statement for ANSI SQL
            </summary>
        </member>
        <member name="T:MetX.Data.Query">
            <summary>
            Creates a SQL Statement and SQL Commands
            </summary>
        </member>
        <member name="M:MetX.Data.Query.GetComparisonOperator(MetX.Data.Comparison)">
            <summary>
            Takes the enum value and returns the proper SQL
            </summary>
            <param name="comp"></param>
            <returns></returns>
        </member>
        <member name="M:MetX.Data.Query.AddInnerJoin(System.String,System.String,System.String)">
            <summary>C#CD: </summary>
            <param name="toTableName">C#CD: </param>
            <param name="fromColumnName">C#CD: </param>
            <param name="toColumnName">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddInnerJoin(System.String)">
            <summary>C#CD: </summary>
            <param name="toTableName">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddAggregate(System.String,MetX.Data.AggregateFunction,System.String)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
            <param name="func">C#CD: </param>
            <param name="alias">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddAggregate(MetX.Data.Aggregate)">
            <summary>C#CD: </summary>
            <param name="agg">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.BeginParen">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.Query.EndParen">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.Query.AddWhere(MetX.Data.Where)">
            <summary>C#CD: </summary>
            <param name="where">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddWhere(System.String,System.Object)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
            <param name="paramValue">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddWhere(System.String,System.String,System.Object)">
            <summary>C#CD: </summary>
            <param name="tableName">C#CD: </param>
            <param name="columnName">C#CD: </param>
            <param name="paramValue">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddWhere(System.String,MetX.Data.Comparison,System.Object)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
            <param name="comp">C#CD: </param>
            <param name="paramValue">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.AddWhere(System.String,System.String,MetX.Data.Comparison,System.Object)">
            <summary>C#CD: </summary>
            <param name="tableName">C#CD: </param>
            <param name="columnName">C#CD: </param>
            <param name="comp">C#CD: </param>
            <param name="paramValue">C#CD: </param>
        </member>
        <member name="M:MetX.Data.Query.BuildSelectCommand">
            <summary>
            Creates a SELECT command based on the Query object's settings.
            If you need a more complex query you should consider using a Stored Procedure
            </summary>
        </member>
        <member name="M:MetX.Data.Query.BuildDeleteCommand">
            <summary>
            Builds a Delete command based on a give WHERE condition
            </summary>
        </member>
        <member name="M:MetX.Data.Query.BuildUpdateCommand">
            <summary>
            Builds an update query for this table with the passed-in hash values
            </summary>
        </member>
        <member name="M:MetX.Data.Query.GetSelectSql">
            <summary>
            Creates a SELECT statement based on the Query object settings
            </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Query.GetUpdateSql">
            <summary>C#CD: </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Query.GetInsertSql">
            <summary>
            Loops the TableColums[] array for the object, creating a SQL string
            for use as an INSERT statement
            </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Query.GetDeleteSql">
            <summary>C#CD: </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Query.ExecuteReader">
            <summary>
            Returns an IDataReader using the passed-in command
            </summary>
            <returns>IDataReader</returns>
        </member>
        <member name="M:MetX.Data.Query.ExecuteDataSet">
            <summary>
            Returns a DataSet based on the passed-in command
            </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Query.ExecuteScalar">
            <summary>
            Returns a scalar object based on the passed-in command
            </summary>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.Query.Execute">
            <summary>
            Executes a pass-through query on the DB
            </summary>
        </member>
        <member name="T:MetX.Data.QueryType">
            <summary>C#CD: </summary>
        </member>
        <member name="F:MetX.Data.QueryType.Select">
            <summary>SELECT FROM query</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Update">
            <summary>UPDATE query</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Insert">
            <summary>INSERT INTO query</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Delete">
            <summary>DELETE FROM query</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Exists">
            <summary>IF EXISTS(query) SELECT 1 ELSE SELECT 0</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Count">
            <summary>SELECT COUNT(*) FROM query</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Max">
            <summary>SELECT MAX(*) FROM query</summary>
        </member>
        <member name="F:MetX.Data.QueryType.Min">
            <summary>SELECT MIN(*) FROM query</summary>
        </member>
        <member name="T:MetX.Data.TableSchema">
            <summary>C#CD: </summary>
        </member>
        <member name="T:MetX.Data.TableSchema.Table">
            <summary>
            Holds information about the base table - this class should be
            static for each object
            </summary>
        </member>
        <member name="F:MetX.Data.TableSchema.Table.FieldList">
            <summary>The field list as it goes into the SELECT sql statement used for Select, Count, Exists and paging type queries</summary>
        </member>
        <member name="F:MetX.Data.TableSchema.Table.InsertSql">
            <summary>The basic INSERT INTO sql statement used for Insert type queries</summary>
        </member>
        <member name="F:MetX.Data.TableSchema.Table.UpdateSql">
            <summary>The basic UPDATE sql statement used for Update type querie</summary>
        </member>
        <member name="M:MetX.Data.TableSchema.Table.#ctor">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.TableSchema.Table.#ctor(System.String,System.String)">
            <summary>C#CD: </summary>
            <param name="tableName">C#CD: </param>
            <param name="schemaName"></param>
        </member>
        <member name="P:MetX.Data.TableSchema.Table.SelectSql">
            <summary>The basic SELECT sql statement used for Select, Count, Exists and paging type queries</summary>
        </member>
        <member name="T:MetX.Data.TableSchema.TableColumn">
            <summary>
            A helper class to help define the columns in an underlying table
            </summary>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumn.#ctor">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumn.#ctor(System.String,System.Data.DbType,System.Boolean,System.Boolean)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
            <param name="dbType">C#CD: </param>
            <param name="isPrimaryKey">C#CD: </param>
            <param name="IsForiegnKey">C#CD: </param>
        </member>
        <member name="T:MetX.Data.TableSchema.TableColumnCollection">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumnCollection.Add(System.String,System.Data.DbType,System.Boolean,System.Boolean,System.Boolean)">
            <summary>C#CD: </summary>
            <param name="name">C#CD: </param>
            <param name="dbType">C#CD: </param>
            <param name="isNullable">C#CD: </param>
            <param name="isPrimaryKey">C#CD: </param>
            <param name="IsForiegnKey">C#CD: </param>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumnCollection.Add(System.String,System.Data.DbType,System.Boolean)">
            <summary>C#CD: </summary>
            <param name="name">C#CD: </param>
            <param name="dbType">C#CD: </param>
            <param name="isNullable">C#CD: </param>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumnCollection.GetColumn(System.String)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumnCollection.GetPrimaryKey">
            <summary>C#CD: </summary>
        </member>
        <member name="T:MetX.Data.TableSchema.TableColumnSetting">
            <summary>
            This is an intermediary class that holds the current value of a table column
            for each object instance.
            </summary>
        </member>
        <member name="F:MetX.Data.TableSchema.TableColumnSetting._columnName">
            <summary>C#CD: </summary>
        </member>
        <member name="F:MetX.Data.TableSchema.TableColumnSetting._currentValue">
            <summary>C#CD: </summary>
        </member>
        <member name="P:MetX.Data.TableSchema.TableColumnSetting.ColumnName">
            <summary>C#CD: </summary>
        </member>
        <member name="P:MetX.Data.TableSchema.TableColumnSetting.CurrentValue">
            <summary>C#CD: </summary>
        </member>
        <member name="T:MetX.Data.TableSchema.TableColumnSettingCollection">
            <summary>C#CD: </summary>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumnSettingCollection.GetValue(System.String)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
            <returns>C#CD: </returns>
        </member>
        <member name="M:MetX.Data.TableSchema.TableColumnSettingCollection.SetValue(System.String,System.Object)">
            <summary>C#CD: </summary>
            <param name="columnName">C#CD: </param>
            <param name="oVal">C#CD: </param>
        </member>
        <member name="T:MetX.Data.Where">
            <summary>
            Creates a WHERE clause for a SQL Statement
            </summary>
        </member>
        <member name="T:MetX.IO.Email">
            <summary>
            Allows for the sending of a simple emamil asynchronously on another thread.
            </summary>
        </member>
        <member name="M:MetX.IO.Email.SendMail(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Allows for the quick and asynchronous sending of a simple email</summary>
            <param name="fromName">Display name of the person sending the email</param>
            <param name="fromEmail">From Email address</param>
            <param name="toName">Display name for the person receiving the email</param>
            <param name="toEmail">To Email Address</param>
            <param name="subject">Email Subject</param>
            <param name="body">Email Body (pure text)</param>
        </member>
        <member name="M:MetX.IO.Email.Send(System.Net.Mail.MailMessage)">
            <summary>
            Asynchronously sends a MailMessage
            </summary>
            <param name="mm">The MailMessage to send</param>
        </member>
        <member name="M:MetX.IO.Email.Start(System.Object)">
            <summary>Private function for sending the asychronous email on a new thread</summary>
        </member>
        <member name="T:MetX.IO.FileSystem">
            <summary>Helper functions for the file system</summary>
        </member>
        <member name="M:MetX.IO.FileSystem.CleanFilesOlderThan(System.Int32,System.String)">
            <summary>Deletes all files in a folder older than a certain number of minutes.</summary>
            <param name="minutes">
                The number of minutes ago the file must be created to be deleted. (So 5 means it must be at least
                5 minutes old to be deleted).
            </param>
            <param name="sPath">The folder to delete files from</param>
        </member>
        <member name="M:MetX.IO.FileSystem.CleanFoldersOlderThan(System.Int32,System.String)">
            <summary>Deletes all sub folders older than a certain number of minutes.</summary>
            <param name="minutes">
                The number of minutes ago a folder must be created to be deleted (So 5 means it must be at least
                5 minutes old to be deleted)
            </param>
            <param name="sPath">
                The path to retrieve delete sub folders for. NOTE: The path itself will not be removed. So passing
                "C:\X\Y" would delete "C:\X\Y\Z" (if it's more than 5 minutes old) but not "C:\X\Y" (no matter how old it is)
            </param>
        </member>
        <member name="M:MetX.IO.FileSystem.DeepCopy(System.IO.DirectoryInfo,System.IO.DirectoryInfo)">
            <summary>Copies the contents of a folder (including subfolders) from one location to another</summary>
            <param name="source">The path from which files and subfolders should be copied</param>
            <param name="dest">The path to which those files and folders should be copied</param>
            <returns>True if the operation was successful, otherwise an exception is thrown</returns>
        </member>
        <member name="M:MetX.IO.FileSystem.DeepContents(System.IO.DirectoryInfo)">
            <summary>
                Iterates the contents of a folder (including subfolders) generating an xml serializable object hierarchy along
                the way
            </summary>
            <param name="source">The path from which files and subfolders to iterate</param>
            <returns>True if the operation was successful, otherwise an exception is thrown</returns>
        </member>
        <member name="M:MetX.IO.FileSystem.DeepContents(MetX.Pipelines.XlgFolder,System.IO.DirectoryInfo)">
            <summary>
                Iterates the contents of a folder (including subfolders) generating an xml serializable object hierarchy along
                the way
            </summary>
            <param name="source">The path from which files and subfolders to iterate</param>
            <returns>True if the operation was successful, otherwise an exception is thrown</returns>
        </member>
        <member name="M:MetX.IO.FileSystem.FileToString(System.String)">
            <summary>Reads the entire contents of a file and returns it as a string</summary>
            <param name="filename">The path and filename to read</param>
            <returns>The contents of the file or a blank string if the file does not exist.</returns>
        </member>
        <member name="M:MetX.IO.FileSystem.StringToFile(System.String,System.String)">
            <summary>
                Writes a string to a file. If the file already exists, it will be deleted first (effectively overwriting the
                file)
            </summary>
            <param name="filename">The path and filename of the file to overwrite</param>
            <param name="fileContents">The contents of the file to write</param>
        </member>
        <member name="M:MetX.IO.FileSystem.ParentDir(System.String)">
            <summary>Given a path, it returns the parent folder (So for "C:\X\Y\Z", "C:\X\Y" would be returned.</summary>
            <param name="path">The path to find the parent for</param>
            <returns>The path of the parent directory</returns>
        </member>
        <member name="M:MetX.IO.FileSystem.GatherOutput(System.String,System.String,System.String,System.Int32)">
            <summary>
                Runs a command line, waits for it to finish, gathers it's output from strin and returns the output.
            </summary>
            <param name="filename">The filename to execute</param>
            <param name="arguments">Any (optional) arguments to pass to the executable</param>
            <param name="workingFolder">The folder that the executing environment should initially be set to</param>
            <param name="waitTime">
                The number of seconds to wait before killing the process. If the value is less than 1, 60
                seconds is assumed.
            </param>
            <returns>The strout/strerr output by the executable</returns>
        </member>
        <member name="T:MetX.IO.Http">
            <summary>Provides static methods to common web based tasks</summary>
        </member>
        <member name="M:MetX.IO.Http.GetUrl(System.String,System.String)">
            <summary>Makes an HTTP POST call returning the response (no headers)</summary>
            <param name="lcUrl">The Web address to post to</param>
            <param name="postData">The URL encoded data to send</param>
            <returns>The response text from the post (ASCII encoded).</returns>
        </member>
        <member name="M:MetX.IO.Http.GetUrl(System.String,System.Int32,System.String)">
            <summary>Makes an HTTP POST call returning the response (no headers)</summary>
            <param name="lcUrl">The Web address to post to</param>
            <param name="timeout">The maximum number of seconds to wait for a response</param>
            <param name="userAgent">The UserAgent header value to pass</param>
            <returns>The response text from the post (ASCII encoded)</returns>
        </member>
        <member name="M:MetX.IO.Http.GetUrl(System.String,System.Int32)">
            <summary>Makes an HTTP POST call returning the response (no headers)</summary>
            <param name="lcUrl">The Web address to post to</param>
            <param name="timeout">The maximum number of seconds to wait</param>
            <returns>The response text from the post (Windows default code page encoded).</returns>
        </member>
        <member name="M:MetX.IO.Http.GetUrl(System.String)">
            <summary>Makes an HTTP POST call returning the response (no headers)</summary>
            <param name="lcUrl">The Web address to post to</param>
            <returns>The response text from the post (Windows default code page encoded).</returns>
        </member>
        <member name="M:MetX.IO.Http.GetUrlByteArray(System.String)">
            <summary>Makes an HTTP POST call returning the response (no headers)</summary>
            <param name="lcUrl">The Web address to post to</param>
            <returns>The response text from the post (Windows default code page encoded).</returns>
        </member>
        <member name="T:MetX.IO.SmtpMail">
            <summary>
                Provides methods to send email via smtp, with out CDO SYS installed.
                <para>This is a manual implementation of the SMTP protocol.</para>
            </summary>
        </member>
        <member name="F:MetX.IO.SmtpMail.SmtpServer">
            <summary>Get or Set the name of the SMTP relay mail server</summary>
        </member>
        <member name="M:MetX.IO.SmtpMail.Send(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Send an Email</summary>
            <param name="fromName">The displayed name for the FROM address</param>
            <param name="fromEmail">The FROM address</param>
            <param name="toName">The displayed name for the TO address</param>
            <param name="toEmail">The TO address</param>
            <param name="subject">The SUBJECT for the email</param>
            <param name="body">The text body of the email</param>
            <returns>True if the email was sent</returns>
        </member>
        <member name="M:MetX.IO.SmtpMail.Send(System.Net.Mail.MailMessage)">
            <summary>Sends an email message</summary>
            <param name="message">The MailMessage to send</param>
            <returns>Returns true if the email was sent.</returns>
        </member>
        <member name="T:MetX.IO.Sql">
            <summary>Helper functions to simplify working with sql connections</summary>
        </member>
        <member name="M:MetX.IO.Sql.GetString(System.Data.SqlClient.SqlDataReader,System.Int32,System.String)">
            <summary>This returns the string representation of a column from a reader. Supports DBNull (default return value), guid, int, and datetime. All other types simply call GetString() on the reader.</summary>
            <param name="rst">The reader</param>
            <param name="index">The column to retreive as a string</param>
            <param name="defaultReturnValue">If the column is DBNull, this will be the return value</param>
            <returns>String representation of the field</returns>
            
            <example><c>GetString(reader, 0, "Something");</c>
            Retrieves field 0. If it's DbNull, the string "Something" will be returned. </example>
        </member>
        <member name="M:MetX.IO.Sql.GetString(System.Data.SqlClient.SqlDataReader,System.Int32)">
            <summary>This returns the string representation of a column from a reader. Supports DBNull (as an empty string), guid, int, and datetime. All other types simply call GetString() on the reader.</summary>
            <param name="rst">The reader</param>
            <param name="index">The column to retreive</param>
            <returns>String representation of the field</returns>
            
            <example><c>GetString(reader, 0);</c>
            Retrieves field 0. If it's DbNull, the string "" will be returned. </example>
        </member>
        <member name="M:MetX.IO.Sql.GetDateTime(System.Data.SqlClient.SqlDataReader,System.Int32)">
            <summary>This returns the DateTime representation of a column from a reader. Supports DBNull (as an empty string), guid, int, and datetime. All other types simply call GetDateTime() on the reader.</summary>
            <param name="rst">The reader</param>
            <param name="index">The column to retreive</param>
            <returns>String representation of the field</returns>
            
            <example><c>GetDateTime(reader, 0);</c>
            Retrieves field 0. If it's DbNull, DateTime.MinValue will be returned. </example>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleStringValue(System.String,System.String,System.String)">
            <summary>Returns the first value of the first row of the passed sql as a string. If DbNull is the value, DefaultReturnValue is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <param name="defaultReturnValue">The value to return when DbNull is encountered.</param>
            <returns>String value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleStringValue(System.String)">
            <summary>Returns the first value of the first row of the passed sql as a string. If DbNull is the value, A blank string is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <returns>String value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleStringValue(System.String,System.String)">
            <summary>Returns the first value of the first row of the passed sql as a string. If DbNull is the value, a blank string is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>String value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToXml(System.String,System.String,System.String,System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="tagName">The element name to wrap the returned xml element(s). If null or blank, no tag wraps the returned xml string</param>
            <param name="tagAttributes">The attributes to add to the TagName element</param>
            <param name="sql">The SQL to convert to an xml string</param>
            <param name="connectionName">The Connection from Web.config to use</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToXml(System.String,System.String,System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="tagName">The element name to wrap the returned xml element(s). If null or blank, no tag wraps the returned xml string</param>
            <param name="tagAttributes">The attributes to add to the TagName element</param>
            <param name="sql">The SQL to convert to an xml string</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToXml(System.String,System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="sql">The SQL to convert to an xml string</param>
            <param name="connectionName">The Connection from Web.config to use</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToXml(System.String)">
            <summary>Converts a SQL statement into a series of elements via SQLXML. If a "FOR XML" phrase is not found "FOR XML AUTO" is added to the SQL</summary>
            <param name="sql">The SQL to convert to an xml string</param>
            <returns>The xml string attribute based representation of the SQL statement</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataSet(System.String,System.String)">
            <summary>Simply runs the SQL statement and returns a DataSet</summary>
            <param name="sql">The SQL to run</param>
            <param name="connectionName">The Connection from Web.config to use</param>
            <returns>A DataSet object with the results</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataSet(System.String)">
            <summary>Simply runs the SQL statement and returns a DataSet</summary>
            <param name="sql">The SQL to run</param>
            <returns>A DataSet object with the results</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleDateValue(System.String,System.String)">
            <summary>Returns the first column as a DateTime value of the first row of the passed sql. If DbNull is the value, DateTime.MinValue is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>DateTime value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleDateValue(System.String)">
            <summary>Returns the first column as a DateTime value of the first row of the passed sql. If DbNull is the value, DateTime.MinValue is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <returns>DateTime value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleIntegerValue(System.String,System.String,System.Int32)">
            <summary>Returns the first column as an int value of the first row of the passed sql. If DbNull is the value, DefaultReturnValue is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <param name="defaultReturnValue">The value to return if DbNull is encountered</param>
            <returns>int value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleIntegerValue(System.String,System.String)">
            <summary>Returns the first column as an int value of the first row of the passed sql. If DbNull is the value, 0 is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>int value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.RetrieveSingleIntegerValue(System.String)">
            <summary>Returns the first column as an int value of the first row of the passed sql. If DbNull is the value, 0 is returned instead.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one row with one column, it is recommended the SQL be tailored to do so.</param>
            <returns>int value of the first column of the first row</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataTable(System.String,System.String)">
            <summary>Converts the SQL passed in into a DataSet and returns the DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one resultset of values, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>A DataTable object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataTable(System.String)">
            <summary>Converts the SQL passed in into a DataSet and returns the DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one resultset of values, it is recommended the SQL be tailored to do so.</param>
            <returns>A DataTable object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataTable(System.String,System.String,System.Data.DataTable)">
            <summary>Converts the SQL passed in into a DataSet and returns the DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one resultset of values, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <param name="toFill">The DataTable to fill (could be a strongly typed DataTable)</param>
            <returns>A DataTable object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataTable(System.String,System.Data.DataTable)">
            <summary>Converts the SQL passed in into a DataSet and returns the DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one resultset of values, it is recommended the SQL be tailored to do so.</param>
            <param name="toFill">The DataTable to fill (could be a strongly typed DataTable)</param>
            <returns>A DataTable object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataRows(System.String,System.String)">
            <summary>Converts the SQL passed in into a DataSet and returns the DataRowCollection inside the first DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one resultset of values, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>A DataRowCollection object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataRows(System.String)">
            <summary>Converts the SQL passed in into a DataSet and returns the DataRowCollection inside the first DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one resultset of values, it is recommended the SQL be tailored to do so.</param>
            <returns>A DataRowCollection object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataRow(System.String,System.String)">
            <summary>Converts the SQL passed in into a DataSet and returns the first DataRow inside the first DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one DataRow of values, it is recommended the SQL be tailored to do so.</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>A DataRow object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.ToDataRow(System.String)">
            <summary>Converts the SQL passed in into a DataSet and returns the first DataRow inside the first DataTable found, otherwise null is returned.</summary>
            <param name="sql">The sql to return. While it doesn't matter if the SQL actually only returns one DataRow of values, it is recommended the SQL be tailored to do so.</param>
            <returns>A DataRow object representing the SQL statement or null</returns>
        </member>
        <member name="M:MetX.IO.Sql.UpdateNotificationField(System.String,System.String,System.String,System.Int32)">
            <summary>Updates a field in the Notification table for a single NotificationID</summary>
            <param name="notificationId">The NotificationID to update</param>
            <param name="fieldName">The field to update</param>
            <param name="newValue">The new value of the field</param>
            <param name="maxLength">If the field has a maximum length, specify it and this function will insure the field does not exceed that length</param>
            <returns>True if the record was updated</returns>
        </member>
        <member name="M:MetX.IO.Sql.Execute(System.Collections.Generic.List{System.String},System.String)">
            <summary>Executes a series of SQL statements on the same connection</summary>
            <param name="sqlArray">The list of SQLs to execute</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
        </member>
        <member name="M:MetX.IO.Sql.Execute(System.Collections.Generic.List{System.String})">
            <summary>Executes a series of SQL statements on the same Default connection</summary>
            <param name="sqlArray">The list of SQLs to execute</param>
        </member>
        <member name="M:MetX.IO.Sql.Execute(System.String,System.String)">
            <summary>Executes a SQL statement</summary>
            <param name="sql">The SQL to execute</param>
            <param name="connectionName">The name of the connection to use. If that connection doesn't exist, the "Default" connection is used.</param>
            <returns>The number of records affected</returns>
        </member>
        <member name="M:MetX.IO.Sql.Execute(System.String)">
            <summary>Executes a SQL statement</summary>
            <param name="sql">The SQL to execute</param>
            <returns>The number of records affected</returns>
        </member>
        <member name="M:MetX.IO.Sql.GetConnection(System.String)">
            <summary>Returns a SqlConnection object given the connection name from Web.config. If that entry is blank or missing, Default.SqlClient is used.</summary>
            <param name="connectionName">The Web.config key name containing the connection string</param>
            <returns>An open SqlConnection object to the appropriate database (remember to close it)</returns>
        </member>
        <member name="M:MetX.IO.Sql.GetConnectionString(System.String)">
            <summary>Returns the Web.config connection string named. If that entry is blank or missing, Default.SqlClient is returned.</summary>
            <param name="connectionName">The Web.config key name</param>
            <returns>A connection string</returns>
        </member>
        <member name="P:MetX.IO.Sql.DefaultConnectionString">
            <summary>Returns the value of the Web.config key "Default.SqlClient"</summary>
        </member>
        <member name="P:MetX.IO.Sql.DefaultConnection">
            <summary>Returns a SqlClonnetion object using DefaultConnectionString</summary>
        </member>
        <member name="T:MetX.IO.StateCollection">
            <summary>Given two strings (such as a unique userid and the path to a web page),
            StateCollection allows for an arbitrary number of name/value pairs to be quickly loaded and saved to the StateCollection table.</summary>
        </member>
        <member name="F:MetX.IO.StateCollection._mState">
            <summary>The internal sorted list in memory</summary>
        </member>
        <member name="F:MetX.IO.StateCollection.StateParent">
            <summary>The first of two unique strings that identify the secure state to work with.</summary>
        </member>
        <member name="F:MetX.IO.StateCollection.StateName">
            <summary>The second of two unique strings that identify the secure state to work with.</summary>
        </member>
        <member name="F:MetX.IO.StateCollection.TagName">
            <summary>Used by InnerXml, This is the name of each element.</summary>
        </member>
        <member name="F:MetX.IO.StateCollection.ConnectionName">
            <summary>The name of the connection to use to connect to the database. Defaults to 'xlgSecurity'</summary>
        </member>
        <member name="M:MetX.IO.StateCollection.#ctor(System.String,System.String,System.String)">
            <summary>Basic constructor. Does not load a profile, just sets up the properties.</summary>
            <param name="stateParent">The first of two unique strings that identify the secure state to work with. Usually the UserID guid.</param>
            <param name="stateName">The second of two unique strings that identify the secure state to work with. Usually the path to the web page.</param>
            <param name="tagName">Used by InnerXml, This is the name of each element. Usually something like "Profile" or "PageState".</param>
        </member>
        <member name="M:MetX.IO.StateCollection.#ctor(System.String,System.String,System.String,MetX.Library.SortedStringList)">
            <summary>Basic constructor that additionally sets the intial state. Useful when loading state from an existing list or when setting up a new secure state.</summary>
            <param name="stateParent">The first of two unique strings that identify the secure state to work with. Usually the UserID guid.</param>
            <param name="stateName">The second of two unique strings that identify the secure state to work with. Usually the path to the web page.</param>
            <param name="tagName">Used by InnerXml, This is the name of each element. Usually something like "Profile" or "PageState".</param>
            <param name="initialState">The initial set of name/value pairs for the named secure state.</param>
        </member>
        <member name="P:MetX.IO.StateCollection.Item(System.String)">
            <summary>Retrieves/Sets the string value for a name/value pair. If the item doesn't exist, the item will be created.</summary>
        </member>
        <member name="P:MetX.IO.StateCollection.State">
            <summary>The secure state will load the first time this property is called and when a name/value list is not supplied in the constructor. Setting this property will overwrite the entire list.</summary>
        </member>
        <member name="M:MetX.IO.StateCollection.Save">
            <summary>Saves the current state to the StateCollection table. All previous items in the state are deleted.</summary>
        </member>
        <member name="P:MetX.IO.StateCollection.InnerXml">
            <summary>Returns a string containing the xml representation of this state. The elements are wrapped with another element with the same name as TagName followed by an "s". So if TagName = "Item", then InnerXml will return a Items elemnt with one Item element per name/value pair.</summary>
        </member>
        <member name="T:MetX.IO.XlgDataSection">
            <summary>Represents the xlg section in a configuration file</summary>
        </member>
        <member name="P:MetX.IO.XlgDataSection.Providers">
            <summary>Represents a collection of ProviderSettings objects</summary>
        </member>
        <member name="P:MetX.IO.XlgDataSection.DefaultProvider">
            <summary>The default provider to use</summary>
        </member>
        <member name="P:MetX.IO.XlgDataSection.ConnectionStringName">
            <summary>The default connection to use</summary>
        </member>
        <member name="T:MetX.IO.XlgThemeResolver">
            <summary>Implements a XmlResolver which tracks which files are loaded so PageCache dependencies can easily be implemented. Additionally xlg type Theme support is added.</summary>
        </member>
        <member name="F:MetX.IO.XlgThemeResolver.ThemePath">
            <summary>The relative path to the theme directory</summary>
        </member>
        <member name="F:MetX.IO.XlgThemeResolver.PathTrigger">
            <summary>The string within the URL that triggers a conversion</summary>
        </member>
        <member name="F:MetX.IO.XlgThemeResolver.BasePath">
            <summary>The base path for all themes</summary>
        </member>
        <member name="F:MetX.IO.XlgThemeResolver.Transformer">
            <summary>The xml class from the xlgHandler</summary>
        </member>
        <member name="M:MetX.IO.XlgThemeResolver.#ctor(MetX.Library.Xsl,System.String,System.String,System.String,System.String)">
            <summary>Initializes the Theme Resolver</summary>
            <param name="transformer">The xml class from your xlgHandler</param>
            <param name="themeName">The name of the theme (blue, red, YourClientName, etc)</param>
            <param name="pathTrigger">The string within the URL that triggers a conversion. The part of the string so converted.</param>
            <param name="basePath">The relative base path for all themes</param>
            <param name="themePath">The relative path to the specific theme directory</param>
        </member>
        <member name="M:MetX.IO.XlgThemeResolver.#ctor(MetX.Library.Xsl,System.String,System.String,System.String)">
            <summary>Initializes the Theme Resolver</summary>
            <param name="transformer">The xml class from your xlgHandler</param>
            <param name="themeName">The name of the theme (blue, red, YourClientName, etc)</param>
            <param name="pathTrigger">The string within the URL that triggers a conversion. The part of the string so converted.</param>
            <param name="basePath">The relative base path for all themes</param>
        </member>
        <member name="M:MetX.IO.XlgThemeResolver.#ctor(MetX.Library.Xsl,System.String)">
            <summary>Initializes the Theme Resolver. This is the one you should use most often.</summary>
            <param name="transformer">The xml class from your xlgHandler</param>
            <param name="themeName">The name of the theme (blue, red, YourClientName, etc)</param>
        </member>
        <member name="M:MetX.IO.XlgThemeResolver.#ctor(MetX.Library.Xsl)">
            <summary>Initializes the Theme Resolver</summary>
            <param name="transformer">The xml class from your xlgHandler</param>
        </member>
        <member name="P:MetX.IO.XlgThemeResolver.ThemeName">
            <summary>The name of the theme to resolve to (when available)</summary>
        </member>
        <member name="M:MetX.IO.XlgThemeResolver.GetEntity(System.Uri,System.String,System.Type)">
            <summary>Resolves and retrieves the requested entity via URI</summary>
            <param name="absoluteUri">The URI to resolve</param>
            <param name="role">N/A</param>
            <param name="ofObjectToReturn">Type of object to return</param>
            <returns>The resolved entity</returns>
        </member>
        <member name="T:MetX.IO.XlgUrnResolver">
            <summary>Implements a XmlResolver which tracks which files are loaded so PageCache dependencies can easily be implemented</summary>
        </member>
        <member name="F:MetX.IO.XlgUrnResolver.FileEntitys">
            <summary>Only Load has been called on an XSL/XSL document, this will contain a list of the files included by the XSL/XML</summary>
        </member>
        <member name="M:MetX.IO.XlgUrnResolver.OnGetEntity(System.Uri,System.Type)">
            <summary>Maps a URI to an object containing the physical resource. Override this to implement your own functionality</summary>
            <param name="absoluteUri">The URI to retrieve</param>
            <param name="ofObjectToReturn">The type of object to return. Current implementation only returns System.IO.Stream objects</param>
            <returns>The actual resource</returns>
        </member>
        <member name="M:MetX.IO.XlgUrnResolver.#ctor">
            <summary>Basic constructor</summary>
        </member>
        <member name="P:MetX.IO.XlgUrnResolver.Credentials">
            <summary>Provides the base authentication credentials</summary>
        </member>
        <member name="M:MetX.IO.XlgUrnResolver.GetEntity(System.Uri,System.String,System.Type)">
            <summary>Resolves and retrieves the requested entity via URI</summary>
            <param name="absoluteUri">The URI of the entity</param>
            <param name="role">Unknown (see XmlResolver)</param>
            <param name="ofObjectToReturn">Unknown (see XmlResolver)</param>
            <returns>Unknown (see XmlResolver)</returns>
        </member>
        <member name="T:MetX.IO.Attachments">
            <summary>
            Summary description for Attachments.
            </summary>
        </member>
        <member name="F:MetX.IO.Attachments.AppName">
            <summary>The fixed name of the application</summary>
        </member>
        <member name="F:MetX.IO.Attachments.ParentId">
            <summary>A unique identifier relative to the AppName for the resource which contains attachments</summary>
        </member>
        <member name="F:MetX.IO.Attachments.BaseFolder">
            <summary>The folder containing all attachments for the AppName(s)</summary>
        </member>
        <member name="F:MetX.IO.Attachments.DirectoryName">
            <summary>Initially set to BaseFolder + AppName + "\" + ParentID + "\"</summary>
        </member>
        <member name="M:MetX.IO.Attachments.#ctor(System.String,System.String,System.String)">
            <summary>Default constructor</summary>
            <param name="baseFolder">The folder containing the Application's attachments</param>
            <param name="appName">The Application name (sub folder) containing the resource's attachments</param>
            <param name="parentId">The Unique string associated with the specific set of attachments</param>
        </member>
        <member name="P:MetX.IO.Attachments.OuterXml">
            <summary>Retrieves an Xml containins the list of attacments for the AppName/ParentID combination. Element name is "Attachments" with each attachment being a child element named "Attachment" with "Filename" and "Link" attributes.</summary>
        </member>
        <member name="T:MetX.Library.BadStreamBuilderB">
            <summary>
            Duck type (ish) interface similar to StringBuilder only write operations go directly to a stream.
            While several of the functions from StringBuilder are supported, some are not implemented
            due to the fact that said functions would be far less efficient than in memory operations.
            </summary>
        </member>
        <member name="P:MetX.Library.BadStreamBuilderB.CloseOnFinish">
            <summary>
            Set this to true and a call to Finish() or during disposal will automatically close <see cref="P:MetX.Library.BadStreamBuilderB.Target"/>.
            </summary>
        </member>
        <member name="P:MetX.Library.BadStreamBuilderB.FilePath">
            <summary>
            The path and filename being written to. NULL if a stream was passed in.
            </summary>
        </member>
        <member name="P:MetX.Library.BadStreamBuilderB.Length">
            <summary>
            The number of bytes written so far. Note: This may not be the same as the length of the file.
            </summary>
        </member>
        <member name="P:MetX.Library.BadStreamBuilderB.Target">
            <summary>
            The wrapper to targetStream
            </summary>
        </member>
        <member name="P:MetX.Library.BadStreamBuilderB.TargetStream">
            <summary>
            The stream that is ultimately written to
            </summary>
        </member>
        <member name="P:MetX.Library.BadStreamBuilderB.TargetStringBuilder">
            <summary>
            The StringBuilder being written to (for that mode)
            </summary>
        </member>
        <member name="M:MetX.Library.BadStreamBuilderB.#ctor(System.String,System.Boolean)">
            <summary>
            Attaches a new file stream to filePath (overwriting file if there).
            </summary>
            <param name="filePath">Path to the file to write to. NOTE: When append is false, file will be overwritten if it exists.</param>
            <param name="appendToExistingFile">True to start writing at the end of the file.</param>
            <exception cref="T:System.ArgumentNullException">File path is required</exception>
            <exception cref="T:System.ArgumentException"><see cref="P:MetX.Library.BadStreamBuilderB.FilePath" /> is a zero-length string, contains only white space, or contains one or more invalid characters as defined by <see cref="F:System.IO.Path.InvalidPathChars" />.-or- access specified Read and mode specified Create, CreateNew, Truncate, or Append. </exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters. </exception>
            <exception cref="T:System.NotSupportedException"><see cref="P:MetX.Library.BadStreamBuilderB.FilePath" /> is in an invalid format. </exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, (for example, it is on an unmapped drive). </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurred while opening the file. </exception>
            <exception cref="T:System.UnauthorizedAccessException"><see cref="P:MetX.Library.BadStreamBuilderB.FilePath" /> specified a file that is read-only access is not Read.-or- <see cref="P:MetX.Library.BadStreamBuilderB.FilePath" /> specified a directory.-or- The caller does not have the required permission. -or-mode is <see cref="F:System.IO.FileMode.Create" /> and the specified file is a hidden file.</exception>
            <exception cref="T:System.IO.FileNotFoundException">The file specified in <see cref="P:MetX.Library.BadStreamBuilderB.FilePath" /> was not found. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">mode or access specified an invalid value. </exception>
        </member>
        <member name="M:MetX.Library.BadStreamBuilderB.#ctor(System.IO.TextWriter,System.IO.Stream)">
            <summary>
            Attaches to an existing TextWriter (or StreamWriter)
            </summary>
            <param name="textWriter"></param>
            <param name="underlyingStream"></param>
            <exception cref="T:System.ArgumentException"><paramref name="textWriter" /> is null or not writable. </exception>
        </member>
        <member name="M:MetX.Library.BadStreamBuilderB.#ctor(System.Text.StringBuilder)">
            <summary>
            Attaches to an existing TextWriter (or StreamWriter)
            </summary>
            <param name="textWriter"></param>
            <param name="underlyingStream"></param>
        </member>
        <member name="T:MetX.Library.SortedStringList">
            <summary>
            Basic implmentation of a Sorted String List (Basically the same as System.Collections.Generic.SortedList&lt;string, string>)
            </summary>
        </member>
        <member name="M:MetX.Library.SortedStringList.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MetX.Library.SortedStringList.#ctor(System.Int32)">
            <summary>
            Creates a sorted string list with an initial capacity
            </summary>
            <param name="capacity">The initial capacity of the sorted list.</param>
        </member>
        <member name="M:MetX.Library.SortedStringList.ToXml(System.String,System.String)">
            <summary>Retrieves the list as a xml string</summary>
            <param name="tagName">The name of each element and the name of the wrapping element (appending an "s")</param>
            <param name="tagAttributes">Any attributes to be added to the wrapping element</param>
            <returns>An xml string of TagName elements wrapped in a TagName + "s" element with attributes equal to TagAttributes</returns>
        </member>
        <member name="M:MetX.Library.StreamBuilder.AppendLine(System.String)">
            <summary>
            Appends a string to the stream followed by a new line.
            </summary>
            <param name="value">The string to append to the stream</param>
            <exception cref="T:System.ObjectDisposedException"><see cref="P:System.IO.StreamWriter.AutoFlush" /> is true or the <see cref="T:System.IO.StreamWriter" /> buffer is full, and current writer is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="T:MetX.Library.StringExtensions">
            <summary>Provides simple methods for retrieving tokens from a string.
            <para>A token is a piece of a delimited string. For instance in the string "this is a test" when " " (a space) is used as a delimiter, "this" is the first token and "test" is the last (4th) token.</para>
            <para>Asking for a token beyond the end of a string returns a blank string. Asking for the zeroth or a negative token returns a blank string.</para>
            </summary>
        </member>
        <member name="T:MetX.Library.Tokenizer">
            <summary>
                String extension methods for finding and returning a substring based on delimiter placement and position.
            </summary>
        </member>
        <member name="M:MetX.Library.Tokenizer.AllTokens(System.String,System.String,System.StringSplitOptions)">
            <summary>
                Conveniently wraps string.Split for returning a string arr
            </summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">
                The string that separates each token. For instance, In the string "Fred went home", a space ("
                ") would be a common delimiter.
            </param>
            <param name="compare">See <see cref="T:System.StringSplitOptions" /></param>
            <returns>
                NOTE: Never returns null. Each delimited token returned in a string array, with empty entries optionally
                removed.
            </returns>
        </member>
        <member name="M:MetX.Library.Tokenizer.FirstToken(System.String,System.String,System.StringComparison)">
            <summary>Returns the first delimited token in the indicated string</summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">The token delimiter</param>
            <example>
                <code>
             string x = FirstToken("this is a test", " a ");
             // x = "this is"
             </code>
            </example>
        </member>
        <member name="M:MetX.Library.Tokenizer.LastPathToken(System.String)">
            <summary>
                Returns everything after the last backslash (\)
            </summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">
                The string that separates each token. For instance, In the string "Fred went home", a space ("
                ") would be a common delimiter.
            </param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Tokenizer.LastToken(System.String,System.String,System.StringComparison)">
            <summary>Returns the last delimited token from a string</summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">The token delimiter</param>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokenAt(System.String,System.Int32,System.String,System.StringComparison)">
             <summary>
                 Scans 'target' and returns everything before the Nth (token) occurence of 'delimiter' and after the Nth - 1
                 occurence of 'delimiter'.<br />
             </summary>
             <para>
                 By definition, the following is true. When the target string is null or empty, TokenAt returns an empty string.
                 <br />
                 When the delimiter string is null or empty, TokenAt returns the target string.<br />
                 When the delimiter does not appear in the target string, TokenAt returns the target string.<br />
                 Otherwise, TokenAt looks for the Nth occurence of the delimiter string (where N = token) in the target
                 string.<br />
                 It the returns everything between the Nth-1 and Nth occurence of delimiter. If N = 1, then TokenAt just returns
                 everything before the first occurence.<br />
                 If there is no Nth occurence, TokenAt returns an empty string.<br />
                 This function will never return null and throws no exceptions.<br />
                 NOTE: Whenever possible, this function ignores case.
             </para>
             <code>
             string sample = "Fred goes home.";
             string delimiter = " "; // A single space
             string first = sample.TokenAt(1, delimiter);     // first set to "Fred"
             string second = sample.TokenAt(2, delimiter);    // second set to "goes"
             string third = sample.TokenAt(3, delimiter);     // third set to "home."
             string fourth = sample.TokenAt(4, delimiter);    // fourth set to ""
             string tenth = sample.TokenAt(10, delimiter);    // tenth set to ""
             string negative = sample.TokenAt(-2, delimiter); // negative set to ""
            
             sample = "Fred goes home. Fred reads his mail.";
             delimiter = "."; // A single space
             first = sample.TokenAt(1, delimiter);     // first set to "Fred goes home"
             second = sample.TokenAt(2, delimiter);    // second set to " Fred reads his mail"
             third = sample.TokenAt(3, delimiter);     // third set to ""
             </code>
             <param name="target">The string to parse</param>
             <param name="token">
                 The token to return. For instance, with a delimiter of space (" ") and a string "Fred went
                 home.", token could be 1, 2 or 3.
             </param>
             <param name="delimiter">The string inside 'target' which separaters tokens. Defaults to a space (" ").</param>
             <param name="compare"> Specifies the culture, case, and sort rules to be used. Defaults to OrdinalIngoreCase (case insensitive)</param>
             <returns>Returns the substring from 'target' before the Nth (token) occurence of 'delimiter'.</returns>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokenBetween(System.String,System.String,System.String,System.StringComparison)">
            <summary>
                Returns everything after the first occurence of leftDelimiter and before the following occurrene of rightDelimiter
            </summary>
            <param name="target">The string to parse</param>
            <param name="leftDelimiter">
                The first string that separates each token. For instance, In the string "(123) 456-7890",
                open parenthesis("(") would be a common left delimiter.
            </param>
            <param name="rightDelimiter">
                The first string that separates each token. For instance, In the string "(123) 456-7890",
                close parenthesis(")") would be a common right delimiter.
            </param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokenCount(System.String,System.String,System.StringComparison)">
            <summary>Returns the number of tokens in a string</summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">The token delimiter</param>
            <param name="compare"> Specifies the culture, case, and sort rules to be used. Defaults to OrdinalIngoreCase (case insensitive)</param>
            <example>
                <code>
             int x = TokenCount("this is a test", "is");
             // x = 2;
             x = TokenCount("this is a test", " ");
             // x = 4;
             </code>
            </example>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokenIndex(System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Returns the index into target of the first of the Nth token</summary>
            <param name="target">The string to parse</param>
            <param name="token">Which token to find the starting index for (N)</param>
            <param name="delimiter">The token delimiter</param>
            <param name="compare"> Specifies the culture, case, and sort rules to be used. Defaults to OrdinalIngoreCase (case insensitive)</param>
            <example>
                <code>
             int x = TokenIndex("this is a test", 5, " ");
             // x = 5;
             </code>
            </example>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokensAfter(System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Returns all tokens after the indicated token.</summary>
            <param name="target">The string to parse</param>
            <param name="token">The token number to return after</param>
            <param name="delimiter">The token delimiter</param>
            <example>
                <code>
             string x = .After("this is a test", 2, " ");
             // x = "a test"
             </code>
            </example>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokensAfterFirst(System.String,System.String,System.StringComparison)">
            <summary>Returns everything after the first delimited token from a string</summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">The token delimiter</param>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokensAround(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            </summary>
            <param name="target">The string to parse</param>
            <param name="leftDelimiter"></param>
            <param name="rightDelimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokensBefore(System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Returns all tokens before the indicated token.</summary>
            <param name="target">The string to parse</param>
            <param name="token">The token number to return before</param>
            <param name="delimiter">The token delimiter</param>
            <example>
                <code>
             string x = TokensBefore("this is a test", 3, " ");
             // x = "this is"
             </code>
            </example>
        </member>
        <member name="M:MetX.Library.Tokenizer.TokensBeforeLast(System.String,System.String,System.StringComparison)">
            <summary>Returns all tokens before the last token.</summary>
            <param name="target">The string to parse</param>
            <param name="delimiter">The token delimiter</param>
            <example>
                <code>
             string x = TokensBeforeLast("this is a test", 3, " ");
             // x = "this is"
             </code>
            </example>
        </member>
        <member name="T:MetX.Library.Worker">
            <summary>General helper functions</summary>
        </member>
        <member name="M:MetX.Library.Worker.AsString(System.Object,System.String)">
            <summary>Returns the string representation of a value, even if it's DbNull, a Guid, or null</summary>
            <param name="value">The value to convert</param>
            <param name="defaultValue">The value to return if Value == null or DbNull or an empty string.</param>
            <returns>The string representation</returns>
        </member>
        <member name="M:MetX.Library.Worker.NzDouble(System.Object)">
            <summary>Returns the double representation of a value, even if it's DbNull, a Guid, or null</summary>
            <param name="value">The value to convert</param>
            <returns>The double representation</returns>
        </member>
        <member name="M:MetX.Library.Worker.S2Db(System.Object)">
            <summary>Returns a SQL appropriate phrase for an object value. If the object is null or DbNull, the string "NULL" will be returned. Otherwise a single quote delimited string of the value will be created. So if Value='fred', then this function will return "'fred'"</summary>
            <param name="value">The value to convert</param>
            <returns>The SQL appropriate phrase</returns>
            
            <example><c>string x = "insert into x values(" + s2db(y) + ")";</c></example>
        </member>
        <member name="M:MetX.Library.Worker.EmailToName(System.String,System.String)">
            <summary>Extracts a name from an email address</summary>
            <param name="sOriginalText">The Email address</param>
            <param name="defaultName">The default name to use if none is found (or a blank email address is passed in)</param>
            <returns>The extracted proper case name</returns>
        </member>
        <member name="T:MetX.Library.XlgUrn">
            <summary>This class is automatically made available as urn:xlg while rendering xsl pages from any of the MetX.Web xsl rendering classes. Each function provides some string, date, and totaling capability as well as some basic variable storage that can survive template calls.
            <para>NOTE: XSL functions must return a variable. Most functions in this library normally wouldn't return anything, but to accomodate XSL, they return a blank string.</para>
            </summary>
        </member>
        <member name="M:MetX.Library.XlgUrn.HasBit(System.Int32,System.Int32)">
            <summary>
            Returns if one or more bits are set in ToCheck
            </summary>
            <param name="toCheck">The Integer to check</param>
            <param name="mask">The bit mask to check</param>
            <returns>true if all bits set in Mask are set in ToCheck, else false</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SetThemePath(System.String,System.String)">
            <summary>Sets the internal variable 'ThemePath' used with FilePath, FileUrl, and FileContents</summary>
            <param name="themePath">The virtual path to the theme directory (such as '/~/theme/YourClientName/')</param>
            <param name="defaultThemePath">The virtual path to the defalt theme directory (such as '/~/theme/default/')</param>
            <returns>A blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.UrlEncode(System.String)">
            <summary>
            Returns the URL encoded value of the string passed in
            </summary>
            <param name="toEncode">The string to URL encode</param>
            <returns>The URL encoded string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SetSupportPath(System.String)">
            <summary>Sets the internal variable 'Support' used with FilePath, FileUrl, and FileContents</summary>
            <param name="supportPath">The virtual path to the xlgSupport directory (defalts to '/xlgSupport/')</param>
            <returns>A blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetThemePath">
            <summary>Returns the value of the internal variable 'ThemePath'</summary>
            <returns>The value of ThemePath</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetSupportPath">
            <summary>Returns the value of the internal variable 'SupportPath'</summary>
            <returns>The value of SupportPath</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.FileExists(System.String)">
            <summary>
            Same as calling System.IO.File.Exists
            </summary>
            <param name="pathAndFilename">Path and filename to the file</param>
            <returns>True if the file exists</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.DirectoryExists(System.String)">
            <summary>Same as calling System.IO.Directory.Exists</summary>
            <param name="path">The path to test existence for</param>
            <returns>True if the folder exists</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.CreateDirectory(System.String)">
            <summary>Same as calling System.IO.Directory.Create</summary>
            <param name="path">The path to create</param>
            <returns>True if the folder exists</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.InsureDirectory(System.String)">
            <summary>Same as calling System.IO.Directory.Create</summary>
            <param name="path">The path to create</param>
            <returns>True if the folder is created, false if it already existed</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SbAppend(System.String,System.String)">
            <summary>
            Appends a string to an internal string builder
            </summary>
            <param name="sbVarName">The name of the string builder to append to</param>
            <param name="toAppend">The string to append</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SbAppendLine(System.String,System.String)">
            <summary>
            Appends a string to an internal string builder with a new line character at the end
            </summary>
            <param name="sbVarName">The name of the string builder to append to</param>
            <param name="toAppend">The string to append</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SbGetVar(System.String)">
            <summary>
            Retrieves the contents of an internal string builder
            </summary>
            <param name="sbVarName">The string builder to retrieve</param>
            <returns>The string builder contents</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SbRemove(System.String)">
            <summary>
            Removes an internal string builder
            </summary>
            <param name="sbVarName">The string builder to remove</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.RemoveVar(System.String)">
            <summary>Removes a specific internal variable set by SetVar</summary>
            <param name="varName">The variable to remove</param>
            <returns>a blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.ClearVars">
            <summary>Clears all internal (non-xsl) variables</summary>
            <returns>a blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SetVar(System.String,System.String)">
            <summary>Sets an internal variable to some value. This value will persist until changed or until the end of rendering</summary>
            <param name="varName">The variable name to set</param>
            <param name="varValue">The value of the variable</param>
            <returns>a blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetVar(System.String)">
            <summary>Returns the value of an internal variable or a blank string if that variable wasn't set.</summary>
            <param name="varName">The variable to retrieve</param>
            <returns>The variables value or a blank string if not set</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.IsVarSet(System.String)">
            <summary>Returns true if the variable has been set and if the value's length is greater than zero</summary>
            <param name="varName">The variable to test.</param>
            <returns>True if the variable has been set to a non empty string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SHash(System.String)">
            <summary>Creates an incrementing number for the ToHash value and stores it in a table. Each time afterward sHash is called with ToHash, the same value will be returned. Among other things, useful for generating a script block and a short unique div name.</summary>
            <param name="toHash">The item to hash</param>
            <returns>The hash value for the item</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SReplace(System.String,System.String,System.String)">
            <summary>Replaces one string with another. Equivalent to calling string.Replace</summary>
            <param name="toSearch">The text to do the replacement on</param>
            <param name="toFind">The text to find</param>
            <param name="toReplace">The text to replace</param>
            <returns>The string with text replaced.</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.InnerXml(System.Xml.XPath.XPathNodeIterator)">
            <summary>Returns an xml string of the Inner text of one or more Nodes</summary>
            <param name="nodes">The nodes to return InnerXml for</param>
            <returns>The inner xml string of the nodes</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.OuterXml(System.Xml.XPath.XPathNodeIterator)">
            <summary>Returns an xml string of the Outer text of one or more Nodes</summary>
            <param name="nodes">The nodes to return OuterXml for</param>
            <returns>The outer xml string of the nodes</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.OuterXmlJson(System.String,System.Xml.XPath.XPathNodeIterator)">
            <summary>Returns the OuterXml of Nodes in javascript format set to the javascript variable VarName. So this generates a single (usually very long) line of javascript.</summary>
            <param name="varName">The javascript variable name to place the outerxml into</param>
            <param name="nodes">The nodes to javascript code</param>
            <returns>One line of javascript of the form var VarName = "outerxml of Nodes";</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.DateMax(System.String,System.String)">
            <summary>Returns the maximum of two dates</summary>
            <param name="sDate1">The first date to compare</param>
            <param name="sDate2">The second date to compare</param>
            <returns>The greater date</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.DateIsInRange(System.String,System.String,System.String)">
            <summary>Determins if one date is between or equal to two other dates</summary>
            <param name="sDateToTest">The date to test</param>
            <param name="sDateBegin">The lower boundary to test</param>
            <param name="sDateEnd">The upper boundary to test</param>
            <returns>true if sDateToTest is between sDateBegin and sDateEnd</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetToken(System.String,System.Int32,System.String)">
            <summary>Retrieves the nth delimited token</summary>
            <param name="allTokens">The string to retrieve a token from</param>
            <param name="n">The token number to retrieve</param>
            <param name="delimiter">The delimiter separating each token</param>
            <returns>The requested token or a blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.IndexOf(System.String,System.String)">
            <summary>Returns the index of a string inside another string. Equivalent to string.IndexOf</summary>
            <param name="toSearch">The string to search</param>
            <param name="toFind">The string to find</param>
            <returns>The index of ToFind in ToSearch. -1 if nothing is found</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.IsToday(System.String)">
            <summary>Determins if the date passed in is today regardless of the time of day</summary>
            <param name="dateStringToTest">The date to test</param>
            <returns>true if the date is between 00:00am and 11:59pm today</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.IsInThePast(System.String)">
            <summary>Determines if a date is in the past</summary>
            <param name="dateStringToTest">The date to test</param>
            <returns>true if the date is in the past (even by a second)</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.ProperCase(System.String)">
            <summary>Returns the proper case of a string (such as a name). So "this is a test" becomes "This Is A Test".</summary>
            <param name="text">The text to proper case</param>
            <returns>The proper case string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.Today">
            <summary>Returns the current date and time</summary>
            <returns>The current date/time</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.NzDouble(System.String)">
            <summary>Returns the double representation of a string</summary>
            <param name="sOriginalText">The string to convert</param>
            <returns>The double representation of a string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.EmailToName(System.String)">
            <summary>Extracts a name from an email address</summary>
            <param name="sOriginalText">The Email address</param>
            <returns>The extracted proper case name</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.Lower(System.String)">
            <summary>Coverts the passed string to lowercase</summary>
            <param name="sOriginalText">The text to convert</param>
            <returns>The lowercase version of the string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.Upper(System.String)">
            <summary>Coverts the passed string to uppercase</summary>
            <param name="sOriginalText">The text to convert</param>
            <returns>The uppercase version of the string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SXmlAgeOfDate(System.String)">
            <summary>Returns the number of days old the date passed in is or a blank string if it isn't a valid date</summary>
            <param name="xmlDate">The date to calculate</param>
            <returns>The number of days old the date is</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.Expand(System.String)">
            <summary>
            Takes a "StringLikeThis" and adds spaces at each upper case letter, except consecutive upper letters, 
            to make a "String Like This"
            </summary>
            <param name="target">The string to expand</param>
            <returns>The space expanded string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SXmlDateOnlyForJavaScript(System.String,System.String)">
            <summary>Converts an xml date/time into a javascript compatible date</summary>
            <param name="xmlDate">The date/time to convert</param>
            <param name="defaultValue">The value to return if the date passed is blank or invalid</param>
            <returns>The javascript date in MMMM, dd YYYY format</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SXmlDateOnly(System.String)">
            <summary>Converts an xml date/time into a displayable date (MM/dd/YYYY format)</summary>
            <param name="xmlDate">The date to convert</param>
            <returns>The displayable date</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SXmlDate(System.String)">
            <summary>Converts an xml date/time into a displayable date/time value ("MM/dd/YYYY hh:mm tt" format)</summary>
            <param name="xmlDate">The date to convert</param>
            <returns>The displayable date</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.Format(System.Single,System.String)">
            <summary>Formats a number to a particular format (see the VB Format() function).</summary>
            <param name="value">The value to format</param>
            <param name="formatString">The VB.NET format string</param>
            <returns>The formated string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SXmlDate(System.String,System.String)">
            <summary>Converts an xml date/time into a displayable date/time value ("MM/dd/YYYY hh:mm tt" format)</summary>
            <param name="xmlDate">The date to convert</param>
            <param name="sFormat">The VB.NET format string to format the date/time to</param>
            <returns>The formated date/time string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.FirstName(System.String)">
            <summary>Returns the first name (word) from the given string</summary>
            <param name="name">The name to parse</param>
            <returns>The first name found</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.LastName(System.String)">
            <summary>Returns the last name (word) from the given string</summary>
            <param name="name">The name to parse</param>
            <returns>The last name found</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetNextId">
            <summary>Increments an internal counter (NextID) and returns that value.</summary>
            <returns>The next higher ID</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetNextLayer">
            <summary>Subtracts one from the internal layer count (starting at 10,000) and returns that value</summary>
            <returns>The next lower layer</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetNextRowClass">
            <summary>Occilates between returning "contentDataRow1" and "contentDataRow2"</summary>
            <returns>The next row CSS class value</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.ClearTotals">
            <summary>
            Clears the internal list of totals
            </summary>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.ClearTotal(System.String)">
            <summary>Clears the internal total to 0</summary>
            <param name="totalName">The name of the total to clear</param>
            <returns>The string "0"</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.ClearTotal(System.String,System.String)">
            <summary>Clears the internal total to some intial value</summary>
            <param name="totalName">The name of the total to clear</param>
            <param name="sInitialValue">The value to set internal total to</param>
            <returns>an empty string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.AddToTotal(System.String,System.String)">
            <summary>Adds a value to the internal total</summary>
            <param name="totalName">The name of the total</param>
            <param name="toAdd">The value to add to the internal total</param>
            <returns>An empty string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.SubtractFromTotal(System.String,System.String)">
            <summary>Subtracts a value from the internal total</summary>
            <param name="totalName">The name of the total</param>
            <param name="toSubtract">The amount to subtract</param>
            <returns>a blank string</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.GetTotal(System.String,System.Int32)">
            <summary>Returns the current internal total value</summary>
            <param name="totalName">The name of the total</param>
            <param name="decimalPlaces">The number of decimal places to return the internal total (normally 2 or 0)</param>
            <returns>The internal total formatted to the number of decimal places</returns>
        </member>
        <member name="M:MetX.Library.XlgUrn.Distinct(System.Xml.XPath.XPathNodeIterator)">
            <summary>
            Returns a distinct set of nodes
            </summary>
            <param name="nodeset"></param>
            <returns></returns>
        </member>
        <member name="T:MetX.Library.Xml">
            <summary>Helper functions for dealing with xml strings</summary>
        </member>
        <member name="F:MetX.Library.Xml.Declaration">
            <summary>The ?xml directive that should be at the top of each file</summary>
        </member>
        <member name="M:MetX.Library.Xml.ToJson(System.Xml.XmlElement,System.Text.StringBuilder)">
            <summary>Converts an XmlElement into a JSON string and appends it to Target</summary>
            <param name="element">The XmlElment to walk and translate to JSON</param>
            <param name="target">The StringBuilder to append the JSON string into</param>
        </member>
        <member name="M:MetX.Library.Xml.AttributeEncode(System.Object)">
            <summary>For use when you are building an xml string and you need to insure the value of an attribute is properly encoded.</summary>
            <param name="strIn">The text to encode as an xml attribute</param>
            <returns>The xml attribute encoded string</returns>
            
            <example>
            <code>
            string x = "&amp;amp;amp;amp;amp;lt;Item Name=\"" + AttributeEncode("Yes &amp;amp;amp;amp;amp;amp; no") + "\" /&amp;amp;amp;amp;amp;gt;";
            // x = &amp;amp;amp;amp;amp;lt;Item Name="Yes &amp;amp;amp;amp;amp;amp;amp; no" /&amp;amp;amp;amp;amp;gt;
            </code>
            </example>
        </member>
        <member name="M:MetX.Library.Xml.Wrap(System.String,System.String,System.String)">
            <summary>Wraps some text in a tag with optional attributes for that tag. NOTE: tagValue may contain any valid text or XML
            <para>Handles several scenarios when tagValue is blank.</para>
            </summary>
            <param name="tagName">The tag to wrap tagValue in</param>
            <param name="tagValue">The text to wrap as the text node of the wrapping tag</param>
            <param name="tagAttributes">The attributes of the wrapping tag (optional)</param>
            <returns>An xml string with a TagName element having tagAttributes as attributes wrapping tagValue</returns>
            
            <exmaple>
            <code>
            string x = Wrap("Item", "This is a test", "Source=\"Somewhere\"");
            // x = &amp;amp;amp;amp;amp;lt;Item Source="Somewhere"&amp;amp;amp;amp;amp;gt;This is a test&amp;amp;amp;amp;amp;lt;/Item/&amp;amp;amp;amp;amp;gt;
            </code>
            </exmaple>
        </member>
        <member name="M:MetX.Library.Xml.Wrap(System.String,System.String)">
            <summary>Wraps some text in a xml element. NOTE: tagValue may contain any valid text or XML</summary>
            <param name="tagName">The tag to wrap tagValue in</param>
            <param name="tagValue">The text to wrap as the text node of the wrapping tag</param>
            <returns>An xml string with a TagName element wrapping tagValue</returns>
            
            <exmaple>
            <code>
            string x = Wrap("Item", "This is a test");
            // x = &amp;amp;amp;amp;amp;lt;Item&amp;amp;amp;amp;amp;gt;This is a test&amp;amp;amp;amp;amp;lt;/Item/&amp;amp;amp;amp;amp;gt;
            </code>
            </exmaple>
        </member>
        <member name="M:MetX.Library.Xml.Writer(System.IO.Stream)">
            <summary>
            Don't forget to close the XmlWriter or wrap this line in a using statement
            </summary>
            <param name="output">The stream to wrap</param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Xml.Writer(System.IO.TextWriter)">
            <summary>
            Don't forget to close the XmlWriter or wrap this line in a using statement
            </summary>
            <param name="output">The TextWriter to wrap</param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Xml.Writer(System.Text.StringBuilder)">
            <summary>
            Don't forget to close the XmlWriter or wrap this line in a using statement
            </summary>
            <param name="output">The StringBuilder to wrap</param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Xml.FromXml``1(System.String)">
            <summary>
            Turns an xml string into a object
            </summary>
            <typeparam name="T">The type to return a XmlSerializer for</typeparam>
            <param name="xmlDoc">An xml string containing the serialized object</param>
            <returns>The deserializd object</returns>
        </member>
        <member name="M:MetX.Library.Xml.LoadFile``1(System.String)">
            <summary>
            Turns the xml contents of a file into an object
            </summary>
            <typeparam name="T">The type to return a XmlSerializer for</typeparam>
            <param name="filePath">The file to read the xml from</param>
            <returns>The deserializd object</returns>
        </member>
        <member name="M:MetX.Library.Xml.SaveFile``1(System.String,``0)">
            <summary>
            Save a object as xml into a file. If the file is already there it is deleted then recreated with the xml contents of the supplied object.
            </summary>
            <typeparam name="T">The type to return a XmlSerializer for</typeparam>
            <param name="filePath">The file to write the xml to</param>
            <param name="toSerialize">The object to serialize</param>
        </member>
        <member name="M:MetX.Library.Xml.ToXml``1(``0,System.Boolean)">
            <summary>
            Turns an object into an xml string
            </summary>
            <typeparam name="T">The type to return a XmlSerializer for</typeparam>
            <param name="toSerialize">The object to serialize</param>
            <returns></returns>
        </member>
        <member name="M:MetX.Library.Xml.Serializer(System.Type)">
            <summary>
            Returns a XmlSerializer for the given type. Repeated calls pull the serializer previously used. Serializers are stored internally in a sorted list for quick retrieval.
            </summary>
            <param name="t">The type to return a XmlSerializer for</param>
            <returns>The XmlSerializer for the type</returns>
        </member>
        <member name="T:MetX.Library.Xsl">
            <summary>Helper functions for dealing with xsl transformation</summary>
        </member>
        <member name="F:MetX.Library.Xsl.PageCacheSubKey">
            <summary>Set this value when you wish your page's xslt compilation to be cached differently (say per theme, in this case the theme name will be sufficient).</summary>
        </member>
        <member name="M:MetX.Library.Xsl.Transform(System.Xml.XmlDocument,System.String)">
            <summary>Performs an XSL Transformation on an XmlDocument</summary>
            <param name="xmlDocument">The XmlDocument object to transform</param>
            <param name="sXsltDocument">The XSL document</param>
        </member>
        <member name="M:MetX.Library.Xsl.Transform(System.IO.TextWriter,System.Xml.XmlDocument,System.String)">
            <summary>Performs an XSL Transformation on an XmlDocument</summary>
            <param name="xmlDocument">The XmlDocument object to transform</param>
            <param name="sXsltDocument">The XSL document</param>
        </member>
        <member name="M:MetX.Library.Xsl.Transform(System.Text.StringBuilder,System.String)">
            <summary>Performs an XSL Transformation on an XmlDocument optionally pulling the XslCompiledTransform object from the pagecache.</summary>
            <param name="sXmlDocument">The xml string to transform</param>
            <param name="xsltPath">The path and filename of the XSL file to load</param>
            <returns>The transformed text</returns>
        </member>
        <member name="M:MetX.Library.Xsl.Transform(System.Text.StringBuilder,System.String,System.Text.StringBuilder)">
            <summary>Performs an XSL Transformation on an XmlDocument optionally pulling the XslCompiledTransform object from the pagecache.</summary>
            <param name="pageCache">The PageCache object to retreive/store the XslCompiledTrasform from/to. If null, no caching is performed</param>
            <param name="sXmlDocument">The xml string to transform</param>
            <param name="xsltPath">The path and filename of the XSL file to load</param>
            <param name="xsltDocumentContent">If supplied, the xsl stylesheet is assumed to already be loaded here. xsltPath is then used as a key to cache the request</param>
            <returns>The transformed text</returns>
        </member>
        <member name="P:MetX.Library.Xsl.UrlResolver">
            <summary>Returns the page specific xlgUrnResolver or a default object if not specified.
            <para>NOTE: You can set this proprety in PreBuild() or BuildXml() to override it with your own implementation.</para>
            </summary>
        </member>
        <member name="P:MetX.Library.Xsl.XlgUrn">
            <summary>Automatically set to a new xlgUrn unless you supply your own..
            <para>NOTE: You can set this proprety in PreBuild() or BuildXml() to override it with your own implementation.</para>
            </summary>
        </member>
        <member name="P:MetX.Library.Xsl.Urns">
            <summary>Returns XsltArgumentList containing a xlgUrn object and an optional object named in xlgSecurity.UrnName and xlgSecurity.UrnClass.
            <para>NOTE: You can set this proprety in PreBuild() or BuildXml() to override it with your own implementation.</para>
            </summary>
        </member>
        <member name="T:MetX.Pipelines.CodeGenerator">
            <summary>Generates Data and xlg specific code</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.SpClassName">
            <summary>The class name to contain the Stored Procedures</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.CSharpKeywords">
            <summary>
            List of all the C# keywords
            </summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.Namespace">
            <summary>The namespace that should be passed into the XSL</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.VDirName">
            <summary>Set internally (overridden externally) indicating the base vitual directory.</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.VirtualPath">
            <summary>Set externally indicating the path/virtual (sub directory) path to any overriding template(s).</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.VirtualxlgFilePath">
            <summary>Set externally indicating the file of any overriding template(s)</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.XlgDataXml">
            <summary>The Data XML file to generate against</summary>
        </member>
        <member name="F:MetX.Pipelines.CodeGenerator.XlgFilename">
            <summary>The file containing the XSL to render code against.
            <para>NOTE: This file does not have to exist. If it doesn't the internal XSL rendering C# will be used.</para>
            </summary>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.#ctor">
            <summary>Default constructor. Does nothing</summary>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.#ctor(System.String,System.String,System.String,System.Windows.Forms.Form)">
            <summary>Internally sets VirtualPath, VirtualxlgFilePath, xlgDataXml, Namespace, and VDirName based on VirtualxlgFilePath</summary>
        </member>
        <member name="P:MetX.Pipelines.CodeGenerator.DataXml">
            <summary>
            Returns an XmlDocument containing a xlgData document with the child elements: Tables, StoredProcedures, and Xsls relative to the list indicated by the supplied include/skip lists.
            </summary>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GenerateCode">
            <summary>Causes generation and returns the code/contents generated</summary>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.RegenerateCode(System.Xml.XmlDocument)">
            <summary>Causes generation and returns the code/contents generated</summary>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetVirtualFile(System.String)">
            <summary>Loads a file from the virutal file system relative to VirtualPath</summary>
            <param name="virtualFilename">The Virtual file to load</param>
            <returns>The contents of the virtual file</returns>
        </member>
        <member name="T:MetX.Pipelines.CodeGenerator.Helper">
            <summary>
            Helper function for loading a virtual file from the virtual file system
            </summary>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.Helper.GenerateViaXsl(System.Xml.XmlDocument,System.String)">
            <summary>Performs a simple XSL transformation on a XmlDocument object</summary>
            <param name="xmlDoc">The XmlDocument to convert</param>
            <param name="sXsl">The XSLT contents to use in the conversion.</param>
            <returns>The rendered content</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.Helper.GetVirtualFile(System.String)">
            <summary>Load a file from the virtual file system</summary>
            <param name="virtualFilename">The virtual path and file to load</param>
            <returns>The contents of the virtual file</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.Helper.VirtualPathToPhysical(System.String)">
            <summary>Attemptes to convert a virtual path into a physical one. Physical path is not guarenteed to exist.</summary>
            <param name="virtualPath">The virtual path to map</param>
            <returns>The physical file system path represented by VirtualPath</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetClassName(System.String)">
            <summary>Translates a table name into a CLSCompliant class name</summary>
            <param name="tableName">The name of the table, stored procedure, etc to translate</param>
            <returns>The translated class name</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetConvertToPart(System.Data.DbType)">
            <summary>Translates a DbType into the .net equivalent type to convert another value to (so "Currency" becomes "Convert.ToCurrency")</summary>
            <param name="dbType">The DbType to convert</param>
            <returns>The portion of code necessary to convert another value to the same type as this</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetCSharpVariableType(System.Data.DbType)">
            <summary>Translates a DbType into the C# equivalent type (so "Currency" becomes "Decimal")</summary>
            <param name="dbType">The DbType to convert</param>
            <returns>The C# type string</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetIsDotNetObject(System.Data.DbType)">
            <summary>Translates a DbType into the C# equivalent type (so "Currency" becomes "Decimal")</summary>
            <param name="dbType">The DbType to convert</param>
            <returns>The C# type string</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetProperName(System.String,System.String,System.String,System.Boolean)">
            <summary>Generates a proper case representation of a string (so "fred" becomes "Fred")</summary>
            <returns>The proper case translation</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetProperName(System.String)">
            <summary>Generates a proper case representation of a string (so "fred" becomes "Fred")</summary>
            <returns>The proper case translation</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.GetVbVariableType(System.Data.DbType)">
            <summary>Translates a DbType into the VB.NET equivalent type (so "Currency" becomes "Decimal")</summary>
            <param name="dbType">The DbType to convert</param>
            <returns>The VB.NET type string</returns>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.AddAttribute(System.Xml.XmlElement,System.String,System.String)">
            <summary>Simplified way of adding an attribute to a XmlElement</summary>
            <param name="target">The XmlElement to add the attribute to</param>
            <param name="attributeName">The name of the attribute to add</param>
            <param name="attributeValue">The value of the attribute to add</param>
        </member>
        <member name="M:MetX.Pipelines.CodeGenerator.AddElement(System.Xml.XmlElement,System.String,System.String,System.String)">
            <summary>Simplified way of adding an XmlElement to a XmlDocument</summary>
            <param name="target">The XmlDocment to add the Element onto</param>
            <param name="elementName">The node name of the element</param>
            <param name="attributeName">Name of an attribute to add</param>
            <param name="attributeValue">Value of the attribute</param>
            <returns>The XmlElement added</returns>
        </member>
        <member name="T:MetX.Pipelines.DefaultXlg">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Pipelines.DefaultXlg.Xml">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Data\DataDefault.xml" as it existed at compile time.</summary>
        </member>
        <member name="T:MetX.Pipelines.XlgFile">
            <summary>
            Represents a file
            </summary>
        </member>
        <member name="T:MetX.Pipelines.XlgFolder">
            <summary>
            Represents a library to generate
            </summary>
        </member>
        <member name="T:MetX.Pipelines.XlgSource">
            <summary>
            Represents a library to generate
            </summary>
        </member>
        <member name="T:MetX.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584661_4">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584690_2">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584694_2">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584753_Cut">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584808_Copy">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584898_clipboard">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584916_Noun_Project_100Icon_10px_grid_06_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources._1421584946_file_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.add_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.arrow_down_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.cancel_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.circle_blue">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.circle_green">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.circle_orange">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.cross_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.database_add_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.database_remove_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.floppy_disk_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.folder_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:MetX.Properties.Resources.refresh_48">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="T:MetX.Scripts.XlgQuickScript">
            <summary>
                Represents a clipboard processing script
            </summary>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.Applications">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.Applications.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\applications.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.Applications.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.EditApplication">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.EditApplication.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\editApplication.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.EditApplication.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.EditCookie">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.EditCookie.Xsl">
            <summary>The static contents of the file: "C:\data\code\xlg\MetX\Web\Virtual\xsl\editCookie.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.EditCookie.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.EditMembers">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.EditMembers.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\editMembers.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.EditMembers.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.EditMenuUrl">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.EditMenuUrl.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\editMenuUrl.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.EditMenuUrl.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.EditMindset">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.EditMindset.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\editMindset.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.EditMindset.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.EditPermissions">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.EditPermissions.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\editPermissions.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.EditPermissions.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.Mindsets">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.Mindsets.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\mindsets.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.Mindsets.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:MetX.Web.Virtual.xsl.XmlToJson">
            <summary>Provides access to static virtual file content for files</summary>
        </member>
        <member name="F:MetX.Web.Virtual.xsl.XmlToJson.Xsl">
            <summary>The static contents of the file: "C:\data\code\wmr\MetX\Web\Virtual\xsl\XmlToJson.xsl" as it existed at compile time.</summary>
        </member>
        <member name="P:MetX.Web.Virtual.xsl.XmlToJson.XslStringBuilder">
            <summary>Returns xsl inside a StringBuilder.</summary>
            <returns>A StringBuilder with the compile time file contents</returns>
        </member>
        <member name="T:Metta.Web.Virtual.xsl.Resource">
            <summary>C#CD: </summary>
        </member>
        <member name="M:Metta.Web.Virtual.xsl.Resource.Get(System.String)">
            <summary>C#CD: </summary>
            <param name="resourceName">C#CD: </param>
        </member>
    </members>
</doc>
